/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./server.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../cmake-build-debug/craft_gen.js":
/*!*****************************************!*\
  !*** ../cmake-build-debug/craft_gen.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(__dirname) {// The Module object: Our interface to the outside world. We import\n// and export values on it. There are various ways Module can be used:\n// 1. Not defined. We create it here\n// 2. A function parameter, function(Module) { ..generated code.. }\n// 3. pre-run appended it, var Module = {}; ..generated code..\n// 4. External script tag defines var Module.\n// We need to check if Module already exists (e.g. case 3 above).\n// Substitution will be replaced with actual code on later stage of the build,\n// this way Closure Compiler will not mangle it (e.g. case 4. above).\n// Note that if you want to run closure, and also to use Module\n// after the generated code, you will need to define   var Module = {};\n// before the code. Then that object will be used in the code, and you\n// can continue to use Module afterwards as well.\nvar Module = typeof Module !== 'undefined' ? Module : {}; // --pre-jses are emitted after the Module integration code, so that they can\n// refer to Module (if they choose; they can also define Module)\n// {{PRE_JSES}}\n// Sometimes an existing Module object exists with properties\n// meant to overwrite the default module functionality. Here\n// we collect those properties and reapply _after_ we configure\n// the current environment's defaults to avoid having to be so\n// defensive during initialization.\n\nvar moduleOverrides = {};\nvar key;\n\nfor (key in Module) {\n  if (Module.hasOwnProperty(key)) {\n    moduleOverrides[key] = Module[key];\n  }\n}\n\nModule['arguments'] = [];\nModule['thisProgram'] = './this.program';\n\nModule['quit'] = function (status, toThrow) {\n  throw toThrow;\n};\n\nModule['preRun'] = [];\nModule['postRun'] = []; // The environment setup code below is customized to use Module.\n// *** Environment setup code ***\n\nvar ENVIRONMENT_IS_WEB = false;\nvar ENVIRONMENT_IS_WORKER = false;\nvar ENVIRONMENT_IS_NODE = false;\nvar ENVIRONMENT_IS_SHELL = false;\nENVIRONMENT_IS_WEB = typeof window === 'object';\nENVIRONMENT_IS_WORKER = typeof importScripts === 'function';\nENVIRONMENT_IS_NODE = typeof process === 'object' && \"function\" === 'function' && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;\nENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n\nif (Module['ENVIRONMENT']) {\n  throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)');\n} // Three configurations we can be running in:\n// 1) We could be the application main() thread running in the main JS UI thread. (ENVIRONMENT_IS_WORKER == false and ENVIRONMENT_IS_PTHREAD == false)\n// 2) We could be the application main() thread proxied to worker. (with Emscripten -s PROXY_TO_WORKER=1) (ENVIRONMENT_IS_WORKER == true, ENVIRONMENT_IS_PTHREAD == false)\n// 3) We could be an application pthread running in a worker. (ENVIRONMENT_IS_WORKER == true and ENVIRONMENT_IS_PTHREAD == true)\n\n\nassert(typeof Module['memoryInitializerPrefixURL'] === 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['pthreadMainPrefixURL'] === 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['cdInitializerPrefixURL'] === 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['filePackagePrefixURL'] === 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead'); // `/` should be present at the end if `scriptDirectory` is not empty\n\nvar scriptDirectory = '';\n\nfunction locateFile(path) {\n  if (Module['locateFile']) {\n    return Module['locateFile'](path, scriptDirectory);\n  } else {\n    return scriptDirectory + path;\n  }\n}\n\nif (ENVIRONMENT_IS_NODE) {\n  scriptDirectory = __dirname + '/'; // Expose functionality in the same simple way that the shells work\n  // Note that we pollute the global namespace here, otherwise we break in node\n\n  var nodeFS;\n  var nodePath;\n\n  Module['read'] = function shell_read(filename, binary) {\n    var ret;\n    ret = tryParseAsDataURI(filename);\n\n    if (!ret) {\n      if (!nodeFS) nodeFS = __webpack_require__(/*! fs */ \"fs\");\n      if (!nodePath) nodePath = __webpack_require__(/*! path */ \"path\");\n      filename = nodePath['normalize'](filename);\n      ret = nodeFS['readFileSync'](filename);\n    }\n\n    return binary ? ret : ret.toString();\n  };\n\n  Module['readBinary'] = function readBinary(filename) {\n    var ret = Module['read'](filename, true);\n\n    if (!ret.buffer) {\n      ret = new Uint8Array(ret);\n    }\n\n    assert(ret.buffer);\n    return ret;\n  };\n\n  if (process['argv'].length > 1) {\n    Module['thisProgram'] = process['argv'][1].replace(/\\\\/g, '/');\n  }\n\n  Module['arguments'] = process['argv'].slice(2);\n\n  if (true) {\n    module['exports'] = Module;\n  }\n\n  process['on']('uncaughtException', function (ex) {\n    // suppress ExitStatus exceptions from showing an error\n    if (!(ex instanceof ExitStatus)) {\n      throw ex;\n    }\n  }); // Currently node will swallow unhandled rejections, but this behavior is\n  // deprecated, and in the future it will exit with error status.\n\n  process['on']('unhandledRejection', function (reason, p) {\n    err('node.js exiting due to unhandled promise rejection');\n    process['exit'](1);\n  });\n\n  Module['quit'] = function (status) {\n    process['exit'](status);\n  };\n\n  Module['inspect'] = function () {\n    return '[Emscripten Module object]';\n  };\n} else if (ENVIRONMENT_IS_SHELL) {\n  if (typeof read != 'undefined') {\n    Module['read'] = function shell_read(f) {\n      var data = tryParseAsDataURI(f);\n\n      if (data) {\n        return intArrayToString(data);\n      }\n\n      return read(f);\n    };\n  }\n\n  Module['readBinary'] = function readBinary(f) {\n    var data;\n    data = tryParseAsDataURI(f);\n\n    if (data) {\n      return data;\n    }\n\n    if (typeof readbuffer === 'function') {\n      return new Uint8Array(readbuffer(f));\n    }\n\n    data = read(f, 'binary');\n    assert(typeof data === 'object');\n    return data;\n  };\n\n  if (typeof scriptArgs != 'undefined') {\n    Module['arguments'] = scriptArgs;\n  } else if (typeof arguments != 'undefined') {\n    Module['arguments'] = arguments;\n  }\n\n  if (typeof quit === 'function') {\n    Module['quit'] = function (status) {\n      quit(status);\n    };\n  }\n} else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n  if (ENVIRONMENT_IS_WEB) {\n    if (document.currentScript) {\n      scriptDirectory = document.currentScript.src;\n    }\n  } else {\n    // worker\n    scriptDirectory = self.location.href;\n  } // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\n  // otherwise, slice off the final part of the url to find the script directory.\n\n\n  if (scriptDirectory.indexOf('blob:') !== 0) {\n    scriptDirectory = scriptDirectory.split('/').slice(0, -1).join('/') + '/';\n  } else {\n    scriptDirectory = '';\n  }\n\n  Module['read'] = function shell_read(url) {\n    try {\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', url, false);\n      xhr.send(null);\n      return xhr.responseText;\n    } catch (err) {\n      var data = tryParseAsDataURI(url);\n\n      if (data) {\n        return intArrayToString(data);\n      }\n\n      throw err;\n    }\n  };\n\n  if (ENVIRONMENT_IS_WORKER) {\n    Module['readBinary'] = function readBinary(url) {\n      try {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, false);\n        xhr.responseType = 'arraybuffer';\n        xhr.send(null);\n        return new Uint8Array(xhr.response);\n      } catch (err) {\n        var data = tryParseAsDataURI(url);\n\n        if (data) {\n          return data;\n        }\n\n        throw err;\n      }\n    };\n  }\n\n  Module['readAsync'] = function readAsync(url, onload, onerror) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'arraybuffer';\n\n    xhr.onload = function xhr_onload() {\n      if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n        // file URLs can return 0\n        onload(xhr.response);\n        return;\n      }\n\n      var data = tryParseAsDataURI(url);\n\n      if (data) {\n        onload(data.buffer);\n        return;\n      }\n\n      onerror();\n    };\n\n    xhr.onerror = onerror;\n    xhr.send(null);\n  };\n\n  Module['setWindowTitle'] = function (title) {\n    document.title = title;\n  };\n} else {\n  throw new Error('environment detection error');\n} // Set up the out() and err() hooks, which are how we can print to stdout or\n// stderr, respectively.\n// If the user provided Module.print or printErr, use that. Otherwise,\n// console.log is checked first, as 'print' on the web will open a print dialogue\n// printErr is preferable to console.warn (works better in shells)\n// bind(console) is necessary to fix IE/Edge closed dev tools panel behavior.\n\n\nvar out = Module['print'] || (typeof console !== 'undefined' ? console.log.bind(console) : typeof print !== 'undefined' ? print : null);\nvar err = Module['printErr'] || (typeof printErr !== 'undefined' ? printErr : typeof console !== 'undefined' && console.warn.bind(console) || out); // *** Environment setup code ***\n// Merge back in the overrides\n\nfor (key in moduleOverrides) {\n  if (moduleOverrides.hasOwnProperty(key)) {\n    Module[key] = moduleOverrides[key];\n  }\n} // Free the object hierarchy contained in the overrides, this lets the GC\n// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\n\n\nmoduleOverrides = undefined; // {{PREAMBLE_ADDITIONS}}\n\nvar STACK_ALIGN = 16; // stack management, and other functionality that is provided by the compiled code,\n// should not be used before it is ready\n\nstackSave = stackRestore = stackAlloc = setTempRet0 = getTempRet0 = function () {\n  abort('cannot use the stack before compiled code is ready to run, and has provided stack access');\n};\n\nfunction staticAlloc(size) {\n  assert(!staticSealed);\n  var ret = STATICTOP;\n  STATICTOP = STATICTOP + size + 15 & -16;\n  assert(STATICTOP < TOTAL_MEMORY, 'not enough memory for static allocation - increase TOTAL_MEMORY');\n  return ret;\n}\n\nfunction dynamicAlloc(size) {\n  assert(DYNAMICTOP_PTR);\n  var ret = HEAP32[DYNAMICTOP_PTR >> 2];\n  var end = ret + size + 15 & -16;\n  HEAP32[DYNAMICTOP_PTR >> 2] = end;\n\n  if (end >= TOTAL_MEMORY) {\n    var success = enlargeMemory();\n\n    if (!success) {\n      HEAP32[DYNAMICTOP_PTR >> 2] = ret;\n      return 0;\n    }\n  }\n\n  return ret;\n}\n\nfunction alignMemory(size, factor) {\n  if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default\n\n  var ret = size = Math.ceil(size / factor) * factor;\n  return ret;\n}\n\nfunction getNativeTypeSize(type) {\n  switch (type) {\n    case 'i1':\n    case 'i8':\n      return 1;\n\n    case 'i16':\n      return 2;\n\n    case 'i32':\n      return 4;\n\n    case 'i64':\n      return 8;\n\n    case 'float':\n      return 4;\n\n    case 'double':\n      return 8;\n\n    default:\n      {\n        if (type[type.length - 1] === '*') {\n          return 4; // A pointer\n        } else if (type[0] === 'i') {\n          var bits = parseInt(type.substr(1));\n          assert(bits % 8 === 0);\n          return bits / 8;\n        } else {\n          return 0;\n        }\n      }\n  }\n}\n\nfunction warnOnce(text) {\n  if (!warnOnce.shown) warnOnce.shown = {};\n\n  if (!warnOnce.shown[text]) {\n    warnOnce.shown[text] = 1;\n    err(text);\n  }\n}\n\nvar asm2wasmImports = {\n  // special asm2wasm imports\n  \"f64-rem\": function (x, y) {\n    return x % y;\n  },\n  \"debugger\": function () {\n    debugger;\n  }\n};\nvar jsCallStartIndex = 1;\nvar functionPointers = new Array(0); // 'sig' parameter is only used on LLVM wasm backend\n\nfunction addFunction(func, sig) {\n  if (typeof sig === 'undefined') {\n    err('warning: addFunction(): You should provide a wasm function signature string as a second argument. This is not necessary for asm.js and asm2wasm, but is required for the LLVM wasm backend, so it is recommended for full portability.');\n  }\n\n  var base = 0;\n\n  for (var i = base; i < base + 0; i++) {\n    if (!functionPointers[i]) {\n      functionPointers[i] = func;\n      return jsCallStartIndex + i;\n    }\n  }\n\n  throw 'Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.';\n}\n\nfunction removeFunction(index) {\n  functionPointers[index - jsCallStartIndex] = null;\n}\n\nvar funcWrappers = {};\n\nfunction getFuncWrapper(func, sig) {\n  if (!func) return; // on null pointer, return undefined\n\n  assert(sig);\n\n  if (!funcWrappers[sig]) {\n    funcWrappers[sig] = {};\n  }\n\n  var sigCache = funcWrappers[sig];\n\n  if (!sigCache[func]) {\n    // optimize away arguments usage in common cases\n    if (sig.length === 1) {\n      sigCache[func] = function dynCall_wrapper() {\n        return dynCall(sig, func);\n      };\n    } else if (sig.length === 2) {\n      sigCache[func] = function dynCall_wrapper(arg) {\n        return dynCall(sig, func, [arg]);\n      };\n    } else {\n      // general case\n      sigCache[func] = function dynCall_wrapper() {\n        return dynCall(sig, func, Array.prototype.slice.call(arguments));\n      };\n    }\n  }\n\n  return sigCache[func];\n}\n\nfunction makeBigInt(low, high, unsigned) {\n  return unsigned ? +(low >>> 0) + +(high >>> 0) * 4294967296.0 : +(low >>> 0) + +(high | 0) * 4294967296.0;\n}\n\nfunction dynCall(sig, ptr, args) {\n  if (args && args.length) {\n    assert(args.length == sig.length - 1);\n    assert('dynCall_' + sig in Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\n    return Module['dynCall_' + sig].apply(null, [ptr].concat(args));\n  } else {\n    assert(sig.length == 1);\n    assert('dynCall_' + sig in Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\n    return Module['dynCall_' + sig].call(null, ptr);\n  }\n}\n\nfunction getCompilerSetting(name) {\n  throw 'You must build with -s RETAIN_COMPILER_SETTINGS=1 for getCompilerSetting or emscripten_get_compiler_setting to work';\n}\n\nvar Runtime = {\n  // FIXME backwards compatibility layer for ports. Support some Runtime.*\n  //       for now, fix it there, then remove it from here. That way we\n  //       can minimize any period of breakage.\n  dynCall: dynCall,\n  // for SDL2 port\n  // helpful errors\n  getTempRet0: function () {\n    abort('getTempRet0() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"');\n  },\n  staticAlloc: function () {\n    abort('staticAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"');\n  },\n  stackAlloc: function () {\n    abort('stackAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"');\n  }\n}; // The address globals begin at. Very low in memory, for code size and optimization opportunities.\n// Above 0 is static memory, starting with globals.\n// Then the stack.\n// Then 'dynamic' memory for sbrk.\n\nvar GLOBAL_BASE = 8; // === Preamble library stuff ===\n// Documentation for the public APIs defined in this file must be updated in:\n//    site/source/docs/api_reference/preamble.js.rst\n// A prebuilt local version of the documentation is available at:\n//    site/build/text/docs/api_reference/preamble.js.txt\n// You can also build docs locally as HTML or other formats in site/\n// An online HTML version (which may be of a different version of Emscripten)\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n//========================================\n// Runtime essentials\n//========================================\n\nvar ABORT = 0; // whether we are quitting the application. no code should run after this. set in exit() and abort()\n\nvar EXITSTATUS = 0;\n/** @type {function(*, string=)} */\n\nfunction assert(condition, text) {\n  if (!condition) {\n    abort('Assertion failed: ' + text);\n  }\n}\n\nvar globalScope = this; // Returns the C function with a specified identifier (for C++, you need to do manual name mangling)\n\nfunction getCFunc(ident) {\n  var func = Module['_' + ident]; // closure exported function\n\n  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');\n  return func;\n}\n\nvar JSfuncs = {\n  // Helpers for cwrap -- it can't refer to Runtime directly because it might\n  // be renamed by closure, instead it calls JSfuncs['stackSave'].body to find\n  // out what the minified function name is.\n  'stackSave': function () {\n    stackSave();\n  },\n  'stackRestore': function () {\n    stackRestore();\n  },\n  // type conversion from js to c\n  'arrayToC': function (arr) {\n    var ret = stackAlloc(arr.length);\n    writeArrayToMemory(arr, ret);\n    return ret;\n  },\n  'stringToC': function (str) {\n    var ret = 0;\n\n    if (str !== null && str !== undefined && str !== 0) {\n      // null string\n      // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\n      var len = (str.length << 2) + 1;\n      ret = stackAlloc(len);\n      stringToUTF8(str, ret, len);\n    }\n\n    return ret;\n  }\n}; // For fast lookup of conversion functions\n\nvar toC = {\n  'string': JSfuncs['stringToC'],\n  'array': JSfuncs['arrayToC']\n}; // C calling interface.\n\nfunction ccall(ident, returnType, argTypes, args, opts) {\n  function convertReturnValue(ret) {\n    if (returnType === 'string') return Pointer_stringify(ret);\n    if (returnType === 'boolean') return Boolean(ret);\n    return ret;\n  }\n\n  var func = getCFunc(ident);\n  var cArgs = [];\n  var stack = 0;\n  assert(returnType !== 'array', 'Return type should not be \"array\".');\n\n  if (args) {\n    for (var i = 0; i < args.length; i++) {\n      var converter = toC[argTypes[i]];\n\n      if (converter) {\n        if (stack === 0) stack = stackSave();\n        cArgs[i] = converter(args[i]);\n      } else {\n        cArgs[i] = args[i];\n      }\n    }\n  }\n\n  var ret = func.apply(null, cArgs);\n  ret = convertReturnValue(ret);\n  if (stack !== 0) stackRestore(stack);\n  return ret;\n}\n\nfunction cwrap(ident, returnType, argTypes, opts) {\n  return function () {\n    return ccall(ident, returnType, argTypes, arguments, opts);\n  };\n}\n/** @type {function(number, number, string, boolean=)} */\n\n\nfunction setValue(ptr, value, type, noSafe) {\n  type = type || 'i8';\n  if (type.charAt(type.length - 1) === '*') type = 'i32'; // pointers are 32-bit\n\n  switch (type) {\n    case 'i1':\n      HEAP8[ptr >> 0] = value;\n      break;\n\n    case 'i8':\n      HEAP8[ptr >> 0] = value;\n      break;\n\n    case 'i16':\n      HEAP16[ptr >> 1] = value;\n      break;\n\n    case 'i32':\n      HEAP32[ptr >> 2] = value;\n      break;\n\n    case 'i64':\n      tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1.0 ? tempDouble > 0.0 ? (Math_min(+Math_floor(tempDouble / 4294967296.0), 4294967295.0) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];\n      break;\n\n    case 'float':\n      HEAPF32[ptr >> 2] = value;\n      break;\n\n    case 'double':\n      HEAPF64[ptr >> 3] = value;\n      break;\n\n    default:\n      abort('invalid type for setValue: ' + type);\n  }\n}\n/** @type {function(number, string, boolean=)} */\n\n\nfunction getValue(ptr, type, noSafe) {\n  type = type || 'i8';\n  if (type.charAt(type.length - 1) === '*') type = 'i32'; // pointers are 32-bit\n\n  switch (type) {\n    case 'i1':\n      return HEAP8[ptr >> 0];\n\n    case 'i8':\n      return HEAP8[ptr >> 0];\n\n    case 'i16':\n      return HEAP16[ptr >> 1];\n\n    case 'i32':\n      return HEAP32[ptr >> 2];\n\n    case 'i64':\n      return HEAP32[ptr >> 2];\n\n    case 'float':\n      return HEAPF32[ptr >> 2];\n\n    case 'double':\n      return HEAPF64[ptr >> 3];\n\n    default:\n      abort('invalid type for getValue: ' + type);\n  }\n\n  return null;\n}\n\nvar ALLOC_NORMAL = 0; // Tries to use _malloc()\n\nvar ALLOC_STACK = 1; // Lives for the duration of the current function call\n\nvar ALLOC_STATIC = 2; // Cannot be freed\n\nvar ALLOC_DYNAMIC = 3; // Cannot be freed except through sbrk\n\nvar ALLOC_NONE = 4; // Do not allocate\n// allocate(): This is for internal use. You can use it yourself as well, but the interface\n//             is a little tricky (see docs right below). The reason is that it is optimized\n//             for multiple syntaxes to save space in generated code. So you should\n//             normally not use allocate(), and instead allocate memory using _malloc(),\n//             initialize it with setValue(), and so forth.\n// @slab: An array of data, or a number. If a number, then the size of the block to allocate,\n//        in *bytes* (note that this is sometimes confusing: the next parameter does not\n//        affect this!)\n// @types: Either an array of types, one for each byte (or 0 if no type at that position),\n//         or a single type which is used for the entire block. This only matters if there\n//         is initial data - if @slab is a number, then this does not matter at all and is\n//         ignored.\n// @allocator: How to allocate memory, see ALLOC_*\n\n/** @type {function((TypedArray|Array<number>|number), string, number, number=)} */\n\nfunction allocate(slab, types, allocator, ptr) {\n  var zeroinit, size;\n\n  if (typeof slab === 'number') {\n    zeroinit = true;\n    size = slab;\n  } else {\n    zeroinit = false;\n    size = slab.length;\n  }\n\n  var singleType = typeof types === 'string' ? types : null;\n  var ret;\n\n  if (allocator == ALLOC_NONE) {\n    ret = ptr;\n  } else {\n    ret = [typeof _malloc === 'function' ? _malloc : staticAlloc, stackAlloc, staticAlloc, dynamicAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length));\n  }\n\n  if (zeroinit) {\n    var stop;\n    ptr = ret;\n    assert((ret & 3) == 0);\n    stop = ret + (size & ~3);\n\n    for (; ptr < stop; ptr += 4) {\n      HEAP32[ptr >> 2] = 0;\n    }\n\n    stop = ret + size;\n\n    while (ptr < stop) {\n      HEAP8[ptr++ >> 0] = 0;\n    }\n\n    return ret;\n  }\n\n  if (singleType === 'i8') {\n    if (slab.subarray || slab.slice) {\n      HEAPU8.set(\n      /** @type {!Uint8Array} */\n      slab, ret);\n    } else {\n      HEAPU8.set(new Uint8Array(slab), ret);\n    }\n\n    return ret;\n  }\n\n  var i = 0,\n      type,\n      typeSize,\n      previousType;\n\n  while (i < size) {\n    var curr = slab[i];\n    type = singleType || types[i];\n\n    if (type === 0) {\n      i++;\n      continue;\n    }\n\n    assert(type, 'Must know what type to store in allocate!');\n    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later\n\n    setValue(ret + i, curr, type); // no need to look up size unless type changes, so cache it\n\n    if (previousType !== type) {\n      typeSize = getNativeTypeSize(type);\n      previousType = type;\n    }\n\n    i += typeSize;\n  }\n\n  return ret;\n} // Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready\n\n\nfunction getMemory(size) {\n  if (!staticSealed) return staticAlloc(size);\n  if (!runtimeInitialized) return dynamicAlloc(size);\n  return _malloc(size);\n}\n/** @type {function(number, number=)} */\n\n\nfunction Pointer_stringify(ptr, length) {\n  if (length === 0 || !ptr) return ''; // Find the length, and check for UTF while doing so\n\n  var hasUtf = 0;\n  var t;\n  var i = 0;\n\n  while (1) {\n    assert(ptr + i < TOTAL_MEMORY);\n    t = HEAPU8[ptr + i >> 0];\n    hasUtf |= t;\n    if (t == 0 && !length) break;\n    i++;\n    if (length && i == length) break;\n  }\n\n  if (!length) length = i;\n  var ret = '';\n\n  if (hasUtf < 128) {\n    var MAX_CHUNK = 1024; // split up into chunks, because .apply on a huge string can overflow the stack\n\n    var curr;\n\n    while (length > 0) {\n      curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));\n      ret = ret ? ret + curr : curr;\n      ptr += MAX_CHUNK;\n      length -= MAX_CHUNK;\n    }\n\n    return ret;\n  }\n\n  return UTF8ToString(ptr);\n} // Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\n\nfunction AsciiToString(ptr) {\n  var str = '';\n\n  while (1) {\n    var ch = HEAP8[ptr++ >> 0];\n    if (!ch) return str;\n    str += String.fromCharCode(ch);\n  }\n} // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.\n\n\nfunction stringToAscii(str, outPtr) {\n  return writeAsciiToMemory(str, outPtr, false);\n} // Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns\n// a copy of that string as a Javascript String object.\n\n\nvar UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;\n\nfunction UTF8ArrayToString(u8Array, idx) {\n  var endPtr = idx; // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n\n  while (u8Array[endPtr]) ++endPtr;\n\n  if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {\n    return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));\n  } else {\n    var u0, u1, u2, u3, u4, u5;\n    var str = '';\n\n    while (1) {\n      // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n      u0 = u8Array[idx++];\n      if (!u0) return str;\n\n      if (!(u0 & 0x80)) {\n        str += String.fromCharCode(u0);\n        continue;\n      }\n\n      u1 = u8Array[idx++] & 63;\n\n      if ((u0 & 0xE0) == 0xC0) {\n        str += String.fromCharCode((u0 & 31) << 6 | u1);\n        continue;\n      }\n\n      u2 = u8Array[idx++] & 63;\n\n      if ((u0 & 0xF0) == 0xE0) {\n        u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n      } else {\n        u3 = u8Array[idx++] & 63;\n\n        if ((u0 & 0xF8) == 0xF0) {\n          u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u3;\n        } else {\n          u4 = u8Array[idx++] & 63;\n\n          if ((u0 & 0xFC) == 0xF8) {\n            u0 = (u0 & 3) << 24 | u1 << 18 | u2 << 12 | u3 << 6 | u4;\n          } else {\n            u5 = u8Array[idx++] & 63;\n            u0 = (u0 & 1) << 30 | u1 << 24 | u2 << 18 | u3 << 12 | u4 << 6 | u5;\n          }\n        }\n      }\n\n      if (u0 < 0x10000) {\n        str += String.fromCharCode(u0);\n      } else {\n        var ch = u0 - 0x10000;\n        str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);\n      }\n    }\n  }\n} // Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\n\nfunction UTF8ToString(ptr) {\n  return UTF8ArrayToString(HEAPU8, ptr);\n} // Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',\n// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.\n//   outIdx: The starting offset in the array to begin the copying.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array.\n//                    This count should include the null terminator,\n//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\n\nfunction stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {\n  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.\n    return 0;\n  var startIdx = outIdx;\n  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n    var u = str.charCodeAt(i); // possibly a lead surrogate\n\n    if (u >= 0xD800 && u <= 0xDFFF) {\n      var u1 = str.charCodeAt(++i);\n      u = 0x10000 + ((u & 0x3FF) << 10) | u1 & 0x3FF;\n    }\n\n    if (u <= 0x7F) {\n      if (outIdx >= endIdx) break;\n      outU8Array[outIdx++] = u;\n    } else if (u <= 0x7FF) {\n      if (outIdx + 1 >= endIdx) break;\n      outU8Array[outIdx++] = 0xC0 | u >> 6;\n      outU8Array[outIdx++] = 0x80 | u & 63;\n    } else if (u <= 0xFFFF) {\n      if (outIdx + 2 >= endIdx) break;\n      outU8Array[outIdx++] = 0xE0 | u >> 12;\n      outU8Array[outIdx++] = 0x80 | u >> 6 & 63;\n      outU8Array[outIdx++] = 0x80 | u & 63;\n    } else if (u <= 0x1FFFFF) {\n      if (outIdx + 3 >= endIdx) break;\n      outU8Array[outIdx++] = 0xF0 | u >> 18;\n      outU8Array[outIdx++] = 0x80 | u >> 12 & 63;\n      outU8Array[outIdx++] = 0x80 | u >> 6 & 63;\n      outU8Array[outIdx++] = 0x80 | u & 63;\n    } else if (u <= 0x3FFFFFF) {\n      if (outIdx + 4 >= endIdx) break;\n      outU8Array[outIdx++] = 0xF8 | u >> 24;\n      outU8Array[outIdx++] = 0x80 | u >> 18 & 63;\n      outU8Array[outIdx++] = 0x80 | u >> 12 & 63;\n      outU8Array[outIdx++] = 0x80 | u >> 6 & 63;\n      outU8Array[outIdx++] = 0x80 | u & 63;\n    } else {\n      if (outIdx + 5 >= endIdx) break;\n      outU8Array[outIdx++] = 0xFC | u >> 30;\n      outU8Array[outIdx++] = 0x80 | u >> 24 & 63;\n      outU8Array[outIdx++] = 0x80 | u >> 18 & 63;\n      outU8Array[outIdx++] = 0x80 | u >> 12 & 63;\n      outU8Array[outIdx++] = 0x80 | u >> 6 & 63;\n      outU8Array[outIdx++] = 0x80 | u & 63;\n    }\n  } // Null-terminate the pointer to the buffer.\n\n\n  outU8Array[outIdx] = 0;\n  return outIdx - startIdx;\n} // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\n\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n  return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n} // Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.\n\n\nfunction lengthBytesUTF8(str) {\n  var len = 0;\n\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var u = str.charCodeAt(i); // possibly a lead surrogate\n\n    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | str.charCodeAt(++i) & 0x3FF;\n\n    if (u <= 0x7F) {\n      ++len;\n    } else if (u <= 0x7FF) {\n      len += 2;\n    } else if (u <= 0xFFFF) {\n      len += 3;\n    } else if (u <= 0x1FFFFF) {\n      len += 4;\n    } else if (u <= 0x3FFFFFF) {\n      len += 5;\n    } else {\n      len += 6;\n    }\n  }\n\n  return len;\n} // Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\n\nvar UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;\n\nfunction UTF16ToString(ptr) {\n  assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');\n  var endPtr = ptr; // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n\n  var idx = endPtr >> 1;\n\n  while (HEAP16[idx]) ++idx;\n\n  endPtr = idx << 1;\n\n  if (endPtr - ptr > 32 && UTF16Decoder) {\n    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n  } else {\n    var i = 0;\n    var str = '';\n\n    while (1) {\n      var codeUnit = HEAP16[ptr + i * 2 >> 1];\n      if (codeUnit == 0) return str;\n      ++i; // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.\n\n      str += String.fromCharCode(codeUnit);\n    }\n  }\n} // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.\n// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\n\nfunction stringToUTF16(str, outPtr, maxBytesToWrite) {\n  assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!'); // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n\n  if (maxBytesToWrite === undefined) {\n    maxBytesToWrite = 0x7FFFFFFF;\n  }\n\n  if (maxBytesToWrite < 2) return 0;\n  maxBytesToWrite -= 2; // Null terminator.\n\n  var startPtr = outPtr;\n  var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n\n  for (var i = 0; i < numCharsToWrite; ++i) {\n    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n\n    HEAP16[outPtr >> 1] = codeUnit;\n    outPtr += 2;\n  } // Null-terminate the pointer to the HEAP.\n\n\n  HEAP16[outPtr >> 1] = 0;\n  return outPtr - startPtr;\n} // Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\n\nfunction lengthBytesUTF16(str) {\n  return str.length * 2;\n}\n\nfunction UTF32ToString(ptr) {\n  assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');\n  var i = 0;\n  var str = '';\n\n  while (1) {\n    var utf32 = HEAP32[ptr + i * 4 >> 2];\n    if (utf32 == 0) return str;\n    ++i; // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n\n    if (utf32 >= 0x10000) {\n      var ch = utf32 - 0x10000;\n      str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);\n    } else {\n      str += String.fromCharCode(utf32);\n    }\n  }\n} // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.\n// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\n\nfunction stringToUTF32(str, outPtr, maxBytesToWrite) {\n  assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!'); // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n\n  if (maxBytesToWrite === undefined) {\n    maxBytesToWrite = 0x7FFFFFFF;\n  }\n\n  if (maxBytesToWrite < 4) return 0;\n  var startPtr = outPtr;\n  var endPtr = startPtr + maxBytesToWrite - 4;\n\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\n      var trailSurrogate = str.charCodeAt(++i);\n      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | trailSurrogate & 0x3FF;\n    }\n\n    HEAP32[outPtr >> 2] = codeUnit;\n    outPtr += 4;\n    if (outPtr + 4 > endPtr) break;\n  } // Null-terminate the pointer to the HEAP.\n\n\n  HEAP32[outPtr >> 2] = 0;\n  return outPtr - startPtr;\n} // Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\n\nfunction lengthBytesUTF32(str) {\n  var len = 0;\n\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var codeUnit = str.charCodeAt(i);\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\n\n    len += 4;\n  }\n\n  return len;\n} // Allocate heap space for a JS string, and write it there.\n// It is the responsibility of the caller to free() that memory.\n\n\nfunction allocateUTF8(str) {\n  var size = lengthBytesUTF8(str) + 1;\n\n  var ret = _malloc(size);\n\n  if (ret) stringToUTF8Array(str, HEAP8, ret, size);\n  return ret;\n} // Allocate stack space for a JS string, and write it there.\n\n\nfunction allocateUTF8OnStack(str) {\n  var size = lengthBytesUTF8(str) + 1;\n  var ret = stackAlloc(size);\n  stringToUTF8Array(str, HEAP8, ret, size);\n  return ret;\n}\n\nfunction demangle(func) {\n  warnOnce('warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling');\n  return func;\n}\n\nfunction demangleAll(text) {\n  var regex = /__Z[\\w\\d_]+/g;\n  return text.replace(regex, function (x) {\n    var y = demangle(x);\n    return x === y ? x : x + ' [' + y + ']';\n  });\n}\n\nfunction jsStackTrace() {\n  var err = new Error();\n\n  if (!err.stack) {\n    // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,\n    // so try that as a special-case.\n    try {\n      throw new Error(0);\n    } catch (e) {\n      err = e;\n    }\n\n    if (!err.stack) {\n      return '(no stack trace available)';\n    }\n  }\n\n  return err.stack.toString();\n}\n\nfunction stackTrace() {\n  var js = jsStackTrace();\n  if (Module['extraStackTrace']) js += '\\n' + Module['extraStackTrace']();\n  return demangleAll(js);\n} // Memory management\n\n\nvar PAGE_SIZE = 16384;\nvar WASM_PAGE_SIZE = 65536;\nvar ASMJS_PAGE_SIZE = 16777216;\nvar MIN_TOTAL_MEMORY = 16777216;\n\nfunction alignUp(x, multiple) {\n  if (x % multiple > 0) {\n    x += multiple - x % multiple;\n  }\n\n  return x;\n}\n\nvar HEAP,\n/** @type {ArrayBuffer} */\nbuffer,\n/** @type {Int8Array} */\nHEAP8,\n/** @type {Uint8Array} */\nHEAPU8,\n/** @type {Int16Array} */\nHEAP16,\n/** @type {Uint16Array} */\nHEAPU16,\n/** @type {Int32Array} */\nHEAP32,\n/** @type {Uint32Array} */\nHEAPU32,\n/** @type {Float32Array} */\nHEAPF32,\n/** @type {Float64Array} */\nHEAPF64;\n\nfunction updateGlobalBuffer(buf) {\n  Module['buffer'] = buffer = buf;\n}\n\nfunction updateGlobalBufferViews() {\n  Module['HEAP8'] = HEAP8 = new Int8Array(buffer);\n  Module['HEAP16'] = HEAP16 = new Int16Array(buffer);\n  Module['HEAP32'] = HEAP32 = new Int32Array(buffer);\n  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buffer);\n  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buffer);\n  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buffer);\n  Module['HEAPF32'] = HEAPF32 = new Float32Array(buffer);\n  Module['HEAPF64'] = HEAPF64 = new Float64Array(buffer);\n}\n\nvar STATIC_BASE, STATICTOP, staticSealed; // static area\n\nvar STACK_BASE, STACKTOP, STACK_MAX; // stack area\n\nvar DYNAMIC_BASE, DYNAMICTOP_PTR; // dynamic area handled by sbrk\n\nSTATIC_BASE = STATICTOP = STACK_BASE = STACKTOP = STACK_MAX = DYNAMIC_BASE = DYNAMICTOP_PTR = 0;\nstaticSealed = false; // Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\n\nfunction writeStackCookie() {\n  assert((STACK_MAX & 3) == 0);\n  HEAPU32[(STACK_MAX >> 2) - 1] = 0x02135467;\n  HEAPU32[(STACK_MAX >> 2) - 2] = 0x89BACDFE;\n}\n\nfunction checkStackCookie() {\n  if (HEAPU32[(STACK_MAX >> 2) - 1] != 0x02135467 || HEAPU32[(STACK_MAX >> 2) - 2] != 0x89BACDFE) {\n    abort('Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x02135467, but received 0x' + HEAPU32[(STACK_MAX >> 2) - 2].toString(16) + ' ' + HEAPU32[(STACK_MAX >> 2) - 1].toString(16));\n  } // Also test the global address 0 for integrity. This check is not compatible with SAFE_SPLIT_MEMORY though, since that mode already tests all address 0 accesses on its own.\n\n\n  if (HEAP32[0] !== 0x63736d65\n  /* 'emsc' */\n  ) throw 'Runtime error: The application has corrupted its heap memory area (address zero)!';\n}\n\nfunction abortStackOverflow(allocSize) {\n  abort('Stack overflow! Attempted to allocate ' + allocSize + ' bytes on the stack, but stack has only ' + (STACK_MAX - stackSave() + allocSize) + ' bytes available!');\n}\n\nfunction abortOnCannotGrowMemory() {\n  abort('Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + TOTAL_MEMORY + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime but prevents some optimizations, (3) set Module.TOTAL_MEMORY to a higher value before the program runs, or (4) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');\n}\n\nfunction enlargeMemory() {\n  abortOnCannotGrowMemory();\n}\n\nvar TOTAL_STACK = Module['TOTAL_STACK'] || 5242880;\nvar TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 268435456;\nif (TOTAL_MEMORY < TOTAL_STACK) err('TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')'); // Initialize the runtime's memory\n// check for full engine support (use string 'subarray' to avoid closure compiler confusion)\n\nassert(typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray !== undefined && Int32Array.prototype.set !== undefined, 'JS engine does not provide full typed array support'); // Use a provided buffer, if there is one, or else allocate a new one\n\nif (Module['buffer']) {\n  buffer = Module['buffer'];\n  assert(buffer.byteLength === TOTAL_MEMORY, 'provided buffer should be ' + TOTAL_MEMORY + ' bytes, but it is ' + buffer.byteLength);\n} else {\n  // Use a WebAssembly memory where available\n  {\n    buffer = new ArrayBuffer(TOTAL_MEMORY);\n  }\n  assert(buffer.byteLength === TOTAL_MEMORY);\n  Module['buffer'] = buffer;\n}\n\nupdateGlobalBufferViews();\n\nfunction getTotalMemory() {\n  return TOTAL_MEMORY;\n} // Endianness check (note: assumes compiler arch was little-endian)\n\n\nHEAP32[0] = 0x63736d65;\n/* 'emsc' */\n\nHEAP16[1] = 0x6373;\nif (HEAPU8[2] !== 0x73 || HEAPU8[3] !== 0x63) throw 'Runtime error: expected the system to be little-endian!';\n\nfunction callRuntimeCallbacks(callbacks) {\n  while (callbacks.length > 0) {\n    var callback = callbacks.shift();\n\n    if (typeof callback == 'function') {\n      callback();\n      continue;\n    }\n\n    var func = callback.func;\n\n    if (typeof func === 'number') {\n      if (callback.arg === undefined) {\n        Module['dynCall_v'](func);\n      } else {\n        Module['dynCall_vi'](func, callback.arg);\n      }\n    } else {\n      func(callback.arg === undefined ? null : callback.arg);\n    }\n  }\n}\n\nvar __ATPRERUN__ = []; // functions called before the runtime is initialized\n\nvar __ATINIT__ = []; // functions called during startup\n\nvar __ATMAIN__ = []; // functions called when main() is to be run\n\nvar __ATEXIT__ = []; // functions called during shutdown\n\nvar __ATPOSTRUN__ = []; // functions called after the main() is called\n\nvar runtimeInitialized = false;\nvar runtimeExited = false;\n\nfunction preRun() {\n  // compatibility - merge in anything from Module['preRun'] at this time\n  if (Module['preRun']) {\n    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\n\n    while (Module['preRun'].length) {\n      addOnPreRun(Module['preRun'].shift());\n    }\n  }\n\n  callRuntimeCallbacks(__ATPRERUN__);\n}\n\nfunction ensureInitRuntime() {\n  checkStackCookie();\n  if (runtimeInitialized) return;\n  runtimeInitialized = true;\n  callRuntimeCallbacks(__ATINIT__);\n}\n\nfunction preMain() {\n  checkStackCookie();\n  callRuntimeCallbacks(__ATMAIN__);\n}\n\nfunction exitRuntime() {\n  checkStackCookie();\n  callRuntimeCallbacks(__ATEXIT__);\n  runtimeExited = true;\n}\n\nfunction postRun() {\n  checkStackCookie(); // compatibility - merge in anything from Module['postRun'] at this time\n\n  if (Module['postRun']) {\n    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\n\n    while (Module['postRun'].length) {\n      addOnPostRun(Module['postRun'].shift());\n    }\n  }\n\n  callRuntimeCallbacks(__ATPOSTRUN__);\n}\n\nfunction addOnPreRun(cb) {\n  __ATPRERUN__.unshift(cb);\n}\n\nfunction addOnInit(cb) {\n  __ATINIT__.unshift(cb);\n}\n\nfunction addOnPreMain(cb) {\n  __ATMAIN__.unshift(cb);\n}\n\nfunction addOnExit(cb) {\n  __ATEXIT__.unshift(cb);\n}\n\nfunction addOnPostRun(cb) {\n  __ATPOSTRUN__.unshift(cb);\n} // Deprecated: This function should not be called because it is unsafe and does not provide\n// a maximum length limit of how many bytes it is allowed to write. Prefer calling the\n// function stringToUTF8Array() instead, which takes in a maximum length that can be used\n// to be secure from out of bounds writes.\n\n/** @deprecated */\n\n\nfunction writeStringToMemory(string, buffer, dontAddNull) {\n  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');\n  var\n  /** @type {number} */\n  lastChar,\n  /** @type {number} */\n  end;\n\n  if (dontAddNull) {\n    // stringToUTF8Array always appends null. If we don't want to do that, remember the\n    // character that existed at the location where the null will be placed, and restore\n    // that after the write (below).\n    end = buffer + lengthBytesUTF8(string);\n    lastChar = HEAP8[end];\n  }\n\n  stringToUTF8(string, buffer, Infinity);\n  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.\n}\n\nfunction writeArrayToMemory(array, buffer) {\n  assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)');\n  HEAP8.set(array, buffer);\n}\n\nfunction writeAsciiToMemory(str, buffer, dontAddNull) {\n  for (var i = 0; i < str.length; ++i) {\n    assert(str.charCodeAt(i) === str.charCodeAt(i) & 0xff);\n    HEAP8[buffer++ >> 0] = str.charCodeAt(i);\n  } // Null-terminate the pointer to the HEAP.\n\n\n  if (!dontAddNull) HEAP8[buffer >> 0] = 0;\n}\n\nfunction unSign(value, bits, ignore) {\n  if (value >= 0) {\n    return value;\n  }\n\n  return bits <= 32 ? 2 * Math.abs(1 << bits - 1) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts\n  : Math.pow(2, bits) + value;\n}\n\nfunction reSign(value, bits, ignore) {\n  if (value <= 0) {\n    return value;\n  }\n\n  var half = bits <= 32 ? Math.abs(1 << bits - 1) // abs is needed if bits == 32\n  : Math.pow(2, bits - 1);\n\n  if (value >= half && (bits <= 32 || value > half)) {\n    // for huge values, we can hit the precision limit and always get true here. so don't do that\n    // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors\n    // TODO: In i64 mode 1, resign the two parts separately and safely\n    value = -2 * half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts\n  }\n\n  return value;\n}\n\nassert(Math['imul'] && Math['fround'] && Math['clz32'] && Math['trunc'], 'this is a legacy browser, build with LEGACY_VM_SUPPORT');\nvar Math_abs = Math.abs;\nvar Math_cos = Math.cos;\nvar Math_sin = Math.sin;\nvar Math_tan = Math.tan;\nvar Math_acos = Math.acos;\nvar Math_asin = Math.asin;\nvar Math_atan = Math.atan;\nvar Math_atan2 = Math.atan2;\nvar Math_exp = Math.exp;\nvar Math_log = Math.log;\nvar Math_sqrt = Math.sqrt;\nvar Math_ceil = Math.ceil;\nvar Math_floor = Math.floor;\nvar Math_pow = Math.pow;\nvar Math_imul = Math.imul;\nvar Math_fround = Math.fround;\nvar Math_round = Math.round;\nvar Math_min = Math.min;\nvar Math_max = Math.max;\nvar Math_clz32 = Math.clz32;\nvar Math_trunc = Math.trunc; // A counter of dependencies for calling run(). If we need to\n// do asynchronous work before running, increment this and\n// decrement it. Incrementing must happen in a place like\n// PRE_RUN_ADDITIONS (used by emcc to add file preloading).\n// Note that you can add dependencies in preRun, even though\n// it happens right before run - run will be postponed until\n// the dependencies are met.\n\nvar runDependencies = 0;\nvar runDependencyWatcher = null;\nvar dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\n\nvar runDependencyTracking = {};\n\nfunction getUniqueRunDependency(id) {\n  var orig = id;\n\n  while (1) {\n    if (!runDependencyTracking[id]) return id;\n    id = orig + Math.random();\n  }\n\n  return id;\n}\n\nfunction addRunDependency(id) {\n  runDependencies++;\n\n  if (Module['monitorRunDependencies']) {\n    Module['monitorRunDependencies'](runDependencies);\n  }\n\n  if (id) {\n    assert(!runDependencyTracking[id]);\n    runDependencyTracking[id] = 1;\n\n    if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {\n      // Check for missing dependencies every few seconds\n      runDependencyWatcher = setInterval(function () {\n        if (ABORT) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n          return;\n        }\n\n        var shown = false;\n\n        for (var dep in runDependencyTracking) {\n          if (!shown) {\n            shown = true;\n            err('still waiting on run dependencies:');\n          }\n\n          err('dependency: ' + dep);\n        }\n\n        if (shown) {\n          err('(end of list)');\n        }\n      }, 10000);\n    }\n  } else {\n    err('warning: run dependency added without ID');\n  }\n}\n\nfunction removeRunDependency(id) {\n  runDependencies--;\n\n  if (Module['monitorRunDependencies']) {\n    Module['monitorRunDependencies'](runDependencies);\n  }\n\n  if (id) {\n    assert(runDependencyTracking[id]);\n    delete runDependencyTracking[id];\n  } else {\n    err('warning: run dependency removed without ID');\n  }\n\n  if (runDependencies == 0) {\n    if (runDependencyWatcher !== null) {\n      clearInterval(runDependencyWatcher);\n      runDependencyWatcher = null;\n    }\n\n    if (dependenciesFulfilled) {\n      var callback = dependenciesFulfilled;\n      dependenciesFulfilled = null;\n      callback(); // can add another dependenciesFulfilled\n    }\n  }\n}\n\nModule[\"preloadedImages\"] = {}; // maps url to image data\n\nModule[\"preloadedAudios\"] = {}; // maps url to audio data\n\nvar memoryInitializer = null;\nvar\n/* show errors on likely calls to FS when it was not included */\nFS = {\n  error: function () {\n    abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with  -s FORCE_FILESYSTEM=1');\n  },\n  init: function () {\n    FS.error();\n  },\n  createDataFile: function () {\n    FS.error();\n  },\n  createPreloadedFile: function () {\n    FS.error();\n  },\n  createLazyFile: function () {\n    FS.error();\n  },\n  open: function () {\n    FS.error();\n  },\n  mkdev: function () {\n    FS.error();\n  },\n  registerDevice: function () {\n    FS.error();\n  },\n  analyzePath: function () {\n    FS.error();\n  },\n  loadFilesFromDB: function () {\n    FS.error();\n  },\n  ErrnoError: function ErrnoError() {\n    FS.error();\n  }\n};\nModule['FS_createDataFile'] = FS.createDataFile;\nModule['FS_createPreloadedFile'] = FS.createPreloadedFile; // Prefix of data URIs emitted by SINGLE_FILE and related options.\n\nvar dataURIPrefix = 'data:application/octet-stream;base64,'; // Indicates whether filename is a base64 data URI.\n\nfunction isDataURI(filename) {\n  return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0;\n} // === Body ===\n\n\nvar ASM_CONSTS = [];\nSTATIC_BASE = GLOBAL_BASE;\nSTATICTOP = STATIC_BASE + 330112;\n/* global initializers */\n\n__ATINIT__.push();\n\nmemoryInitializer = \"data:application/octet-stream;base64,AAAAAAAAAACXoIlbWg+DDclfYDXC6QfhjCRnHkWOCGMl8BUKF74GlPd46ksAGsU+Xvzby3UjCyA5sSFY7ZU4V64UfYirqESvSqVHhoswG6ZNkp7nU2/lejzThebcaVwpNy71KPRmjzZBGT+hAdhQSdFMhLvQWRKpyMSHgnS8n1akZG3GrboDQDTZ4vp8ewXKJpN2fv9SVdTPzjvjLxA6Eba9HCrft6rVd/iYAiyao0bdmWWbpyusCYEWJ/0TYmxuT3Hg6LK5cGja9mHk+yLywe7SkAy/s6LxUTOR6/kO72sxwNYftcdqnbhUzLBzeTItfwSW/orszV3eckMdGEjzjYDDTkLXPZy0l6CJW1oPgw3JX2A1wukH4YwkZx5FjghjJfAVChe+BpT3eOpLABrFPl7828t1IwsgObEhWO2VOFeuFH2Iq6hEr0qlR4aLMBumTZKe51Nv5Xo804Xm3GlcKTcu9Sj0Zo82QRk/oQHYUEnRTIS70FkSqcjEh4J0vJ9WpGRtxq26A0A02eL6fHsFyiaTdn7/UlXUz8474y8QOhG2vRwq37eq1Xf4mAIsmqNG3Zllm6crrAmBFif9E2Jsbk9x4OiyuXBo2vZh5Psi8sHu0pAMv7Oi8VEzkev5Du9rMcDWH7XHap24VMywc3kyLX8Elv6K7M1d3nJDHRhI842Aw05C1z2ctAAAgD8AAIA/AAAAAAAAgL8AAIA/AAAAAAAAgD8AAIC/AAAAAAAAgL8AAIC/AAAAAAAAgD8AAAAAAACAPwAAgL8AAAAAAACAPwAAgD8AAAAAAACAvwAAgL8AAAAAAACAvwAAAAAAAIA/AACAPwAAAAAAAIC/AACAPwAAAAAAAIA/AACAvwAAAAAAAIC/AACAvwAAgD8AAAAAAACAvwAAgL8AAAAAAACAvwAAAAAAAIC/AACAPwAAAAAAAIA/AACAP9QCAAAFAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAwAAAHgDBQAABAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAK/////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA1AIAAENhdWdodCBtYXAgZG91YmxlLWZyZWU=\";\n/* no memory initializer */\n\nvar tempDoublePtr = STATICTOP;\nSTATICTOP += 16;\nassert(tempDoublePtr % 8 == 0);\n\nfunction copyTempFloat(ptr) {\n  // functions, because inlining this code increases code size too much\n  HEAP8[tempDoublePtr] = HEAP8[ptr];\n  HEAP8[tempDoublePtr + 1] = HEAP8[ptr + 1];\n  HEAP8[tempDoublePtr + 2] = HEAP8[ptr + 2];\n  HEAP8[tempDoublePtr + 3] = HEAP8[ptr + 3];\n}\n\nfunction copyTempDouble(ptr) {\n  HEAP8[tempDoublePtr] = HEAP8[ptr];\n  HEAP8[tempDoublePtr + 1] = HEAP8[ptr + 1];\n  HEAP8[tempDoublePtr + 2] = HEAP8[ptr + 2];\n  HEAP8[tempDoublePtr + 3] = HEAP8[ptr + 3];\n  HEAP8[tempDoublePtr + 4] = HEAP8[ptr + 4];\n  HEAP8[tempDoublePtr + 5] = HEAP8[ptr + 5];\n  HEAP8[tempDoublePtr + 6] = HEAP8[ptr + 6];\n  HEAP8[tempDoublePtr + 7] = HEAP8[ptr + 7];\n} // {{PRE_LIBRARY}}\n\n\nfunction ___lock() {}\n\nvar SYSCALLS = {\n  varargs: 0,\n  get: function (varargs) {\n    SYSCALLS.varargs += 4;\n    var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];\n    return ret;\n  },\n  getStr: function () {\n    var ret = Pointer_stringify(SYSCALLS.get());\n    return ret;\n  },\n  get64: function () {\n    var low = SYSCALLS.get(),\n        high = SYSCALLS.get();\n    if (low >= 0) assert(high === 0);else assert(high === -1);\n    return low;\n  },\n  getZero: function () {\n    assert(SYSCALLS.get() === 0);\n  }\n};\n\nfunction ___syscall140(which, varargs) {\n  SYSCALLS.varargs = varargs;\n\n  try {\n    // llseek\n    var stream = SYSCALLS.getStreamFromFD(),\n        offset_high = SYSCALLS.get(),\n        offset_low = SYSCALLS.get(),\n        result = SYSCALLS.get(),\n        whence = SYSCALLS.get(); // NOTE: offset_high is unused - Emscripten's off_t is 32-bit\n\n    var offset = offset_low;\n    FS.llseek(stream, offset, whence);\n    HEAP32[result >> 2] = stream.position;\n    if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state\n\n    return 0;\n  } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n}\n\nfunction flush_NO_FILESYSTEM() {\n  // flush anything remaining in the buffers during shutdown\n  var fflush = Module[\"_fflush\"];\n  if (fflush) fflush(0);\n  var printChar = ___syscall146.printChar;\n  if (!printChar) return;\n  var buffers = ___syscall146.buffers;\n  if (buffers[1].length) printChar(1, 10);\n  if (buffers[2].length) printChar(2, 10);\n}\n\nfunction ___syscall146(which, varargs) {\n  SYSCALLS.varargs = varargs;\n\n  try {\n    // writev\n    // hack to support printf in NO_FILESYSTEM\n    var stream = SYSCALLS.get(),\n        iov = SYSCALLS.get(),\n        iovcnt = SYSCALLS.get();\n    var ret = 0;\n\n    if (!___syscall146.buffers) {\n      ___syscall146.buffers = [null, [], []]; // 1 => stdout, 2 => stderr\n\n      ___syscall146.printChar = function (stream, curr) {\n        var buffer = ___syscall146.buffers[stream];\n        assert(buffer);\n\n        if (curr === 0 || curr === 10) {\n          (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));\n          buffer.length = 0;\n        } else {\n          buffer.push(curr);\n        }\n      };\n    }\n\n    for (var i = 0; i < iovcnt; i++) {\n      var ptr = HEAP32[iov + i * 8 >> 2];\n      var len = HEAP32[iov + (i * 8 + 4) >> 2];\n\n      for (var j = 0; j < len; j++) {\n        ___syscall146.printChar(stream, HEAPU8[ptr + j]);\n      }\n\n      ret += len;\n    }\n\n    return ret;\n  } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n}\n\nfunction ___syscall54(which, varargs) {\n  SYSCALLS.varargs = varargs;\n\n  try {\n    // ioctl\n    return 0;\n  } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n}\n\nfunction ___syscall6(which, varargs) {\n  SYSCALLS.varargs = varargs;\n\n  try {\n    // close\n    var stream = SYSCALLS.getStreamFromFD();\n    FS.close(stream);\n    return 0;\n  } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n}\n\nfunction ___unlock() {}\n\nfunction _abort() {\n  Module['abort']();\n}\n\nvar _llvm_floor_f32 = Math_floor;\n\nfunction _emscripten_memcpy_big(dest, src, num) {\n  HEAPU8.set(HEAPU8.subarray(src, src + num), dest);\n  return dest;\n}\n\nfunction ___setErrNo(value) {\n  if (Module['___errno_location']) HEAP32[Module['___errno_location']() >> 2] = value;else err('failed to set errno from JS');\n  return value;\n}\n\nDYNAMICTOP_PTR = staticAlloc(4);\nSTACK_BASE = STACKTOP = alignMemory(STATICTOP);\nSTACK_MAX = STACK_BASE + TOTAL_STACK;\nDYNAMIC_BASE = alignMemory(STACK_MAX);\nHEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;\nstaticSealed = true; // seal the static portion of memory\n\nassert(DYNAMIC_BASE < TOTAL_MEMORY, \"TOTAL_MEMORY not big enough for stack\");\nvar ASSERTIONS = true;\n/** @type {function(string, boolean=, number=)} */\n\nfunction intArrayFromString(stringy, dontAddNull, length) {\n  var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n  var u8array = new Array(len);\n  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n  if (dontAddNull) u8array.length = numBytesWritten;\n  return u8array;\n}\n\nfunction intArrayToString(array) {\n  var ret = [];\n\n  for (var i = 0; i < array.length; i++) {\n    var chr = array[i];\n\n    if (chr > 0xFF) {\n      if (ASSERTIONS) {\n        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');\n      }\n\n      chr &= 0xFF;\n    }\n\n    ret.push(String.fromCharCode(chr));\n  }\n\n  return ret.join('');\n} // Copied from https://github.com/strophe/strophejs/blob/e06d027/src/polyfills.js#L149\n// This code was written by Tyler Akins and has been placed in the\n// public domain.  It would be nice if you left this header intact.\n// Base64 code from Tyler Akins -- http://rumkin.com\n\n/**\r\n * Decodes a base64 string.\r\n * @param {String} input The string to decode.\r\n */\n\n\nvar decodeBase64 = typeof atob === 'function' ? atob : function (input) {\n  var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n  var output = '';\n  var chr1, chr2, chr3;\n  var enc1, enc2, enc3, enc4;\n  var i = 0; // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\n\n  input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\n\n  do {\n    enc1 = keyStr.indexOf(input.charAt(i++));\n    enc2 = keyStr.indexOf(input.charAt(i++));\n    enc3 = keyStr.indexOf(input.charAt(i++));\n    enc4 = keyStr.indexOf(input.charAt(i++));\n    chr1 = enc1 << 2 | enc2 >> 4;\n    chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n    chr3 = (enc3 & 3) << 6 | enc4;\n    output = output + String.fromCharCode(chr1);\n\n    if (enc3 !== 64) {\n      output = output + String.fromCharCode(chr2);\n    }\n\n    if (enc4 !== 64) {\n      output = output + String.fromCharCode(chr3);\n    }\n  } while (i < input.length);\n\n  return output;\n}; // Converts a string of base64 into a byte array.\n// Throws error on invalid input.\n\nfunction intArrayFromBase64(s) {\n  if (typeof ENVIRONMENT_IS_NODE === 'boolean' && ENVIRONMENT_IS_NODE) {\n    var buf;\n\n    try {\n      buf = Buffer.from(s, 'base64');\n    } catch (_) {\n      buf = new Buffer(s, 'base64');\n    }\n\n    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n  }\n\n  try {\n    var decoded = decodeBase64(s);\n    var bytes = new Uint8Array(decoded.length);\n\n    for (var i = 0; i < decoded.length; ++i) {\n      bytes[i] = decoded.charCodeAt(i);\n    }\n\n    return bytes;\n  } catch (_) {\n    throw new Error('Converting base64 string to bytes failed.');\n  }\n} // If filename is a base64 data URI, parses and returns data (Buffer on node,\n// Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.\n\n\nfunction tryParseAsDataURI(filename) {\n  if (!isDataURI(filename)) {\n    return;\n  }\n\n  return intArrayFromBase64(filename.slice(dataURIPrefix.length));\n}\n\nfunction nullFunc_ii(x) {\n  err(\"Invalid function pointer called with signature 'ii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n  err(\"Build with ASSERTIONS=2 for more info.\");\n  abort(x);\n}\n\nfunction nullFunc_iiii(x) {\n  err(\"Invalid function pointer called with signature 'iiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n  err(\"Build with ASSERTIONS=2 for more info.\");\n  abort(x);\n}\n\nfunction nullFunc_viiiii(x) {\n  err(\"Invalid function pointer called with signature 'viiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n  err(\"Build with ASSERTIONS=2 for more info.\");\n  abort(x);\n}\n\nfunction invoke_ii(index, a1) {\n  var sp = stackSave();\n\n  try {\n    return Module[\"dynCall_ii\"](index, a1);\n  } catch (e) {\n    stackRestore(sp);\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    Module[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_iiii(index, a1, a2, a3) {\n  var sp = stackSave();\n\n  try {\n    return Module[\"dynCall_iiii\"](index, a1, a2, a3);\n  } catch (e) {\n    stackRestore(sp);\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    Module[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_viiiii(index, a1, a2, a3, a4, a5) {\n  var sp = stackSave();\n\n  try {\n    Module[\"dynCall_viiiii\"](index, a1, a2, a3, a4, a5);\n  } catch (e) {\n    stackRestore(sp);\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    Module[\"setThrew\"](1, 0);\n  }\n}\n\nModule.asmGlobalArg = {\n  \"Math\": Math,\n  \"Int8Array\": Int8Array,\n  \"Int16Array\": Int16Array,\n  \"Int32Array\": Int32Array,\n  \"Uint8Array\": Uint8Array,\n  \"Uint16Array\": Uint16Array,\n  \"Uint32Array\": Uint32Array,\n  \"Float32Array\": Float32Array,\n  \"Float64Array\": Float64Array,\n  \"NaN\": NaN,\n  \"Infinity\": Infinity\n};\nModule.asmLibraryArg = {\n  \"abort\": abort,\n  \"assert\": assert,\n  \"enlargeMemory\": enlargeMemory,\n  \"getTotalMemory\": getTotalMemory,\n  \"abortOnCannotGrowMemory\": abortOnCannotGrowMemory,\n  \"abortStackOverflow\": abortStackOverflow,\n  \"nullFunc_ii\": nullFunc_ii,\n  \"nullFunc_iiii\": nullFunc_iiii,\n  \"nullFunc_viiiii\": nullFunc_viiiii,\n  \"invoke_ii\": invoke_ii,\n  \"invoke_iiii\": invoke_iiii,\n  \"invoke_viiiii\": invoke_viiiii,\n  \"___lock\": ___lock,\n  \"___setErrNo\": ___setErrNo,\n  \"___syscall140\": ___syscall140,\n  \"___syscall146\": ___syscall146,\n  \"___syscall54\": ___syscall54,\n  \"___syscall6\": ___syscall6,\n  \"___unlock\": ___unlock,\n  \"_abort\": _abort,\n  \"_emscripten_memcpy_big\": _emscripten_memcpy_big,\n  \"_llvm_floor_f32\": _llvm_floor_f32,\n  \"flush_NO_FILESYSTEM\": flush_NO_FILESYSTEM,\n  \"DYNAMICTOP_PTR\": DYNAMICTOP_PTR,\n  \"tempDoublePtr\": tempDoublePtr,\n  \"ABORT\": ABORT,\n  \"STACKTOP\": STACKTOP,\n  \"STACK_MAX\": STACK_MAX\n}; // EMSCRIPTEN_START_ASM\n\nvar asm =\n/** @suppress {uselessCode} */\nfunction (global, env, buffer) {\n  'almost asm';\n\n  var HEAP8 = new global.Int8Array(buffer);\n  var HEAP16 = new global.Int16Array(buffer);\n  var HEAP32 = new global.Int32Array(buffer);\n  var HEAPU8 = new global.Uint8Array(buffer);\n  var HEAPU16 = new global.Uint16Array(buffer);\n  var HEAPU32 = new global.Uint32Array(buffer);\n  var HEAPF32 = new global.Float32Array(buffer);\n  var HEAPF64 = new global.Float64Array(buffer);\n  var DYNAMICTOP_PTR = env.DYNAMICTOP_PTR | 0;\n  var tempDoublePtr = env.tempDoublePtr | 0;\n  var ABORT = env.ABORT | 0;\n  var STACKTOP = env.STACKTOP | 0;\n  var STACK_MAX = env.STACK_MAX | 0;\n  var __THREW__ = 0;\n  var threwValue = 0;\n  var setjmpId = 0;\n  var undef = 0;\n  var nan = global.NaN,\n      inf = global.Infinity;\n  var tempInt = 0,\n      tempBigInt = 0,\n      tempBigIntS = 0,\n      tempValue = 0,\n      tempDouble = 0.0;\n  var tempRet0 = 0;\n  var Math_floor = global.Math.floor;\n  var Math_abs = global.Math.abs;\n  var Math_sqrt = global.Math.sqrt;\n  var Math_pow = global.Math.pow;\n  var Math_cos = global.Math.cos;\n  var Math_sin = global.Math.sin;\n  var Math_tan = global.Math.tan;\n  var Math_acos = global.Math.acos;\n  var Math_asin = global.Math.asin;\n  var Math_atan = global.Math.atan;\n  var Math_atan2 = global.Math.atan2;\n  var Math_exp = global.Math.exp;\n  var Math_log = global.Math.log;\n  var Math_ceil = global.Math.ceil;\n  var Math_imul = global.Math.imul;\n  var Math_min = global.Math.min;\n  var Math_max = global.Math.max;\n  var Math_clz32 = global.Math.clz32;\n  var abort = env.abort;\n  var assert = env.assert;\n  var enlargeMemory = env.enlargeMemory;\n  var getTotalMemory = env.getTotalMemory;\n  var abortOnCannotGrowMemory = env.abortOnCannotGrowMemory;\n  var abortStackOverflow = env.abortStackOverflow;\n  var nullFunc_ii = env.nullFunc_ii;\n  var nullFunc_iiii = env.nullFunc_iiii;\n  var nullFunc_viiiii = env.nullFunc_viiiii;\n  var invoke_ii = env.invoke_ii;\n  var invoke_iiii = env.invoke_iiii;\n  var invoke_viiiii = env.invoke_viiiii;\n  var ___lock = env.___lock;\n  var ___setErrNo = env.___setErrNo;\n  var ___syscall140 = env.___syscall140;\n  var ___syscall146 = env.___syscall146;\n  var ___syscall54 = env.___syscall54;\n  var ___syscall6 = env.___syscall6;\n  var ___unlock = env.___unlock;\n  var _abort = env._abort;\n  var _emscripten_memcpy_big = env._emscripten_memcpy_big;\n  var _llvm_floor_f32 = env._llvm_floor_f32;\n  var flush_NO_FILESYSTEM = env.flush_NO_FILESYSTEM;\n  var tempFloat = 0.0; // EMSCRIPTEN_START_FUNCS\n\n  function stackAlloc(size) {\n    size = size | 0;\n    var ret = 0;\n    ret = STACKTOP;\n    STACKTOP = STACKTOP + size | 0;\n    STACKTOP = STACKTOP + 15 & -16;\n    if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(size | 0);\n    return ret | 0;\n  }\n\n  function stackSave() {\n    return STACKTOP | 0;\n  }\n\n  function stackRestore(top) {\n    top = top | 0;\n    STACKTOP = top;\n  }\n\n  function establishStackSpace(stackBase, stackMax) {\n    stackBase = stackBase | 0;\n    stackMax = stackMax | 0;\n    STACKTOP = stackBase;\n    STACK_MAX = stackMax;\n  }\n\n  function setThrew(threw, value) {\n    threw = threw | 0;\n    value = value | 0;\n\n    if ((__THREW__ | 0) == 0) {\n      __THREW__ = threw;\n      threwValue = value;\n    }\n  }\n\n  function setTempRet0(value) {\n    value = value | 0;\n    tempRet0 = value;\n  }\n\n  function getTempRet0() {\n    return tempRet0 | 0;\n  }\n\n  function _init_chunk($0, $1, $2, $3) {\n    $0 = $0 | 0;\n    $1 = $1 | 0;\n    $2 = $2 | 0;\n    $3 = $3 | 0;\n    var $10 = 0,\n        $11 = 0,\n        $12 = 0,\n        $13 = 0,\n        $4 = 0,\n        $5 = 0,\n        $6 = 0,\n        $7 = 0,\n        $8 = 0,\n        $9 = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    $4 = $0 + 12 | 0;\n    HEAP32[$4 >> 2] = 1;\n    HEAP32[$0 >> 2] = $1;\n    $5 = $0 + 4 | 0;\n    HEAP32[$5 >> 2] = $2;\n    $6 = $0 + 8 | 0;\n    HEAP32[$6 >> 2] = $3;\n    $7 = $0 + 16 | 0;\n    HEAP32[$7 >> 2] = 0;\n    $8 = $0 + 68 | 0;\n\n    _sign_list_alloc($8, 16);\n\n    $9 = $0 + 20 | 0;\n    $10 = $0 + 44 | 0;\n    $11 = $1 << 5;\n    $12 = $3 << 5;\n    $13 = $2 << 5;\n\n    _map_alloc($9, $11, $12, $13, 32767);\n\n    _map_alloc($10, $11, $12, $13, 32767);\n\n    return;\n  }\n\n  function _delete_chunk($0) {\n    $0 = $0 | 0;\n    var $1 = 0,\n        $2 = 0,\n        $3 = 0,\n        $4 = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    $1 = $0 + 20 | 0;\n\n    _map_free($1);\n\n    $2 = $0 + 44 | 0;\n\n    _map_free($2);\n\n    $3 = $0 + 68 | 0;\n\n    _sign_list_free($3);\n\n    $4 = $0 + 12 | 0;\n    HEAP32[$4 >> 2] = 0;\n    return;\n  }\n\n  function _map_set_func($0, $1, $2, $3, $4) {\n    $0 = $0 | 0;\n    $1 = $1 | 0;\n    $2 = $2 | 0;\n    $3 = $3 | 0;\n    $4 = $4 | 0;\n    var label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    _map_set($4, $0, $1, $2, $3) | 0;\n    return;\n  }\n\n  function _gen_chunk($0) {\n    $0 = $0 | 0;\n    var $1 = 0,\n        $2 = 0,\n        $3 = 0,\n        $4 = 0,\n        $5 = 0,\n        $6 = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    $1 = HEAP32[$0 >> 2] | 0;\n    $2 = $0 + 4 | 0;\n    $3 = HEAP32[$2 >> 2] | 0;\n    $4 = $0 + 8 | 0;\n    $5 = HEAP32[$4 >> 2] | 0;\n    $6 = $0 + 20 | 0;\n\n    _create_world($1, $3, $5, 4, $6);\n\n    return;\n  }\n\n  function _find_chunk($0, $1, $2) {\n    $0 = $0 | 0;\n    $1 = $1 | 0;\n    $2 = $2 | 0;\n    var $$01822 = 0,\n        $10 = 0,\n        $11 = 0,\n        $12 = 0,\n        $13 = 0,\n        $14 = 0,\n        $15 = 0,\n        $16 = 0,\n        $17 = 0,\n        $3 = 0,\n        $4 = 0,\n        $5 = 0,\n        $6 = 0,\n        $7 = 0,\n        $8 = 0,\n        $9 = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    $$01822 = 0;\n\n    while (1) {\n      $3 = 880 + ($$01822 * 80 | 0) | 0;\n      $4 = (880 + ($$01822 * 80 | 0) | 0) + 12 | 0;\n      $5 = HEAP32[$4 >> 2] | 0;\n      $6 = ($5 | 0) == 0;\n\n      if (!$6) {\n        $7 = HEAP32[$3 >> 2] | 0;\n        $8 = ($7 | 0) == ($0 | 0);\n\n        if ($8) {\n          $9 = (880 + ($$01822 * 80 | 0) | 0) + 4 | 0;\n          $10 = HEAP32[$9 >> 2] | 0;\n          $11 = ($10 | 0) == ($1 | 0);\n\n          if ($11) {\n            $12 = (880 + ($$01822 * 80 | 0) | 0) + 8 | 0;\n            $13 = HEAP32[$12 >> 2] | 0;\n            $14 = ($13 | 0) == ($2 | 0);\n\n            if ($14) {\n              $17 = $3;\n              label = 7;\n              break;\n            }\n          }\n        }\n      }\n\n      $15 = $$01822 + 1 | 0;\n      $16 = $15 >>> 0 < 4096;\n\n      if ($16) {\n        $$01822 = $15;\n      } else {\n        $17 = 0;\n        label = 7;\n        break;\n      }\n    }\n\n    if ((label | 0) == 7) {\n      return $17 | 0;\n    }\n\n    return 0 | 0;\n  }\n\n  function _get_unused_chunk_mem_location() {\n    var $$01214 = 0,\n        $0 = 0,\n        $1 = 0,\n        $2 = 0,\n        $3 = 0,\n        $4 = 0,\n        $5 = 0,\n        $6 = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    $$01214 = 1;\n\n    while (1) {\n      $2 = (880 + ($$01214 * 80 | 0) | 0) + 12 | 0;\n      $3 = HEAP32[$2 >> 2] | 0;\n      $4 = ($3 | 0) == 0;\n      $1 = $$01214 + 1 | 0;\n\n      if ($4) {\n        break;\n      }\n\n      $0 = $1 >>> 0 < 4096;\n\n      if ($0) {\n        $$01214 = $1;\n      } else {\n        $6 = 0;\n        label = 5;\n        break;\n      }\n    }\n\n    if ((label | 0) == 5) {\n      return $6 | 0;\n    }\n\n    $5 = 880 + ($$01214 * 80 | 0) | 0;\n    $6 = $5;\n    return $6 | 0;\n  }\n\n  function _gen_trees($0, $1, $2, $3, $4, $5, $6, $7) {\n    $0 = $0 | 0;\n    $1 = $1 | 0;\n    $2 = $2 | 0;\n    $3 = $3 | 0;\n    $4 = $4 | 0;\n    $5 = $5 | 0;\n    $6 = $6 | 0;\n    $7 = $7 | 0;\n    var $$0120137 = 0,\n        $$0120137$us = 0,\n        $$0120137$us139 = 0,\n        $$0121136 = 0,\n        $$0121136$us = 0,\n        $$0121136$us$mux = 0,\n        $$0122145 = 0,\n        $$0123146 = 0,\n        $$0126149 = 0,\n        $$0151 = 0,\n        $$2 = 0,\n        $$2$us = 0,\n        $$not152 = 0,\n        $10 = 0.0,\n        $100 = 0,\n        $101 = 0.0,\n        $102 = 0.0,\n        $103 = 0.0,\n        $104 = 0,\n        $105 = 0.0;\n    var $106 = 0.0,\n        $107 = 0.0,\n        $108 = 0,\n        $109 = 0,\n        $11 = 0.0,\n        $110 = 0,\n        $111 = 0,\n        $112 = 0,\n        $113 = 0.0,\n        $114 = 0.0,\n        $115 = 0.0,\n        $116 = 0,\n        $117 = 0,\n        $118 = 0.0,\n        $119 = 0.0,\n        $12 = 0,\n        $120 = 0.0,\n        $121 = 0,\n        $122 = 0.0,\n        $123 = 0.0;\n    var $124 = 0.0,\n        $125 = 0,\n        $126 = 0,\n        $127 = 0,\n        $128 = 0,\n        $129 = 0,\n        $13 = 0,\n        $130 = 0,\n        $131 = 0,\n        $132 = 0,\n        $133 = 0,\n        $134 = 0,\n        $135 = 0,\n        $136 = 0,\n        $137 = 0,\n        $138 = 0,\n        $139 = 0,\n        $14 = 0,\n        $140 = 0,\n        $141 = 0;\n    var $142 = 0,\n        $143 = 0,\n        $144 = 0,\n        $145 = 0,\n        $146 = 0,\n        $147 = 0,\n        $148 = 0,\n        $149 = 0,\n        $15 = 0,\n        $150 = 0,\n        $151 = 0,\n        $152 = 0,\n        $153 = 0,\n        $154 = 0,\n        $155 = 0,\n        $156 = 0,\n        $157 = 0,\n        $158 = 0,\n        $159 = 0,\n        $16 = 0;\n    var $160 = 0,\n        $161 = 0,\n        $162 = 0,\n        $163 = 0,\n        $164 = 0,\n        $165 = 0,\n        $166 = 0,\n        $167 = 0,\n        $168 = 0,\n        $169 = 0,\n        $17 = 0,\n        $170 = 0,\n        $171 = 0,\n        $172 = 0,\n        $173 = 0,\n        $18 = 0,\n        $19 = 0,\n        $20 = 0,\n        $21 = 0,\n        $22 = 0;\n    var $23 = 0,\n        $24 = 0,\n        $25 = 0,\n        $26 = 0,\n        $27 = 0,\n        $28 = 0,\n        $29 = 0,\n        $30 = 0,\n        $31 = 0,\n        $32 = 0,\n        $33 = 0,\n        $34 = 0,\n        $35 = 0,\n        $36 = 0,\n        $37 = 0,\n        $38 = 0,\n        $39 = 0,\n        $40 = 0,\n        $41 = 0,\n        $42 = 0;\n    var $43 = 0,\n        $44 = 0,\n        $45 = 0,\n        $46 = 0,\n        $47 = 0,\n        $48 = 0,\n        $49 = 0,\n        $50 = 0,\n        $51 = 0,\n        $52 = 0,\n        $53 = 0,\n        $54 = 0,\n        $55 = 0,\n        $56 = 0,\n        $57 = 0,\n        $58 = 0,\n        $59 = 0,\n        $60 = 0,\n        $61 = 0,\n        $62 = 0;\n    var $63 = 0.0,\n        $64 = 0,\n        $65 = 0,\n        $66 = 0,\n        $67 = 0,\n        $68 = 0.0,\n        $69 = 0,\n        $70 = 0,\n        $71 = 0,\n        $72 = 0,\n        $73 = 0,\n        $74 = 0,\n        $75 = 0,\n        $76 = 0,\n        $77 = 0.0,\n        $78 = 0.0,\n        $79 = 0.0,\n        $8 = 0.0,\n        $80 = 0,\n        $81 = 0;\n    var $82 = 0,\n        $83 = 0.0,\n        $84 = 0.0,\n        $85 = 0.0,\n        $86 = 0,\n        $87 = 0,\n        $88 = 0.0,\n        $89 = 0.0,\n        $9 = 0.0,\n        $90 = 0.0,\n        $91 = 0,\n        $92 = 0,\n        $93 = 0,\n        $94 = 0,\n        $95 = 0,\n        $96 = 0.0,\n        $97 = 0.0,\n        $98 = 0.0,\n        $99 = 0,\n        $brmerge = 0;\n    var $brmerge154 = 0,\n        $exitcond = 0,\n        $exitcond158 = 0,\n        $exitcond159 = 0,\n        $exitcond160 = 0,\n        $exitcond161 = 0,\n        $exitcond164 = 0,\n        $pow2 = 0.0,\n        $pow2$us = 0.0,\n        $pow2$us141 = 0.0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    $8 = +($4 | 0);\n    $9 = +($5 | 0);\n    $10 = +_simplex2($8, $9, 1, 1.0, 3.0);\n    $11 = $10;\n    $12 = $11 > 0.93999999999999994;\n\n    if (!$12) {\n      return;\n    }\n\n    $13 = $5 - $3 | 0;\n    $14 = $4 - $2 | 0;\n    $15 = $13 << 6;\n    $16 = $15 + -320 | 0;\n    $17 = $13 << 6;\n    $18 = $17 + -256 | 0;\n    $19 = $13 << 6;\n    $20 = $19 + -192 | 0;\n    $21 = $13 << 6;\n    $22 = $21 + -128 | 0;\n    $23 = $13 << 6;\n    $24 = $23 + -64 | 0;\n    $25 = $13 << 6;\n    $26 = $13 << 6;\n    $27 = $26 + 64 | 0;\n    $28 = $13 << 6;\n    $29 = $28 + 128 | 0;\n    $30 = $13 << 6;\n    $31 = $30 + 192 | 0;\n    $32 = $13 << 6;\n    $33 = $32 + 256 | 0;\n    $$0151 = -5;\n\n    while (1) {\n      $34 = $14 + $$0151 | 0;\n      $35 = $34 + $16 | 0;\n      $36 = $35 >>> 0 > 4095;\n\n      if (!$36) {\n        $37 = $1 + ($35 << 2) | 0;\n        $38 = HEAP32[$37 >> 2] | 0;\n        $39 = ($38 | 0) == 0;\n\n        if (!$39) {\n          label = 29;\n          break;\n        }\n      }\n\n      $40 = $34 + $18 | 0;\n      $41 = $40 >>> 0 > 4095;\n\n      if (!$41) {\n        $129 = $1 + ($40 << 2) | 0;\n        $130 = HEAP32[$129 >> 2] | 0;\n        $131 = ($130 | 0) == 0;\n\n        if (!$131) {\n          label = 29;\n          break;\n        }\n      }\n\n      $132 = $34 + $20 | 0;\n      $133 = $132 >>> 0 > 4095;\n\n      if (!$133) {\n        $134 = $1 + ($132 << 2) | 0;\n        $135 = HEAP32[$134 >> 2] | 0;\n        $136 = ($135 | 0) == 0;\n\n        if (!$136) {\n          label = 29;\n          break;\n        }\n      }\n\n      $137 = $34 + $22 | 0;\n      $138 = $137 >>> 0 > 4095;\n\n      if (!$138) {\n        $139 = $1 + ($137 << 2) | 0;\n        $140 = HEAP32[$139 >> 2] | 0;\n        $141 = ($140 | 0) == 0;\n\n        if (!$141) {\n          label = 29;\n          break;\n        }\n      }\n\n      $142 = $34 + $24 | 0;\n      $143 = $142 >>> 0 > 4095;\n\n      if (!$143) {\n        $144 = $1 + ($142 << 2) | 0;\n        $145 = HEAP32[$144 >> 2] | 0;\n        $146 = ($145 | 0) == 0;\n\n        if (!$146) {\n          label = 29;\n          break;\n        }\n      }\n\n      $147 = $34 + $25 | 0;\n      $148 = $147 >>> 0 > 4095;\n\n      if (!$148) {\n        $149 = $1 + ($147 << 2) | 0;\n        $150 = HEAP32[$149 >> 2] | 0;\n        $151 = ($150 | 0) == 0;\n\n        if (!$151) {\n          label = 29;\n          break;\n        }\n      }\n\n      $152 = $34 + $27 | 0;\n      $153 = $152 >>> 0 > 4095;\n\n      if (!$153) {\n        $154 = $1 + ($152 << 2) | 0;\n        $155 = HEAP32[$154 >> 2] | 0;\n        $156 = ($155 | 0) == 0;\n\n        if (!$156) {\n          label = 29;\n          break;\n        }\n      }\n\n      $157 = $34 + $29 | 0;\n      $158 = $157 >>> 0 > 4095;\n\n      if (!$158) {\n        $159 = $1 + ($157 << 2) | 0;\n        $160 = HEAP32[$159 >> 2] | 0;\n        $161 = ($160 | 0) == 0;\n\n        if (!$161) {\n          label = 29;\n          break;\n        }\n      }\n\n      $162 = $34 + $31 | 0;\n      $163 = $162 >>> 0 > 4095;\n\n      if (!$163) {\n        $164 = $1 + ($162 << 2) | 0;\n        $165 = HEAP32[$164 >> 2] | 0;\n        $166 = ($165 | 0) == 0;\n\n        if (!$166) {\n          label = 29;\n          break;\n        }\n      }\n\n      $167 = $34 + $33 | 0;\n      $168 = $167 >>> 0 > 4095;\n\n      if (!$168) {\n        $169 = $1 + ($167 << 2) | 0;\n        $170 = HEAP32[$169 >> 2] | 0;\n        $171 = ($170 | 0) == 0;\n\n        if (!$171) {\n          label = 29;\n          break;\n        }\n      }\n\n      $172 = $$0151 + 1 | 0;\n      $173 = ($$0151 | 0) < 4;\n\n      if ($173) {\n        $$0151 = $172;\n      } else {\n        label = 6;\n        break;\n      }\n    }\n\n    if ((label | 0) == 6) {\n      $42 = $6 + 1 | 0;\n      $43 = $6 + 2 | 0;\n      $44 = $6 + 3 | 0;\n      $45 = $6 + 4 | 0;\n      $46 = $6 + 5 | 0;\n      $47 = $6 + 6 | 0;\n      $48 = $6 + 7 | 0;\n      $49 = $6 + 8 | 0;\n      $50 = $6 + 9 | 0;\n      $51 = $6 + 10 | 0;\n      $52 = $6 + 11 | 0;\n      $53 = $6 + 12 | 0;\n      $54 = $6 + 13 | 0;\n      $55 = $6 + 14 | 0;\n      $56 = $6 + 15 | 0;\n      $57 = $5 + 1 | 0;\n      $$0126149 = 0;\n\n      while (1) {\n        $58 = $$0126149 + $4 | 0;\n        FUNCTION_TABLE_viiiii[$0 & 7]($58, $42, $5, 5, $7);\n        FUNCTION_TABLE_viiiii[$0 & 7]($58, $43, $5, 5, $7);\n        FUNCTION_TABLE_viiiii[$0 & 7]($58, $44, $5, 5, $7);\n        FUNCTION_TABLE_viiiii[$0 & 7]($58, $45, $5, 5, $7);\n        FUNCTION_TABLE_viiiii[$0 & 7]($58, $46, $5, 5, $7);\n        FUNCTION_TABLE_viiiii[$0 & 7]($58, $47, $5, 5, $7);\n        FUNCTION_TABLE_viiiii[$0 & 7]($58, $48, $5, 5, $7);\n        FUNCTION_TABLE_viiiii[$0 & 7]($58, $49, $5, 5, $7);\n        FUNCTION_TABLE_viiiii[$0 & 7]($58, $50, $5, 5, $7);\n        FUNCTION_TABLE_viiiii[$0 & 7]($58, $51, $5, 5, $7);\n        FUNCTION_TABLE_viiiii[$0 & 7]($58, $52, $5, 5, $7);\n        FUNCTION_TABLE_viiiii[$0 & 7]($58, $53, $5, 5, $7);\n        FUNCTION_TABLE_viiiii[$0 & 7]($58, $54, $5, 5, $7);\n        FUNCTION_TABLE_viiiii[$0 & 7]($58, $55, $5, 5, $7);\n        FUNCTION_TABLE_viiiii[$0 & 7]($58, $56, $5, 5, $7);\n        FUNCTION_TABLE_viiiii[$0 & 7]($58, $42, $57, 5, $7);\n        FUNCTION_TABLE_viiiii[$0 & 7]($58, $43, $57, 5, $7);\n        FUNCTION_TABLE_viiiii[$0 & 7]($58, $44, $57, 5, $7);\n        FUNCTION_TABLE_viiiii[$0 & 7]($58, $45, $57, 5, $7);\n        FUNCTION_TABLE_viiiii[$0 & 7]($58, $46, $57, 5, $7);\n        FUNCTION_TABLE_viiiii[$0 & 7]($58, $47, $57, 5, $7);\n        FUNCTION_TABLE_viiiii[$0 & 7]($58, $48, $57, 5, $7);\n        FUNCTION_TABLE_viiiii[$0 & 7]($58, $49, $57, 5, $7);\n        FUNCTION_TABLE_viiiii[$0 & 7]($58, $50, $57, 5, $7);\n        FUNCTION_TABLE_viiiii[$0 & 7]($58, $51, $57, 5, $7);\n        FUNCTION_TABLE_viiiii[$0 & 7]($58, $52, $57, 5, $7);\n        FUNCTION_TABLE_viiiii[$0 & 7]($58, $53, $57, 5, $7);\n        FUNCTION_TABLE_viiiii[$0 & 7]($58, $54, $57, 5, $7);\n        FUNCTION_TABLE_viiiii[$0 & 7]($58, $55, $57, 5, $7);\n        FUNCTION_TABLE_viiiii[$0 & 7]($58, $56, $57, 5, $7);\n        $59 = $$0126149 + 1 | 0;\n        $exitcond164 = ($59 | 0) == 2;\n\n        if ($exitcond164) {\n          break;\n        } else {\n          $$0126149 = $59;\n        }\n      }\n\n      $$0123146 = -8;\n\n      while (1) {\n        $60 = ($$0123146 | 0) > -1;\n        $61 = ($$0123146 | 0) > 1;\n        $62 = $$0123146 + $4 | 0;\n        $63 = +($62 | 0);\n        $64 = Math_imul($$0123146, $$0123146) | 0;\n        $65 = $62 - $2 | 0;\n        $$0122145 = -8;\n\n        while (1) {\n          $67 = $$0122145 + $5 | 0;\n          $68 = +($67 | 0);\n          $69 = Math_imul($$0122145, $$0122145) | 0;\n          $70 = $69 + $64 | 0;\n          $71 = $67 - $3 | 0;\n          $72 = $71 << 6;\n          $73 = $72 + $65 | 0;\n          $74 = $73 >>> 0 > 4095;\n          $75 = $1 + ($73 << 2) | 0;\n\n          L45: do {\n            if ($60) {\n              $76 = $$0122145 >>> 0 > 1;\n              $$not152 = $76 | $61;\n              $$0120137$us = -8;\n              $$0121136$us = 0;\n\n              while (1) {\n                $77 = +($$0120137$us | 0);\n                $78 = $77 * 0.5;\n                $79 = +_llvm_round_f64(+$78);\n                $80 = ~~$79;\n                $81 = ($56 | 0) >= ($80 | 0);\n                $brmerge = $81 | $$not152;\n\n                if ($brmerge) {\n                  $82 = $$0120137$us + $56 | 0;\n                  $83 = +($82 | 0);\n                  $84 = +_simplex3($63, $68, $83, 1, 1.0, 3.0);\n                  $85 = $84;\n                  $86 = Math_imul($$0120137$us, $$0120137$us) | 0;\n                  $87 = $70 + $86 | 0;\n                  $88 = +($87 | 0);\n                  $89 = +Math_sqrt(+$88);\n                  $90 = $89 * 0.125;\n                  $pow2$us = $90 * $90;\n                  $91 = $pow2$us > $85;\n\n                  if ($91) {\n                    $$2$us = $$0121136$us;\n                  } else {\n                    $92 = $56 + $80 | 0;\n                    FUNCTION_TABLE_viiiii[$0 & 7]($62, $92, $67, 15, $7);\n                    $93 = ($$0121136$us | 0) != 0;\n                    $brmerge154 = $93 | $74;\n                    $$0121136$us$mux = $93 ? $$0121136$us : 1;\n\n                    if ($brmerge154) {\n                      $$2$us = $$0121136$us$mux;\n                    } else {\n                      HEAP32[$75 >> 2] = 1;\n                      $$2$us = 1;\n                    }\n                  }\n                } else {\n                  $$2$us = $$0121136$us;\n                }\n\n                $94 = $$0120137$us + 1 | 0;\n                $exitcond159 = ($94 | 0) == 9;\n\n                if ($exitcond159) {\n                  break;\n                } else {\n                  $$0120137$us = $94;\n                  $$0121136$us = $$2$us;\n                }\n              }\n            } else {\n              if ($74) {\n                $$0120137$us139 = -8;\n\n                while (1) {\n                  $95 = $$0120137$us139 + $56 | 0;\n                  $96 = +($95 | 0);\n                  $97 = +_simplex3($63, $68, $96, 1, 1.0, 3.0);\n                  $98 = $97;\n                  $99 = Math_imul($$0120137$us139, $$0120137$us139) | 0;\n                  $100 = $70 + $99 | 0;\n                  $101 = +($100 | 0);\n                  $102 = +Math_sqrt(+$101);\n                  $103 = $102 * 0.125;\n                  $pow2$us141 = $103 * $103;\n                  $104 = $pow2$us141 > $98;\n\n                  if (!$104) {\n                    $105 = +($$0120137$us139 | 0);\n                    $106 = $105 * 0.5;\n                    $107 = +_llvm_round_f64(+$106);\n                    $108 = ~~$107;\n                    $109 = $56 + $108 | 0;\n                    FUNCTION_TABLE_viiiii[$0 & 7]($62, $109, $67, 15, $7);\n                  }\n\n                  $110 = $$0120137$us139 + 1 | 0;\n                  $exitcond158 = ($110 | 0) == 9;\n\n                  if ($exitcond158) {\n                    break L45;\n                  } else {\n                    $$0120137$us139 = $110;\n                  }\n                }\n              }\n\n              $$0120137 = -8;\n              $$0121136 = 0;\n\n              while (1) {\n                $112 = $$0120137 + $56 | 0;\n                $113 = +($112 | 0);\n                $114 = +_simplex3($63, $68, $113, 1, 1.0, 3.0);\n                $115 = $114;\n                $116 = Math_imul($$0120137, $$0120137) | 0;\n                $117 = $70 + $116 | 0;\n                $118 = +($117 | 0);\n                $119 = +Math_sqrt(+$118);\n                $120 = $119 * 0.125;\n                $pow2 = $120 * $120;\n                $121 = $pow2 > $115;\n\n                if ($121) {\n                  $$2 = $$0121136;\n                } else {\n                  $122 = +($$0120137 | 0);\n                  $123 = $122 * 0.5;\n                  $124 = +_llvm_round_f64(+$123);\n                  $125 = ~~$124;\n                  $126 = $56 + $125 | 0;\n                  FUNCTION_TABLE_viiiii[$0 & 7]($62, $126, $67, 15, $7);\n                  $127 = ($$0121136 | 0) == 0;\n\n                  if ($127) {\n                    HEAP32[$75 >> 2] = 1;\n                    $$2 = 1;\n                  } else {\n                    $$2 = $$0121136;\n                  }\n                }\n\n                $128 = $$0120137 + 1 | 0;\n                $exitcond = ($128 | 0) == 9;\n\n                if ($exitcond) {\n                  break;\n                } else {\n                  $$0120137 = $128;\n                  $$0121136 = $$2;\n                }\n              }\n            }\n          } while (0);\n\n          $111 = $$0122145 + 1 | 0;\n          $exitcond160 = ($111 | 0) == 8;\n\n          if ($exitcond160) {\n            break;\n          } else {\n            $$0122145 = $111;\n          }\n        }\n\n        $66 = $$0123146 + 1 | 0;\n        $exitcond161 = ($66 | 0) == 8;\n\n        if ($exitcond161) {\n          break;\n        } else {\n          $$0123146 = $66;\n        }\n      }\n\n      return;\n    } else if ((label | 0) == 29) {\n      return;\n    }\n  }\n\n  function _gen_buildings($0, $1, $2, $3, $4, $5, $6, $7) {\n    $0 = $0 | 0;\n    $1 = $1 | 0;\n    $2 = $2 | 0;\n    $3 = $3 | 0;\n    $4 = $4 | 0;\n    $5 = $5 | 0;\n    $6 = $6 | 0;\n    $7 = $7 | 0;\n    var $$08799 = 0,\n        $$08799$us = 0,\n        $$088104 = 0,\n        $$091106 = 0,\n        $10 = 0.0,\n        $100 = 0,\n        $101 = 0,\n        $102 = 0,\n        $103 = 0,\n        $104 = 0,\n        $105 = 0,\n        $106 = 0,\n        $107 = 0,\n        $108 = 0,\n        $109 = 0,\n        $11 = 0.0,\n        $110 = 0,\n        $111 = 0,\n        $112 = 0,\n        $113 = 0;\n    var $114 = 0,\n        $115 = 0,\n        $116 = 0,\n        $117 = 0,\n        $118 = 0,\n        $119 = 0,\n        $12 = 0,\n        $120 = 0,\n        $121 = 0,\n        $122 = 0,\n        $123 = 0,\n        $124 = 0,\n        $125 = 0,\n        $126 = 0,\n        $127 = 0,\n        $128 = 0,\n        $129 = 0,\n        $13 = 0,\n        $130 = 0,\n        $131 = 0;\n    var $132 = 0,\n        $133 = 0,\n        $134 = 0,\n        $135 = 0,\n        $136 = 0,\n        $137 = 0,\n        $138 = 0,\n        $139 = 0,\n        $14 = 0,\n        $140 = 0,\n        $141 = 0,\n        $142 = 0,\n        $143 = 0,\n        $144 = 0,\n        $145 = 0,\n        $146 = 0,\n        $147 = 0,\n        $148 = 0,\n        $149 = 0,\n        $15 = 0;\n    var $150 = 0,\n        $151 = 0,\n        $152 = 0,\n        $153 = 0,\n        $154 = 0,\n        $155 = 0,\n        $156 = 0,\n        $157 = 0,\n        $158 = 0,\n        $159 = 0,\n        $16 = 0,\n        $160 = 0,\n        $161 = 0,\n        $162 = 0,\n        $163 = 0,\n        $164 = 0,\n        $165 = 0,\n        $166 = 0,\n        $167 = 0,\n        $168 = 0;\n    var $169 = 0,\n        $17 = 0,\n        $170 = 0,\n        $171 = 0,\n        $172 = 0,\n        $173 = 0,\n        $174 = 0,\n        $175 = 0,\n        $176 = 0,\n        $177 = 0,\n        $178 = 0,\n        $18 = 0,\n        $19 = 0,\n        $20 = 0,\n        $21 = 0,\n        $22 = 0,\n        $23 = 0,\n        $24 = 0,\n        $25 = 0,\n        $26 = 0;\n    var $27 = 0,\n        $28 = 0,\n        $29 = 0,\n        $30 = 0,\n        $31 = 0,\n        $32 = 0,\n        $33 = 0,\n        $34 = 0,\n        $35 = 0,\n        $36 = 0,\n        $37 = 0,\n        $38 = 0,\n        $39 = 0,\n        $40 = 0,\n        $41 = 0,\n        $42 = 0,\n        $43 = 0,\n        $44 = 0,\n        $45 = 0,\n        $46 = 0;\n    var $47 = 0,\n        $48 = 0,\n        $49 = 0,\n        $50 = 0,\n        $51 = 0,\n        $52 = 0,\n        $53 = 0,\n        $54 = 0,\n        $55 = 0,\n        $56 = 0,\n        $57 = 0,\n        $58 = 0,\n        $59 = 0,\n        $60 = 0,\n        $61 = 0,\n        $62 = 0,\n        $63 = 0,\n        $64 = 0,\n        $65 = 0,\n        $66 = 0;\n    var $67 = 0,\n        $68 = 0,\n        $69 = 0,\n        $70 = 0,\n        $71 = 0,\n        $72 = 0,\n        $73 = 0,\n        $74 = 0,\n        $75 = 0,\n        $76 = 0,\n        $77 = 0,\n        $78 = 0,\n        $79 = 0,\n        $8 = 0.0,\n        $80 = 0,\n        $81 = 0,\n        $82 = 0,\n        $83 = 0,\n        $84 = 0,\n        $85 = 0;\n    var $86 = 0,\n        $87 = 0,\n        $88 = 0,\n        $89 = 0,\n        $9 = 0.0,\n        $90 = 0,\n        $91 = 0,\n        $92 = 0,\n        $93 = 0,\n        $94 = 0,\n        $95 = 0,\n        $96 = 0,\n        $97 = 0,\n        $98 = 0,\n        $99 = 0,\n        $exitcond = 0,\n        $exitcond114 = 0,\n        $exitcond115 = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    $8 = +($4 | 0);\n    $9 = +($5 | 0);\n    $10 = +_simplex2($8, $9, 1, 1.0, 3.0);\n    $11 = $10;\n    $12 = $11 > 0.97999999999999998;\n\n    if (!$12) {\n      return;\n    }\n\n    $13 = $5 - $3 | 0;\n    $14 = $4 - $2 | 0;\n    $15 = $13 << 6;\n    $16 = $15 + -512 | 0;\n    $17 = $13 << 6;\n    $18 = $17 + -448 | 0;\n    $19 = $13 << 6;\n    $20 = $19 + -384 | 0;\n    $21 = $13 << 6;\n    $22 = $21 + -320 | 0;\n    $23 = $13 << 6;\n    $24 = $23 + -256 | 0;\n    $25 = $13 << 6;\n    $26 = $25 + -192 | 0;\n    $27 = $13 << 6;\n    $28 = $27 + -128 | 0;\n    $29 = $13 << 6;\n    $30 = $29 + -64 | 0;\n    $31 = $13 << 6;\n    $32 = $13 << 6;\n    $33 = $32 + 64 | 0;\n    $34 = $13 << 6;\n    $35 = $34 + 128 | 0;\n    $36 = $13 << 6;\n    $37 = $36 + 192 | 0;\n    $38 = $13 << 6;\n    $39 = $38 + 256 | 0;\n    $40 = $13 << 6;\n    $41 = $40 + 320 | 0;\n    $42 = $13 << 6;\n    $43 = $42 + 384 | 0;\n    $44 = $13 << 6;\n    $45 = $44 + 448 | 0;\n    $46 = $13 << 6;\n    $47 = $46 + 512 | 0;\n    $$091106 = -8;\n\n    while (1) {\n      $48 = $14 + $$091106 | 0;\n      $49 = $48 + $16 | 0;\n      $50 = $49 >>> 0 > 4095;\n\n      if (!$50) {\n        $51 = $1 + ($49 << 2) | 0;\n        $52 = HEAP32[$51 >> 2] | 0;\n        $53 = ($52 | 0) == 0;\n\n        if (!$53) {\n          label = 20;\n          break;\n        }\n      }\n\n      $54 = $48 + $18 | 0;\n      $55 = $54 >>> 0 > 4095;\n\n      if (!$55) {\n        $99 = $1 + ($54 << 2) | 0;\n        $100 = HEAP32[$99 >> 2] | 0;\n        $101 = ($100 | 0) == 0;\n\n        if (!$101) {\n          label = 20;\n          break;\n        }\n      }\n\n      $102 = $48 + $20 | 0;\n      $103 = $102 >>> 0 > 4095;\n\n      if (!$103) {\n        $104 = $1 + ($102 << 2) | 0;\n        $105 = HEAP32[$104 >> 2] | 0;\n        $106 = ($105 | 0) == 0;\n\n        if (!$106) {\n          label = 20;\n          break;\n        }\n      }\n\n      $107 = $48 + $22 | 0;\n      $108 = $107 >>> 0 > 4095;\n\n      if (!$108) {\n        $109 = $1 + ($107 << 2) | 0;\n        $110 = HEAP32[$109 >> 2] | 0;\n        $111 = ($110 | 0) == 0;\n\n        if (!$111) {\n          label = 20;\n          break;\n        }\n      }\n\n      $112 = $48 + $24 | 0;\n      $113 = $112 >>> 0 > 4095;\n\n      if (!$113) {\n        $114 = $1 + ($112 << 2) | 0;\n        $115 = HEAP32[$114 >> 2] | 0;\n        $116 = ($115 | 0) == 0;\n\n        if (!$116) {\n          label = 20;\n          break;\n        }\n      }\n\n      $117 = $48 + $26 | 0;\n      $118 = $117 >>> 0 > 4095;\n\n      if (!$118) {\n        $119 = $1 + ($117 << 2) | 0;\n        $120 = HEAP32[$119 >> 2] | 0;\n        $121 = ($120 | 0) == 0;\n\n        if (!$121) {\n          label = 20;\n          break;\n        }\n      }\n\n      $122 = $48 + $28 | 0;\n      $123 = $122 >>> 0 > 4095;\n\n      if (!$123) {\n        $124 = $1 + ($122 << 2) | 0;\n        $125 = HEAP32[$124 >> 2] | 0;\n        $126 = ($125 | 0) == 0;\n\n        if (!$126) {\n          label = 20;\n          break;\n        }\n      }\n\n      $127 = $48 + $30 | 0;\n      $128 = $127 >>> 0 > 4095;\n\n      if (!$128) {\n        $129 = $1 + ($127 << 2) | 0;\n        $130 = HEAP32[$129 >> 2] | 0;\n        $131 = ($130 | 0) == 0;\n\n        if (!$131) {\n          label = 20;\n          break;\n        }\n      }\n\n      $132 = $48 + $31 | 0;\n      $133 = $132 >>> 0 > 4095;\n\n      if (!$133) {\n        $134 = $1 + ($132 << 2) | 0;\n        $135 = HEAP32[$134 >> 2] | 0;\n        $136 = ($135 | 0) == 0;\n\n        if (!$136) {\n          label = 20;\n          break;\n        }\n      }\n\n      $137 = $48 + $33 | 0;\n      $138 = $137 >>> 0 > 4095;\n\n      if (!$138) {\n        $139 = $1 + ($137 << 2) | 0;\n        $140 = HEAP32[$139 >> 2] | 0;\n        $141 = ($140 | 0) == 0;\n\n        if (!$141) {\n          label = 20;\n          break;\n        }\n      }\n\n      $142 = $48 + $35 | 0;\n      $143 = $142 >>> 0 > 4095;\n\n      if (!$143) {\n        $144 = $1 + ($142 << 2) | 0;\n        $145 = HEAP32[$144 >> 2] | 0;\n        $146 = ($145 | 0) == 0;\n\n        if (!$146) {\n          label = 20;\n          break;\n        }\n      }\n\n      $147 = $48 + $37 | 0;\n      $148 = $147 >>> 0 > 4095;\n\n      if (!$148) {\n        $149 = $1 + ($147 << 2) | 0;\n        $150 = HEAP32[$149 >> 2] | 0;\n        $151 = ($150 | 0) == 0;\n\n        if (!$151) {\n          label = 20;\n          break;\n        }\n      }\n\n      $152 = $48 + $39 | 0;\n      $153 = $152 >>> 0 > 4095;\n\n      if (!$153) {\n        $154 = $1 + ($152 << 2) | 0;\n        $155 = HEAP32[$154 >> 2] | 0;\n        $156 = ($155 | 0) == 0;\n\n        if (!$156) {\n          label = 20;\n          break;\n        }\n      }\n\n      $157 = $48 + $41 | 0;\n      $158 = $157 >>> 0 > 4095;\n\n      if (!$158) {\n        $159 = $1 + ($157 << 2) | 0;\n        $160 = HEAP32[$159 >> 2] | 0;\n        $161 = ($160 | 0) == 0;\n\n        if (!$161) {\n          label = 20;\n          break;\n        }\n      }\n\n      $162 = $48 + $43 | 0;\n      $163 = $162 >>> 0 > 4095;\n\n      if (!$163) {\n        $164 = $1 + ($162 << 2) | 0;\n        $165 = HEAP32[$164 >> 2] | 0;\n        $166 = ($165 | 0) == 0;\n\n        if (!$166) {\n          label = 20;\n          break;\n        }\n      }\n\n      $167 = $48 + $45 | 0;\n      $168 = $167 >>> 0 > 4095;\n\n      if (!$168) {\n        $169 = $1 + ($167 << 2) | 0;\n        $170 = HEAP32[$169 >> 2] | 0;\n        $171 = ($170 | 0) == 0;\n\n        if (!$171) {\n          label = 20;\n          break;\n        }\n      }\n\n      $172 = $48 + $47 | 0;\n      $173 = $172 >>> 0 > 4095;\n\n      if (!$173) {\n        $174 = $1 + ($172 << 2) | 0;\n        $175 = HEAP32[$174 >> 2] | 0;\n        $176 = ($175 | 0) == 0;\n\n        if (!$176) {\n          label = 20;\n          break;\n        }\n      }\n\n      $177 = $$091106 + 1 | 0;\n      $178 = ($$091106 | 0) < 8;\n\n      if ($178) {\n        $$091106 = $177;\n      } else {\n        label = 6;\n        break;\n      }\n    }\n\n    if ((label | 0) == 6) {\n      $56 = $6 + 1 | 0;\n      $57 = $6 + 2 | 0;\n      $58 = $6 + 3 | 0;\n      $59 = $6 + 4 | 0;\n      $60 = $6 + 5 | 0;\n      $61 = $6 + 6 | 0;\n      $62 = $6 + 7 | 0;\n      $63 = $6 + 8 | 0;\n      $64 = $6 + 1 | 0;\n      $65 = $6 + 2 | 0;\n      $66 = $6 + 3 | 0;\n      $67 = $6 + 4 | 0;\n      $68 = $6 + 5 | 0;\n      $69 = $6 + 6 | 0;\n      $70 = $6 + 7 | 0;\n      $71 = $6 + 8 | 0;\n      $72 = $6 + 1 | 0;\n      $73 = $6 + 2 | 0;\n      $74 = $6 + 3 | 0;\n      $75 = $6 + 4 | 0;\n      $76 = $6 + 5 | 0;\n      $77 = $6 + 6 | 0;\n      $78 = $6 + 7 | 0;\n      $79 = $6 + 8 | 0;\n      $$088104 = -8;\n\n      while (1) {\n        $80 = $$088104 + $4 | 0;\n        $81 = $80 - $2 | 0;\n        $82 = ($$088104 | 0) == -8;\n        $83 = ($$088104 | 0) == 8;\n\n        if ($83) {\n          $$08799$us = -8;\n\n          while (1) {\n            $84 = $$08799$us + $5 | 0;\n            $85 = $84 - $3 | 0;\n            $86 = $85 << 6;\n            $87 = $86 + $81 | 0;\n            $88 = $87 >>> 0 > 4095;\n\n            if (!$88) {\n              $89 = $1 + ($87 << 2) | 0;\n              HEAP32[$89 >> 2] = 1;\n            }\n\n            FUNCTION_TABLE_viiiii[$0 & 7]($80, $56, $84, 3, $7);\n            FUNCTION_TABLE_viiiii[$0 & 7]($80, $57, $84, 3, $7);\n            FUNCTION_TABLE_viiiii[$0 & 7]($80, $58, $84, 3, $7);\n            FUNCTION_TABLE_viiiii[$0 & 7]($80, $59, $84, 3, $7);\n            FUNCTION_TABLE_viiiii[$0 & 7]($80, $60, $84, 3, $7);\n            FUNCTION_TABLE_viiiii[$0 & 7]($80, $61, $84, 3, $7);\n            FUNCTION_TABLE_viiiii[$0 & 7]($80, $62, $84, 3, $7);\n            FUNCTION_TABLE_viiiii[$0 & 7]($80, $63, $84, 3, $7);\n            $90 = $$08799$us + 1 | 0;\n            $exitcond114 = ($90 | 0) == 9;\n\n            if ($exitcond114) {\n              break;\n            } else {\n              $$08799$us = $90;\n            }\n          }\n        } else {\n          $$08799 = -8;\n\n          while (1) {\n            $92 = $$08799 + $5 | 0;\n            $93 = $92 - $3 | 0;\n            $94 = $93 << 6;\n            $95 = $94 + $81 | 0;\n            $96 = $95 >>> 0 > 4095;\n\n            if (!$96) {\n              $97 = $1 + ($95 << 2) | 0;\n              HEAP32[$97 >> 2] = 1;\n            }\n\n            L74: do {\n              if ($82) {\n                label = 18;\n              } else {\n                switch ($$08799 | 0) {\n                  case 8:\n                  case -8:\n                    {\n                      label = 18;\n                      break L74;\n                      break;\n                    }\n\n                  default:\n                    {}\n                }\n\n                FUNCTION_TABLE_viiiii[$0 & 7]($80, $72, $92, 0, $7);\n                FUNCTION_TABLE_viiiii[$0 & 7]($80, $73, $92, 0, $7);\n                FUNCTION_TABLE_viiiii[$0 & 7]($80, $74, $92, 0, $7);\n                FUNCTION_TABLE_viiiii[$0 & 7]($80, $75, $92, 0, $7);\n                FUNCTION_TABLE_viiiii[$0 & 7]($80, $76, $92, 0, $7);\n                FUNCTION_TABLE_viiiii[$0 & 7]($80, $77, $92, 0, $7);\n                FUNCTION_TABLE_viiiii[$0 & 7]($80, $78, $92, 0, $7);\n                FUNCTION_TABLE_viiiii[$0 & 7]($80, $79, $92, 3, $7);\n              }\n            } while (0);\n\n            if ((label | 0) == 18) {\n              label = 0;\n              FUNCTION_TABLE_viiiii[$0 & 7]($80, $64, $92, 3, $7);\n              FUNCTION_TABLE_viiiii[$0 & 7]($80, $65, $92, 3, $7);\n              FUNCTION_TABLE_viiiii[$0 & 7]($80, $66, $92, 3, $7);\n              FUNCTION_TABLE_viiiii[$0 & 7]($80, $67, $92, 3, $7);\n              FUNCTION_TABLE_viiiii[$0 & 7]($80, $68, $92, 3, $7);\n              FUNCTION_TABLE_viiiii[$0 & 7]($80, $69, $92, 3, $7);\n              FUNCTION_TABLE_viiiii[$0 & 7]($80, $70, $92, 3, $7);\n              FUNCTION_TABLE_viiiii[$0 & 7]($80, $71, $92, 3, $7);\n            }\n\n            $98 = $$08799 + 1 | 0;\n            $exitcond = ($98 | 0) == 9;\n\n            if ($exitcond) {\n              break;\n            } else {\n              $$08799 = $98;\n            }\n          }\n        }\n\n        $91 = $$088104 + 1 | 0;\n        $exitcond115 = ($91 | 0) == 9;\n\n        if ($exitcond115) {\n          break;\n        } else {\n          $$088104 = $91;\n        }\n      }\n\n      return;\n    } else if ((label | 0) == 20) {\n      return;\n    }\n  }\n\n  function _create_world($0, $1, $2, $3, $4) {\n    $0 = $0 | 0;\n    $1 = $1 | 0;\n    $2 = $2 | 0;\n    $3 = $3 | 0;\n    $4 = $4 | 0;\n    var $$0101103 = 0,\n        $$0102104 = 0,\n        $$0105 = 0,\n        $10 = 0,\n        $11 = 0,\n        $12 = 0.0,\n        $13 = 0.0,\n        $14 = 0,\n        $15 = 0.0,\n        $16 = 0.0,\n        $17 = 0.0,\n        $18 = 0.0,\n        $19 = 0.0,\n        $20 = 0,\n        $21 = 0,\n        $22 = 0.0,\n        $23 = 0.0,\n        $24 = 0.0,\n        $25 = 0,\n        $26 = 0.0;\n    var $27 = 0.0,\n        $28 = 0.0,\n        $29 = 0.0,\n        $30 = 0.0,\n        $31 = 0,\n        $32 = 0.0,\n        $33 = 0.0,\n        $34 = 0,\n        $35 = 0,\n        $36 = 0.0,\n        $37 = 0.0,\n        $38 = 0.0,\n        $39 = 0,\n        $40 = 0,\n        $41 = 0,\n        $42 = 0,\n        $43 = 0,\n        $44 = 0,\n        $45 = 0.0,\n        $46 = 0.0;\n    var $47 = 0.0,\n        $48 = 0.0,\n        $49 = 0,\n        $5 = 0,\n        $50 = 0,\n        $6 = 0,\n        $7 = 0,\n        $8 = 0,\n        $9 = 0,\n        $exitcond = 0,\n        $exitcond106 = 0,\n        $exitcond107 = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    STACKTOP = STACKTOP + 16384 | 0;\n    if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16384 | 0);\n    $5 = sp;\n    _memset($5 | 0, 0, 16384) | 0;\n    $6 = $0 << 5;\n    $7 = $1 << 5;\n    $8 = $2 << 5;\n    $9 = $6 + -16 | 0;\n    $10 = $7 + -16 | 0;\n    $$0105 = -16;\n\n    while (1) {\n      $11 = $$0105 + $6 | 0;\n      $12 = +($11 | 0);\n      $13 = $12 * 0.0010000000474974513;\n      $14 = 0 - $11 | 0;\n      $15 = +($14 | 0);\n      $16 = $15 * 0.0010000000474974513;\n      $17 = +($11 | 0);\n      $18 = $17 * 0.01;\n      $19 = $18;\n      $$0102104 = -16;\n\n      while (1) {\n        $21 = $$0102104 + $7 | 0;\n        $22 = +($21 | 0);\n        $23 = $22 * 0.0010000000474974513;\n        $24 = +_simplex2($13, $23, 5, 0.5, 3.0);\n        $25 = 0 - $21 | 0;\n        $26 = +($25 | 0);\n        $27 = $26 * 0.0010000000474974513;\n        $28 = +_simplex2($16, $27, 2, 0.89999997615814208, 4.0);\n        $29 = $28 * 32.0;\n        $30 = $29 + 16.0;\n        $31 = ~~$30;\n        $32 = +($31 | 0);\n        $33 = $24 * $32;\n        $34 = ~~$33;\n        $35 = $34 + -5 | 0;\n        $36 = +($21 | 0);\n        $37 = $36 * 0.01;\n        $38 = $37;\n        $$0101103 = -16;\n\n        while (1) {\n          $40 = $$0101103 + $8 | 0;\n          $41 = ($40 | 0) > ($35 | 0);\n\n          do {\n            if ($41) {\n              $42 = ($40 | 0) > ($34 | 0);\n\n              if (!$42) {\n                FUNCTION_TABLE_viiiii[$3 & 7]($11, $40, $21, 1, $4);\n                break;\n              }\n\n              $43 = $40 & -8;\n              $44 = ($43 | 0) == 64;\n\n              if ($44) {\n                $45 = +($40 | 0);\n                $46 = $45 * 0.10000000000000001;\n                $47 = $46;\n                $48 = +_simplex3($19, $47, $38, 8, 0.5, 2.0);\n                $49 = $48 > 0.75;\n\n                if ($49) {\n                  FUNCTION_TABLE_viiiii[$3 & 7]($11, $40, $21, 16, $4);\n                }\n              }\n            } else {\n              FUNCTION_TABLE_viiiii[$3 & 7]($11, $40, $21, 6, $4);\n            }\n          } while (0);\n\n          $50 = $$0101103 + 1 | 0;\n          $exitcond = ($50 | 0) == 48;\n\n          if ($exitcond) {\n            break;\n          } else {\n            $$0101103 = $50;\n          }\n        }\n\n        _gen_buildings($3, $5, $9, $10, $11, $21, $34, $4);\n\n        _gen_trees($3, $5, $9, $10, $11, $21, $34, $4);\n\n        $39 = $$0102104 + 1 | 0;\n        $exitcond106 = ($39 | 0) == 48;\n\n        if ($exitcond106) {\n          break;\n        } else {\n          $$0102104 = $39;\n        }\n      }\n\n      $20 = $$0105 + 1 | 0;\n      $exitcond107 = ($20 | 0) == 48;\n\n      if ($exitcond107) {\n        break;\n      } else {\n        $$0105 = $20;\n      }\n    }\n\n    STACKTOP = sp;\n    return;\n  }\n\n  function _map_alloc($0, $1, $2, $3, $4) {\n    $0 = $0 | 0;\n    $1 = $1 | 0;\n    $2 = $2 | 0;\n    $3 = $3 | 0;\n    $4 = $4 | 0;\n    var $10 = 0,\n        $11 = 0,\n        $5 = 0,\n        $6 = 0,\n        $7 = 0,\n        $8 = 0,\n        $9 = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    HEAP32[$0 >> 2] = $1;\n    $5 = $0 + 4 | 0;\n    HEAP32[$5 >> 2] = $2;\n    $6 = $0 + 8 | 0;\n    HEAP32[$6 >> 2] = $3;\n    $7 = $0 + 12 | 0;\n    HEAP32[$7 >> 2] = $4;\n    $8 = $4 + 1 | 0;\n    $9 = $0 + 16 | 0;\n    HEAP32[$9 >> 2] = $8;\n    $10 = _calloc($8, 2) | 0;\n    $11 = $0 + 20 | 0;\n    HEAP32[$11 >> 2] = $10;\n    return;\n  }\n\n  function _map_free($0) {\n    $0 = $0 | 0;\n    var $1 = 0,\n        $2 = 0,\n        $3 = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    $1 = $0 + 20 | 0;\n    $2 = HEAP32[$1 >> 2] | 0;\n    $3 = ($2 | 0) == (0 | 0);\n\n    if ($3) {\n      _puts(852) | 0;\n      return;\n    } else {\n      _free($2);\n\n      HEAP32[$1 >> 2] = 0;\n      return;\n    }\n  }\n\n  function _map_set($0, $1, $2, $3, $4) {\n    $0 = $0 | 0;\n    $1 = $1 | 0;\n    $2 = $2 | 0;\n    $3 = $3 | 0;\n    $4 = $4 | 0;\n    var $$0 = 0,\n        $10 = 0,\n        $11 = 0,\n        $12 = 0,\n        $13 = 0,\n        $14 = 0,\n        $15 = 0,\n        $16 = 0,\n        $17 = 0,\n        $18 = 0,\n        $19 = 0,\n        $20 = 0,\n        $21 = 0,\n        $22 = 0,\n        $23 = 0,\n        $24 = 0,\n        $25 = 0,\n        $26 = 0,\n        $5 = 0,\n        $6 = 0;\n    var $7 = 0,\n        $8 = 0,\n        $9 = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    $5 = HEAP32[$0 >> 2] | 0;\n    $6 = $1 - $5 | 0;\n    $7 = $0 + 8 | 0;\n    $8 = HEAP32[$7 >> 2] | 0;\n    $9 = $3 - $8 | 0;\n    $10 = $6 & 255;\n    $11 = $10 >>> 0 > 31;\n\n    if ($11) {\n      $$0 = 0;\n      return $$0 | 0;\n    }\n\n    $12 = $0 + 4 | 0;\n    $13 = HEAP32[$12 >> 2] | 0;\n    $14 = $2 - $13 | 0;\n    $15 = $14 & 255;\n    $16 = $15 >>> 0 > 31;\n\n    if ($16) {\n      $$0 = 0;\n      return $$0 | 0;\n    }\n\n    $17 = $9 & 255;\n    $18 = $17 >>> 0 > 31;\n\n    if ($18) {\n      $$0 = 0;\n      return $$0 | 0;\n    }\n\n    $19 = $0 + 20 | 0;\n    $20 = $15 << 5;\n    $21 = $17 << 10;\n    $22 = $21 | $10;\n    $23 = $22 + $20 | 0;\n    $24 = HEAP32[$19 >> 2] | 0;\n    $25 = $4 & 255;\n    $26 = ($24 + ($23 << 1) | 0) + 1 | 0;\n    HEAP8[$26 >> 0] = $25;\n    $$0 = 1;\n    return $$0 | 0;\n  }\n\n  function _sign_list_alloc($0, $1) {\n    $0 = $0 | 0;\n    $1 = $1 | 0;\n    var $2 = 0,\n        $3 = 0,\n        $4 = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    HEAP32[$0 >> 2] = $1;\n    $2 = $0 + 4 | 0;\n    HEAP32[$2 >> 2] = 0;\n    $3 = _calloc($1, 80) | 0;\n    $4 = $0 + 8 | 0;\n    HEAP32[$4 >> 2] = $3;\n    return;\n  }\n\n  function _sign_list_free($0) {\n    $0 = $0 | 0;\n    var $1 = 0,\n        $2 = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    $1 = $0 + 8 | 0;\n    $2 = HEAP32[$1 >> 2] | 0;\n\n    _free($2);\n\n    return;\n  }\n\n  function _noise2($0, $1) {\n    $0 = +$0;\n    $1 = +$1;\n    var $10 = 0.0,\n        $100 = 0,\n        $101 = 0.0,\n        $102 = 0.0,\n        $103 = 0,\n        $104 = 0.0,\n        $105 = 0.0,\n        $106 = 0.0,\n        $107 = 0.0,\n        $108 = 0.0,\n        $109 = 0.0,\n        $11 = 0.0,\n        $110 = 0.0,\n        $111 = 0.0,\n        $112 = 0.0,\n        $113 = 0.0,\n        $12 = 0.0,\n        $13 = 0.0,\n        $14 = 0,\n        $15 = 0;\n    var $16 = 0,\n        $17 = 0,\n        $18 = 0.0,\n        $19 = 0.0,\n        $2 = 0.0,\n        $20 = 0.0,\n        $21 = 0.0,\n        $22 = 0.0,\n        $23 = 0.0,\n        $24 = 0.0,\n        $25 = 0.0,\n        $26 = 0.0,\n        $27 = 0.0,\n        $28 = 0,\n        $29 = 0,\n        $3 = 0.0,\n        $30 = 0,\n        $31 = 0,\n        $32 = 0,\n        $33 = 0;\n    var $34 = 0,\n        $35 = 0,\n        $36 = 0,\n        $37 = 0,\n        $38 = 0,\n        $39 = 0,\n        $4 = 0.0,\n        $40 = 0,\n        $41 = 0,\n        $42 = 0,\n        $43 = 0,\n        $44 = 0,\n        $45 = 0,\n        $46 = 0,\n        $47 = 0,\n        $48 = 0,\n        $49 = 0,\n        $5 = 0.0,\n        $50 = 0,\n        $51 = 0;\n    var $52 = 0,\n        $53 = 0,\n        $54 = 0,\n        $55 = 0,\n        $56 = 0,\n        $57 = 0,\n        $58 = 0,\n        $59 = 0,\n        $6 = 0.0,\n        $60 = 0.0,\n        $61 = 0.0,\n        $62 = 0.0,\n        $63 = 0.0,\n        $64 = 0.0,\n        $65 = 0.0,\n        $66 = 0.0,\n        $67 = 0.0,\n        $68 = 0.0,\n        $69 = 0.0,\n        $7 = 0.0;\n    var $70 = 0.0,\n        $71 = 0.0,\n        $72 = 0,\n        $73 = 0.0,\n        $74 = 0.0,\n        $75 = 0.0,\n        $76 = 0,\n        $77 = 0.0,\n        $78 = 0.0,\n        $79 = 0,\n        $8 = 0.0,\n        $80 = 0.0,\n        $81 = 0.0,\n        $82 = 0.0,\n        $83 = 0.0,\n        $84 = 0,\n        $85 = 0.0,\n        $86 = 0.0,\n        $87 = 0.0,\n        $88 = 0;\n    var $89 = 0.0,\n        $9 = 0.0,\n        $90 = 0.0,\n        $91 = 0,\n        $92 = 0.0,\n        $93 = 0.0,\n        $94 = 0.0,\n        $95 = 0.0,\n        $96 = 0,\n        $97 = 0.0,\n        $98 = 0.0,\n        $99 = 0.0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    $2 = $0 + $1;\n    $3 = $2 * 0.3660254180431366;\n    $4 = $3 + $0;\n    $5 = +Math_floor(+$4);\n    $6 = $3 + $1;\n    $7 = +Math_floor(+$6);\n    $8 = $5 + $7;\n    $9 = $8 * 0.21132487058639526;\n    $10 = $5 - $9;\n    $11 = $0 - $10;\n    $12 = $7 - $9;\n    $13 = $1 - $12;\n    $14 = $11 > $13;\n    $15 = $14 & 1;\n    $16 = $11 <= $13;\n    $17 = $16 & 1;\n    $18 = $11 + 0.42264974117279053;\n    $19 = $18 + -1.0;\n    $20 = $13 + 0.42264974117279053;\n    $21 = $20 + -1.0;\n    $22 = +($14 & 1);\n    $23 = $11 - $22;\n    $24 = $23 + 0.21132487058639526;\n    $25 = +($16 & 1);\n    $26 = $13 - $25;\n    $27 = $26 + 0.21132487058639526;\n    $28 = ~~$5;\n    $29 = $28 & 255;\n    $30 = ~~$7;\n    $31 = $30 & 255;\n    $32 = 16 + $31 | 0;\n    $33 = HEAP8[$32 >> 0] | 0;\n    $34 = $33 & 255;\n    $35 = $29 + $34 | 0;\n    $36 = 16 + $35 | 0;\n    $37 = HEAP8[$36 >> 0] | 0;\n    $38 = ($37 & 255) % 12 & -1;\n    $39 = $38 & 255;\n    $40 = $29 + $15 | 0;\n    $41 = $31 + $17 | 0;\n    $42 = 16 + $41 | 0;\n    $43 = HEAP8[$42 >> 0] | 0;\n    $44 = $43 & 255;\n    $45 = $40 + $44 | 0;\n    $46 = 16 + $45 | 0;\n    $47 = HEAP8[$46 >> 0] | 0;\n    $48 = ($47 & 255) % 12 & -1;\n    $49 = $48 & 255;\n    $50 = $29 + 1 | 0;\n    $51 = $31 + 1 | 0;\n    $52 = 16 + $51 | 0;\n    $53 = HEAP8[$52 >> 0] | 0;\n    $54 = $53 & 255;\n    $55 = $50 + $54 | 0;\n    $56 = 16 + $55 | 0;\n    $57 = HEAP8[$56 >> 0] | 0;\n    $58 = ($57 & 255) % 12 & -1;\n    $59 = $58 & 255;\n    $60 = $11 * $11;\n    $61 = 0.5 - $60;\n    $62 = $13 * $13;\n    $63 = $61 - $62;\n    $64 = $24 * $24;\n    $65 = 0.5 - $64;\n    $66 = $27 * $27;\n    $67 = $65 - $66;\n    $68 = $19 * $19;\n    $69 = 0.5 - $68;\n    $70 = $21 * $21;\n    $71 = $69 - $70;\n    $72 = $63 > 0.0;\n\n    if ($72) {\n      $73 = $63 * $63;\n      $74 = $63 * $73;\n      $75 = $63 * $74;\n      $76 = 528 + ($39 * 12 | 0) | 0;\n      $77 = +HEAPF32[$76 >> 2];\n      $78 = $77 * $11;\n      $79 = (528 + ($39 * 12 | 0) | 0) + 4 | 0;\n      $80 = +HEAPF32[$79 >> 2];\n      $81 = $80 * $13;\n      $82 = $78 + $81;\n      $83 = $75 * $82;\n      $109 = $83;\n    } else {\n      $109 = 0.0;\n    }\n\n    $84 = $67 > 0.0;\n\n    if ($84) {\n      $85 = $67 * $67;\n      $86 = $67 * $85;\n      $87 = $67 * $86;\n      $88 = 528 + ($49 * 12 | 0) | 0;\n      $89 = +HEAPF32[$88 >> 2];\n      $90 = $89 * $24;\n      $91 = (528 + ($49 * 12 | 0) | 0) + 4 | 0;\n      $92 = +HEAPF32[$91 >> 2];\n      $93 = $92 * $27;\n      $94 = $90 + $93;\n      $95 = $87 * $94;\n      $110 = $95;\n    } else {\n      $110 = 0.0;\n    }\n\n    $96 = $71 > 0.0;\n\n    if (!$96) {\n      $112 = 0.0;\n      $108 = $109 + $110;\n      $111 = $108 + $112;\n      $113 = $111 * 70.0;\n      return +$113;\n    }\n\n    $97 = $71 * $71;\n    $98 = $71 * $97;\n    $99 = $71 * $98;\n    $100 = 528 + ($59 * 12 | 0) | 0;\n    $101 = +HEAPF32[$100 >> 2];\n    $102 = $101 * $19;\n    $103 = (528 + ($59 * 12 | 0) | 0) + 4 | 0;\n    $104 = +HEAPF32[$103 >> 2];\n    $105 = $104 * $21;\n    $106 = $102 + $105;\n    $107 = $99 * $106;\n    $112 = $107;\n    $108 = $109 + $110;\n    $111 = $108 + $112;\n    $113 = $111 * 70.0;\n    return +$113;\n  }\n\n  function _noise3($0, $1, $2) {\n    $0 = +$0;\n    $1 = +$1;\n    $2 = +$2;\n    var $$phi$trans$insert = 0,\n        $$pre = 0.0,\n        $10 = 0.0,\n        $100 = 0,\n        $101 = 0,\n        $102 = 0,\n        $103 = 0,\n        $104 = 0,\n        $105 = 0,\n        $106 = 0,\n        $107 = 0,\n        $108 = 0,\n        $109 = 0,\n        $11 = 0.0,\n        $110 = 0,\n        $111 = 0,\n        $112 = 0,\n        $113 = 0,\n        $114 = 0,\n        $115 = 0;\n    var $116 = 0,\n        $117 = 0,\n        $118 = 0,\n        $119 = 0,\n        $12 = 0.0,\n        $120 = 0,\n        $121 = 0,\n        $122 = 0,\n        $123 = 0,\n        $124 = 0,\n        $125 = 0,\n        $126 = 0,\n        $127 = 0,\n        $128 = 0,\n        $129 = 0,\n        $13 = 0.0,\n        $130 = 0,\n        $131 = 0,\n        $132 = 0.0,\n        $133 = 0.0;\n    var $134 = 0.0,\n        $135 = 0.0,\n        $136 = 0.0,\n        $137 = 0.0,\n        $138 = 0.0,\n        $139 = 0.0,\n        $14 = 0.0,\n        $140 = 0.0,\n        $141 = 0.0,\n        $142 = 0.0,\n        $143 = 0.0,\n        $144 = 0.0,\n        $145 = 0.0,\n        $146 = 0.0,\n        $147 = 0.0,\n        $148 = 0.0,\n        $149 = 0.0,\n        $15 = 0.0,\n        $150 = 0.0,\n        $151 = 0.0;\n    var $152 = 0.0,\n        $153 = 0.0,\n        $154 = 0.0,\n        $155 = 0.0,\n        $156 = 0.0,\n        $157 = 0.0,\n        $158 = 0.0,\n        $159 = 0.0,\n        $16 = 0.0,\n        $160 = 0.0,\n        $161 = 0.0,\n        $162 = 0.0,\n        $163 = 0.0,\n        $164 = 0.0,\n        $165 = 0.0,\n        $166 = 0.0,\n        $167 = 0,\n        $168 = 0.0,\n        $169 = 0.0,\n        $17 = 0.0;\n    var $170 = 0.0,\n        $171 = 0,\n        $172 = 0.0,\n        $173 = 0.0,\n        $174 = 0,\n        $175 = 0.0,\n        $176 = 0.0,\n        $177 = 0.0,\n        $178 = 0,\n        $179 = 0.0,\n        $18 = 0.0,\n        $180 = 0.0,\n        $181 = 0.0,\n        $182 = 0.0,\n        $183 = 0,\n        $184 = 0.0,\n        $185 = 0.0,\n        $186 = 0.0,\n        $187 = 0,\n        $188 = 0.0;\n    var $189 = 0.0,\n        $19 = 0.0,\n        $190 = 0,\n        $191 = 0.0,\n        $192 = 0.0,\n        $193 = 0.0,\n        $194 = 0.0,\n        $195 = 0,\n        $196 = 0.0,\n        $197 = 0.0,\n        $198 = 0.0,\n        $199 = 0.0,\n        $20 = 0.0,\n        $200 = 0,\n        $201 = 0,\n        $202 = 0.0,\n        $203 = 0.0,\n        $204 = 0.0,\n        $205 = 0,\n        $206 = 0.0;\n    var $207 = 0.0,\n        $208 = 0,\n        $209 = 0.0,\n        $21 = 0,\n        $210 = 0.0,\n        $211 = 0.0,\n        $212 = 0,\n        $213 = 0.0,\n        $214 = 0.0,\n        $215 = 0.0,\n        $216 = 0.0,\n        $217 = 0,\n        $218 = 0,\n        $219 = 0.0,\n        $22 = 0.0,\n        $220 = 0.0,\n        $221 = 0.0,\n        $222 = 0,\n        $223 = 0.0,\n        $224 = 0.0;\n    var $225 = 0,\n        $226 = 0.0,\n        $227 = 0.0,\n        $228 = 0.0,\n        $229 = 0,\n        $23 = 0.0,\n        $230 = 0.0,\n        $231 = 0.0,\n        $232 = 0.0,\n        $233 = 0.0,\n        $234 = 0,\n        $235 = 0.0,\n        $236 = 0,\n        $237 = 0.0,\n        $238 = 0.0,\n        $239 = 0,\n        $24 = 0,\n        $240 = 0.0,\n        $241 = 0.0,\n        $242 = 0.0;\n    var $243 = 0.0,\n        $244 = 0.0,\n        $25 = 0,\n        $26 = 0,\n        $27 = 0,\n        $28 = 0,\n        $29 = 0,\n        $3 = 0,\n        $30 = 0.0,\n        $31 = 0.0,\n        $32 = 0,\n        $33 = 0.0,\n        $34 = 0,\n        $35 = 0.0,\n        $36 = 0.0,\n        $37 = 0,\n        $38 = 0.0,\n        $39 = 0,\n        $4 = 0,\n        $40 = 0.0;\n    var $41 = 0.0,\n        $42 = 0,\n        $43 = 0.0,\n        $44 = 0.0,\n        $45 = 0,\n        $46 = 0.0,\n        $47 = 0,\n        $48 = 0.0,\n        $49 = 0.0,\n        $5 = 0.0,\n        $50 = 0,\n        $51 = 0.0,\n        $52 = 0,\n        $53 = 0.0,\n        $54 = 0.0,\n        $55 = 0,\n        $56 = 0.0,\n        $57 = 0.0,\n        $58 = 0,\n        $59 = 0.0;\n    var $6 = 0.0,\n        $60 = 0,\n        $61 = 0.0,\n        $62 = 0.0,\n        $63 = 0,\n        $64 = 0.0,\n        $65 = 0,\n        $66 = 0.0,\n        $67 = 0.0,\n        $68 = 0,\n        $69 = 0,\n        $7 = 0.0,\n        $70 = 0,\n        $71 = 0,\n        $72 = 0,\n        $73 = 0,\n        $74 = 0,\n        $75 = 0,\n        $76 = 0,\n        $77 = 0;\n    var $78 = 0,\n        $79 = 0,\n        $8 = 0.0,\n        $80 = 0,\n        $81 = 0,\n        $82 = 0,\n        $83 = 0,\n        $84 = 0,\n        $85 = 0,\n        $86 = 0,\n        $87 = 0,\n        $88 = 0,\n        $89 = 0,\n        $9 = 0.0,\n        $90 = 0,\n        $91 = 0,\n        $92 = 0,\n        $93 = 0,\n        $94 = 0,\n        $95 = 0;\n    var $96 = 0,\n        $97 = 0,\n        $98 = 0,\n        $99 = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    STACKTOP = STACKTOP + 64 | 0;\n    if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);\n    $3 = sp + 48 | 0;\n    $4 = sp;\n    ;\n    HEAP32[$3 >> 2] = 0 | 0;\n    HEAP32[$3 + 4 >> 2] = 0 | 0;\n    HEAP32[$3 + 8 >> 2] = 0 | 0;\n    HEAP32[$3 + 12 >> 2] = 0 | 0;\n    $5 = $0 + $1;\n    $6 = $5 + $2;\n    $7 = $6 * 0.3333333432674408;\n    $8 = $7 + $0;\n    $9 = +Math_floor(+$8);\n    $10 = $7 + $1;\n    $11 = +Math_floor(+$10);\n    $12 = $7 + $2;\n    $13 = +Math_floor(+$12);\n    $14 = $9 + $11;\n    $15 = $13 + $14;\n    $16 = $15 * 0.1666666716337204;\n    $17 = $9 - $16;\n    $18 = $0 - $17;\n    HEAPF32[$4 >> 2] = $18;\n    $19 = $11 - $16;\n    $20 = $1 - $19;\n    $21 = $4 + 4 | 0;\n    HEAPF32[$21 >> 2] = $20;\n    $22 = $13 - $16;\n    $23 = $2 - $22;\n    $24 = $4 + 8 | 0;\n    HEAPF32[$24 >> 2] = $23;\n    $25 = !($18 >= $20);\n\n    if ($25) {\n      $28 = $20 < $23;\n\n      if ($28) {\n        $34 = 0;\n        $39 = 0;\n        $47 = 1;\n        $52 = 0;\n        $60 = 1;\n        $65 = 1;\n      } else {\n        $29 = $18 < $23;\n\n        if ($29) {\n          $34 = 0;\n          $39 = 0;\n          $47 = 1;\n          $52 = 1;\n          $60 = 1;\n          $65 = 0;\n        } else {\n          $34 = 1;\n          $39 = 0;\n          $47 = 1;\n          $52 = 1;\n          $60 = 0;\n          $65 = 0;\n        }\n      }\n    } else {\n      $26 = !($20 >= $23);\n\n      if ($26) {\n        $27 = !($18 >= $23);\n\n        if ($27) {\n          $34 = 1;\n          $39 = 0;\n          $47 = 0;\n          $52 = 0;\n          $60 = 1;\n          $65 = 1;\n        } else {\n          $34 = 1;\n          $39 = 1;\n          $47 = 0;\n          $52 = 0;\n          $60 = 1;\n          $65 = 0;\n        }\n      } else {\n        $34 = 1;\n        $39 = 1;\n        $47 = 1;\n        $52 = 0;\n        $60 = 0;\n        $65 = 0;\n      }\n    }\n\n    $30 = $18 + -1.0;\n    $31 = $30 + 0.5;\n    $32 = $4 + 36 | 0;\n    HEAPF32[$32 >> 2] = $31;\n    $33 = +($34 | 0);\n    $35 = $18 - $33;\n    $36 = $35 + 0.3333333432674408;\n    $37 = $4 + 24 | 0;\n    HEAPF32[$37 >> 2] = $36;\n    $38 = +($39 | 0);\n    $40 = $18 - $38;\n    $41 = $40 + 0.1666666716337204;\n    $42 = $4 + 12 | 0;\n    HEAPF32[$42 >> 2] = $41;\n    $43 = $20 + -1.0;\n    $44 = $43 + 0.5;\n    $45 = $4 + 40 | 0;\n    HEAPF32[$45 >> 2] = $44;\n    $46 = +($47 | 0);\n    $48 = $20 - $46;\n    $49 = $48 + 0.3333333432674408;\n    $50 = $4 + 28 | 0;\n    HEAPF32[$50 >> 2] = $49;\n    $51 = +($52 | 0);\n    $53 = $20 - $51;\n    $54 = $53 + 0.1666666716337204;\n    $55 = $4 + 16 | 0;\n    HEAPF32[$55 >> 2] = $54;\n    $56 = $23 + -1.0;\n    $57 = $56 + 0.5;\n    $58 = $4 + 44 | 0;\n    HEAPF32[$58 >> 2] = $57;\n    $59 = +($60 | 0);\n    $61 = $23 - $59;\n    $62 = $61 + 0.3333333432674408;\n    $63 = $4 + 32 | 0;\n    HEAPF32[$63 >> 2] = $62;\n    $64 = +($65 | 0);\n    $66 = $23 - $64;\n    $67 = $66 + 0.1666666716337204;\n    $68 = $4 + 20 | 0;\n    HEAPF32[$68 >> 2] = $67;\n    $69 = ~~$9;\n    $70 = $69 & 255;\n    $71 = ~~$11;\n    $72 = $71 & 255;\n    $73 = ~~$13;\n    $74 = $73 & 255;\n    $75 = 16 + $74 | 0;\n    $76 = HEAP8[$75 >> 0] | 0;\n    $77 = $76 & 255;\n    $78 = $72 + $77 | 0;\n    $79 = 16 + $78 | 0;\n    $80 = HEAP8[$79 >> 0] | 0;\n    $81 = $80 & 255;\n    $82 = $70 + $81 | 0;\n    $83 = 16 + $82 | 0;\n    $84 = HEAP8[$83 >> 0] | 0;\n    $85 = ($84 & 255) % 12 & -1;\n    $86 = $85 & 255;\n    $87 = $39 + $70 | 0;\n    $88 = $52 + $72 | 0;\n    $89 = $65 + $74 | 0;\n    $90 = 16 + $89 | 0;\n    $91 = HEAP8[$90 >> 0] | 0;\n    $92 = $91 & 255;\n    $93 = $88 + $92 | 0;\n    $94 = 16 + $93 | 0;\n    $95 = HEAP8[$94 >> 0] | 0;\n    $96 = $95 & 255;\n    $97 = $87 + $96 | 0;\n    $98 = 16 + $97 | 0;\n    $99 = HEAP8[$98 >> 0] | 0;\n    $100 = ($99 & 255) % 12 & -1;\n    $101 = $100 & 255;\n    $102 = $34 + $70 | 0;\n    $103 = $47 + $72 | 0;\n    $104 = $60 + $74 | 0;\n    $105 = 16 + $104 | 0;\n    $106 = HEAP8[$105 >> 0] | 0;\n    $107 = $106 & 255;\n    $108 = $103 + $107 | 0;\n    $109 = 16 + $108 | 0;\n    $110 = HEAP8[$109 >> 0] | 0;\n    $111 = $110 & 255;\n    $112 = $102 + $111 | 0;\n    $113 = 16 + $112 | 0;\n    $114 = HEAP8[$113 >> 0] | 0;\n    $115 = ($114 & 255) % 12 & -1;\n    $116 = $115 & 255;\n    $117 = $70 + 1 | 0;\n    $118 = $72 + 1 | 0;\n    $119 = $74 + 1 | 0;\n    $120 = 16 + $119 | 0;\n    $121 = HEAP8[$120 >> 0] | 0;\n    $122 = $121 & 255;\n    $123 = $118 + $122 | 0;\n    $124 = 16 + $123 | 0;\n    $125 = HEAP8[$124 >> 0] | 0;\n    $126 = $125 & 255;\n    $127 = $117 + $126 | 0;\n    $128 = 16 + $127 | 0;\n    $129 = HEAP8[$128 >> 0] | 0;\n    $130 = ($129 & 255) % 12 & -1;\n    $131 = $130 & 255;\n    $132 = +HEAPF32[$4 >> 2];\n    $133 = $132 * $132;\n    $134 = 0.60000002384185791 - $133;\n    $135 = +HEAPF32[$21 >> 2];\n    $136 = $135 * $135;\n    $137 = $134 - $136;\n    $138 = +HEAPF32[$24 >> 2];\n    $139 = $138 * $138;\n    $140 = $137 - $139;\n    $141 = +HEAPF32[$42 >> 2];\n    $142 = $141 * $141;\n    $143 = 0.60000002384185791 - $142;\n    $144 = +HEAPF32[$55 >> 2];\n    $145 = $144 * $144;\n    $146 = $143 - $145;\n    $147 = $67 * $67;\n    $148 = $146 - $147;\n    $149 = +HEAPF32[$37 >> 2];\n    $150 = $149 * $149;\n    $151 = 0.60000002384185791 - $150;\n    $152 = +HEAPF32[$50 >> 2];\n    $153 = $152 * $152;\n    $154 = $151 - $153;\n    $155 = +HEAPF32[$63 >> 2];\n    $156 = $155 * $155;\n    $157 = $154 - $156;\n    $158 = +HEAPF32[$32 >> 2];\n    $159 = $158 * $158;\n    $160 = 0.60000002384185791 - $159;\n    $161 = +HEAPF32[$45 >> 2];\n    $162 = $161 * $161;\n    $163 = $160 - $162;\n    $164 = +HEAPF32[$58 >> 2];\n    $165 = $164 * $164;\n    $166 = $163 - $165;\n    $167 = $140 > 0.0;\n\n    if ($167) {\n      $168 = $140 * $140;\n      $169 = $140 * $168;\n      $170 = $140 * $169;\n      $171 = 528 + ($86 * 12 | 0) | 0;\n      $172 = +HEAPF32[$171 >> 2];\n      $173 = $132 * $172;\n      $174 = (528 + ($86 * 12 | 0) | 0) + 4 | 0;\n      $175 = +HEAPF32[$174 >> 2];\n      $176 = $135 * $175;\n      $177 = $173 + $176;\n      $178 = (528 + ($86 * 12 | 0) | 0) + 8 | 0;\n      $179 = +HEAPF32[$178 >> 2];\n      $180 = $138 * $179;\n      $181 = $177 + $180;\n      $182 = $170 * $181;\n      HEAPF32[$3 >> 2] = $182;\n    }\n\n    $183 = $148 > 0.0;\n\n    if ($183) {\n      $184 = $148 * $148;\n      $185 = $148 * $184;\n      $186 = $148 * $185;\n      $187 = 528 + ($101 * 12 | 0) | 0;\n      $188 = +HEAPF32[$187 >> 2];\n      $189 = $141 * $188;\n      $190 = (528 + ($101 * 12 | 0) | 0) + 4 | 0;\n      $191 = +HEAPF32[$190 >> 2];\n      $192 = $144 * $191;\n      $193 = $189 + $192;\n      $194 = +HEAPF32[$68 >> 2];\n      $195 = (528 + ($101 * 12 | 0) | 0) + 8 | 0;\n      $196 = +HEAPF32[$195 >> 2];\n      $197 = $194 * $196;\n      $198 = $193 + $197;\n      $199 = $186 * $198;\n      $200 = $3 + 4 | 0;\n      HEAPF32[$200 >> 2] = $199;\n    }\n\n    $201 = $157 > 0.0;\n\n    if ($201) {\n      $202 = $157 * $157;\n      $203 = $157 * $202;\n      $204 = $157 * $203;\n      $205 = 528 + ($116 * 12 | 0) | 0;\n      $206 = +HEAPF32[$205 >> 2];\n      $207 = $149 * $206;\n      $208 = (528 + ($116 * 12 | 0) | 0) + 4 | 0;\n      $209 = +HEAPF32[$208 >> 2];\n      $210 = $152 * $209;\n      $211 = $207 + $210;\n      $212 = (528 + ($116 * 12 | 0) | 0) + 8 | 0;\n      $213 = +HEAPF32[$212 >> 2];\n      $214 = $155 * $213;\n      $215 = $211 + $214;\n      $216 = $204 * $215;\n      $217 = $3 + 8 | 0;\n      HEAPF32[$217 >> 2] = $216;\n    }\n\n    $218 = $166 > 0.0;\n\n    if ($218) {\n      $219 = $166 * $166;\n      $220 = $166 * $219;\n      $221 = $166 * $220;\n      $222 = 528 + ($131 * 12 | 0) | 0;\n      $223 = +HEAPF32[$222 >> 2];\n      $224 = $158 * $223;\n      $225 = (528 + ($131 * 12 | 0) | 0) + 4 | 0;\n      $226 = +HEAPF32[$225 >> 2];\n      $227 = $161 * $226;\n      $228 = $224 + $227;\n      $229 = (528 + ($131 * 12 | 0) | 0) + 8 | 0;\n      $230 = +HEAPF32[$229 >> 2];\n      $231 = $164 * $230;\n      $232 = $228 + $231;\n      $233 = $221 * $232;\n      $234 = $3 + 12 | 0;\n      HEAPF32[$234 >> 2] = $233;\n      $243 = $233;\n      $235 = +HEAPF32[$3 >> 2];\n      $236 = $3 + 4 | 0;\n      $237 = +HEAPF32[$236 >> 2];\n      $238 = $235 + $237;\n      $239 = $3 + 8 | 0;\n      $240 = +HEAPF32[$239 >> 2];\n      $241 = $238 + $240;\n      $242 = $241 + $243;\n      $244 = $242 * 32.0;\n      STACKTOP = sp;\n      return +$244;\n    } else {\n      $$phi$trans$insert = $3 + 12 | 0;\n      $$pre = +HEAPF32[$$phi$trans$insert >> 2];\n      $243 = $$pre;\n      $235 = +HEAPF32[$3 >> 2];\n      $236 = $3 + 4 | 0;\n      $237 = +HEAPF32[$236 >> 2];\n      $238 = $235 + $237;\n      $239 = $3 + 8 | 0;\n      $240 = +HEAPF32[$239 >> 2];\n      $241 = $238 + $240;\n      $242 = $241 + $243;\n      $244 = $242 * 32.0;\n      STACKTOP = sp;\n      return +$244;\n    }\n\n    return +0.0;\n  }\n\n  function _simplex2($0, $1, $2, $3, $4) {\n    $0 = +$0;\n    $1 = +$1;\n    $2 = $2 | 0;\n    $3 = +$3;\n    $4 = +$4;\n    var $$027$lcssa = 0.0,\n        $$02734 = 0.0,\n        $$028$lcssa = 0.0,\n        $$02833 = 0.0,\n        $$02932 = 0.0,\n        $$03031 = 0.0,\n        $$035 = 0,\n        $10 = 0.0,\n        $11 = 0.0,\n        $12 = 0.0,\n        $13 = 0.0,\n        $14 = 0.0,\n        $15 = 0,\n        $16 = 0.0,\n        $17 = 0.0,\n        $18 = 0.0,\n        $5 = 0.0,\n        $6 = 0,\n        $7 = 0.0,\n        $8 = 0.0;\n    var $9 = 0.0,\n        $exitcond = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    $5 = +_noise2($0, $1);\n    $6 = ($2 | 0) > 1;\n\n    if ($6) {\n      $$02734 = $5;\n      $$02833 = 1.0;\n      $$02932 = 1.0;\n      $$03031 = 1.0;\n      $$035 = 1;\n\n      while (1) {\n        $7 = $$03031 * $4;\n        $8 = $$02932 * $3;\n        $9 = $$02833 + $8;\n        $10 = $7 * $0;\n        $11 = $7 * $1;\n        $12 = +_noise2($10, $11);\n        $13 = $8 * $12;\n        $14 = $$02734 + $13;\n        $15 = $$035 + 1 | 0;\n        $exitcond = ($15 | 0) == ($2 | 0);\n\n        if ($exitcond) {\n          $$027$lcssa = $14;\n          $$028$lcssa = $9;\n          break;\n        } else {\n          $$02734 = $14;\n          $$02833 = $9;\n          $$02932 = $8;\n          $$03031 = $7;\n          $$035 = $15;\n        }\n      }\n    } else {\n      $$027$lcssa = $5;\n      $$028$lcssa = 1.0;\n    }\n\n    $16 = $$027$lcssa / $$028$lcssa;\n    $17 = $16 + 1.0;\n    $18 = $17 * 0.5;\n    return +$18;\n  }\n\n  function _simplex3($0, $1, $2, $3, $4, $5) {\n    $0 = +$0;\n    $1 = +$1;\n    $2 = +$2;\n    $3 = $3 | 0;\n    $4 = +$4;\n    $5 = +$5;\n    var $$030$lcssa = 0.0,\n        $$03037 = 0.0,\n        $$031$lcssa = 0.0,\n        $$03136 = 0.0,\n        $$03235 = 0.0,\n        $$03334 = 0.0,\n        $$038 = 0,\n        $10 = 0.0,\n        $11 = 0.0,\n        $12 = 0.0,\n        $13 = 0.0,\n        $14 = 0.0,\n        $15 = 0.0,\n        $16 = 0.0,\n        $17 = 0,\n        $18 = 0.0,\n        $19 = 0.0,\n        $20 = 0.0,\n        $6 = 0.0,\n        $7 = 0;\n    var $8 = 0.0,\n        $9 = 0.0,\n        $exitcond = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    $6 = +_noise3($0, $1, $2);\n    $7 = ($3 | 0) > 1;\n\n    if ($7) {\n      $$03037 = $6;\n      $$03136 = 1.0;\n      $$03235 = 1.0;\n      $$03334 = 1.0;\n      $$038 = 1;\n\n      while (1) {\n        $8 = $$03334 * $5;\n        $9 = $$03235 * $4;\n        $10 = $$03136 + $9;\n        $11 = $8 * $0;\n        $12 = $8 * $1;\n        $13 = $8 * $2;\n        $14 = +_noise3($11, $12, $13);\n        $15 = $9 * $14;\n        $16 = $$03037 + $15;\n        $17 = $$038 + 1 | 0;\n        $exitcond = ($17 | 0) == ($3 | 0);\n\n        if ($exitcond) {\n          $$030$lcssa = $16;\n          $$031$lcssa = $10;\n          break;\n        } else {\n          $$03037 = $16;\n          $$03136 = $10;\n          $$03235 = $9;\n          $$03334 = $8;\n          $$038 = $17;\n        }\n      }\n    } else {\n      $$030$lcssa = $6;\n      $$031$lcssa = 1.0;\n    }\n\n    $18 = $$030$lcssa / $$031$lcssa;\n    $19 = $18 + 1.0;\n    $20 = $19 * 0.5;\n    return +$20;\n  }\n\n  function _malloc($0) {\n    $0 = $0 | 0;\n    var $$0 = 0,\n        $$0$i$i = 0,\n        $$0$i$i$i = 0,\n        $$0$i16$i = 0,\n        $$0187$i = 0,\n        $$0189$i = 0,\n        $$0190$i = 0,\n        $$0191$i = 0,\n        $$0197 = 0,\n        $$0199 = 0,\n        $$02065$i$i = 0,\n        $$0207$lcssa$i$i = 0,\n        $$02074$i$i = 0,\n        $$0211$i$i = 0,\n        $$0212$i$i = 0,\n        $$024372$i = 0,\n        $$0286$i$i = 0,\n        $$028711$i$i = 0,\n        $$0288$lcssa$i$i = 0,\n        $$028810$i$i = 0;\n    var $$0294$i$i = 0,\n        $$0295$i$i = 0,\n        $$0340$i = 0,\n        $$034217$i = 0,\n        $$0343$lcssa$i = 0,\n        $$034316$i = 0,\n        $$0345$i = 0,\n        $$0351$i = 0,\n        $$0357$i = 0,\n        $$0358$i = 0,\n        $$0360$i = 0,\n        $$0361$i = 0,\n        $$0367$i = 0,\n        $$1194$i = 0,\n        $$1194$i$be = 0,\n        $$1194$i$ph = 0,\n        $$1196$i = 0,\n        $$1196$i$be = 0,\n        $$1196$i$ph = 0,\n        $$124471$i = 0;\n    var $$1290$i$i = 0,\n        $$1290$i$i$be = 0,\n        $$1290$i$i$ph = 0,\n        $$1292$i$i = 0,\n        $$1292$i$i$be = 0,\n        $$1292$i$i$ph = 0,\n        $$1341$i = 0,\n        $$1346$i = 0,\n        $$1362$i = 0,\n        $$1369$i = 0,\n        $$1369$i$be = 0,\n        $$1369$i$ph = 0,\n        $$1373$i = 0,\n        $$1373$i$be = 0,\n        $$1373$i$ph = 0,\n        $$2234243136$i = 0,\n        $$2247$ph$i = 0,\n        $$2253$ph$i = 0,\n        $$2353$i = 0,\n        $$3$i = 0;\n    var $$3$i$i = 0,\n        $$3$i203 = 0,\n        $$3$i203218 = 0,\n        $$3348$i = 0,\n        $$3371$i = 0,\n        $$4$lcssa$i = 0,\n        $$420$i = 0,\n        $$420$i$ph = 0,\n        $$4236$i = 0,\n        $$4349$lcssa$i = 0,\n        $$434919$i = 0,\n        $$434919$i$ph = 0,\n        $$4355$i = 0,\n        $$535618$i = 0,\n        $$535618$i$ph = 0,\n        $$723947$i = 0,\n        $$748$i = 0,\n        $$pre = 0,\n        $$pre$i = 0,\n        $$pre$i$i = 0;\n    var $$pre$i17$i = 0,\n        $$pre$i208 = 0,\n        $$pre$i210 = 0,\n        $$pre$phi$i$iZ2D = 0,\n        $$pre$phi$i18$iZ2D = 0,\n        $$pre$phi$i209Z2D = 0,\n        $$pre$phi$iZ2D = 0,\n        $$pre$phi17$i$iZ2D = 0,\n        $$pre$phiZ2D = 0,\n        $$pre16$i$i = 0,\n        $$sink = 0,\n        $$sink325 = 0,\n        $$sink326 = 0,\n        $1 = 0,\n        $10 = 0,\n        $100 = 0,\n        $1000 = 0,\n        $1001 = 0,\n        $1002 = 0,\n        $1003 = 0;\n    var $1004 = 0,\n        $1005 = 0,\n        $1006 = 0,\n        $1007 = 0,\n        $1008 = 0,\n        $1009 = 0,\n        $101 = 0,\n        $1010 = 0,\n        $1011 = 0,\n        $1012 = 0,\n        $1013 = 0,\n        $1014 = 0,\n        $1015 = 0,\n        $1016 = 0,\n        $1017 = 0,\n        $1018 = 0,\n        $1019 = 0,\n        $102 = 0,\n        $1020 = 0,\n        $1021 = 0;\n    var $1022 = 0,\n        $1023 = 0,\n        $1024 = 0,\n        $1025 = 0,\n        $1026 = 0,\n        $1027 = 0,\n        $1028 = 0,\n        $1029 = 0,\n        $103 = 0,\n        $1030 = 0,\n        $1031 = 0,\n        $1032 = 0,\n        $1033 = 0,\n        $1034 = 0,\n        $1035 = 0,\n        $1036 = 0,\n        $1037 = 0,\n        $1038 = 0,\n        $1039 = 0,\n        $104 = 0;\n    var $1040 = 0,\n        $1041 = 0,\n        $1042 = 0,\n        $1043 = 0,\n        $1044 = 0,\n        $1045 = 0,\n        $1046 = 0,\n        $1047 = 0,\n        $1048 = 0,\n        $1049 = 0,\n        $105 = 0,\n        $1050 = 0,\n        $1051 = 0,\n        $1052 = 0,\n        $1053 = 0,\n        $1054 = 0,\n        $1055 = 0,\n        $1056 = 0,\n        $1057 = 0,\n        $1058 = 0;\n    var $1059 = 0,\n        $106 = 0,\n        $1060 = 0,\n        $1061 = 0,\n        $1062 = 0,\n        $1063 = 0,\n        $1064 = 0,\n        $1065 = 0,\n        $1066 = 0,\n        $1067 = 0,\n        $1068 = 0,\n        $1069 = 0,\n        $107 = 0,\n        $1070 = 0,\n        $108 = 0,\n        $109 = 0,\n        $11 = 0,\n        $110 = 0,\n        $111 = 0,\n        $112 = 0;\n    var $113 = 0,\n        $114 = 0,\n        $115 = 0,\n        $116 = 0,\n        $117 = 0,\n        $118 = 0,\n        $119 = 0,\n        $12 = 0,\n        $120 = 0,\n        $121 = 0,\n        $122 = 0,\n        $123 = 0,\n        $124 = 0,\n        $125 = 0,\n        $126 = 0,\n        $127 = 0,\n        $128 = 0,\n        $129 = 0,\n        $13 = 0,\n        $130 = 0;\n    var $131 = 0,\n        $132 = 0,\n        $133 = 0,\n        $134 = 0,\n        $135 = 0,\n        $136 = 0,\n        $137 = 0,\n        $138 = 0,\n        $139 = 0,\n        $14 = 0,\n        $140 = 0,\n        $141 = 0,\n        $142 = 0,\n        $143 = 0,\n        $144 = 0,\n        $145 = 0,\n        $146 = 0,\n        $147 = 0,\n        $148 = 0,\n        $149 = 0;\n    var $15 = 0,\n        $150 = 0,\n        $151 = 0,\n        $152 = 0,\n        $153 = 0,\n        $154 = 0,\n        $155 = 0,\n        $156 = 0,\n        $157 = 0,\n        $158 = 0,\n        $159 = 0,\n        $16 = 0,\n        $160 = 0,\n        $161 = 0,\n        $162 = 0,\n        $163 = 0,\n        $164 = 0,\n        $165 = 0,\n        $166 = 0,\n        $167 = 0;\n    var $168 = 0,\n        $169 = 0,\n        $17 = 0,\n        $170 = 0,\n        $171 = 0,\n        $172 = 0,\n        $173 = 0,\n        $174 = 0,\n        $175 = 0,\n        $176 = 0,\n        $177 = 0,\n        $178 = 0,\n        $179 = 0,\n        $18 = 0,\n        $180 = 0,\n        $181 = 0,\n        $182 = 0,\n        $183 = 0,\n        $184 = 0,\n        $185 = 0;\n    var $186 = 0,\n        $187 = 0,\n        $188 = 0,\n        $189 = 0,\n        $19 = 0,\n        $190 = 0,\n        $191 = 0,\n        $192 = 0,\n        $193 = 0,\n        $194 = 0,\n        $195 = 0,\n        $196 = 0,\n        $197 = 0,\n        $198 = 0,\n        $199 = 0,\n        $2 = 0,\n        $20 = 0,\n        $200 = 0,\n        $201 = 0,\n        $202 = 0;\n    var $203 = 0,\n        $204 = 0,\n        $205 = 0,\n        $206 = 0,\n        $207 = 0,\n        $208 = 0,\n        $209 = 0,\n        $21 = 0,\n        $210 = 0,\n        $211 = 0,\n        $212 = 0,\n        $213 = 0,\n        $214 = 0,\n        $215 = 0,\n        $216 = 0,\n        $217 = 0,\n        $218 = 0,\n        $219 = 0,\n        $22 = 0,\n        $220 = 0;\n    var $221 = 0,\n        $222 = 0,\n        $223 = 0,\n        $224 = 0,\n        $225 = 0,\n        $226 = 0,\n        $227 = 0,\n        $228 = 0,\n        $229 = 0,\n        $23 = 0,\n        $230 = 0,\n        $231 = 0,\n        $232 = 0,\n        $233 = 0,\n        $234 = 0,\n        $235 = 0,\n        $236 = 0,\n        $237 = 0,\n        $238 = 0,\n        $239 = 0;\n    var $24 = 0,\n        $240 = 0,\n        $241 = 0,\n        $242 = 0,\n        $243 = 0,\n        $244 = 0,\n        $245 = 0,\n        $246 = 0,\n        $247 = 0,\n        $248 = 0,\n        $249 = 0,\n        $25 = 0,\n        $250 = 0,\n        $251 = 0,\n        $252 = 0,\n        $253 = 0,\n        $254 = 0,\n        $255 = 0,\n        $256 = 0,\n        $257 = 0;\n    var $258 = 0,\n        $259 = 0,\n        $26 = 0,\n        $260 = 0,\n        $261 = 0,\n        $262 = 0,\n        $263 = 0,\n        $264 = 0,\n        $265 = 0,\n        $266 = 0,\n        $267 = 0,\n        $268 = 0,\n        $269 = 0,\n        $27 = 0,\n        $270 = 0,\n        $271 = 0,\n        $272 = 0,\n        $273 = 0,\n        $274 = 0,\n        $275 = 0;\n    var $276 = 0,\n        $277 = 0,\n        $278 = 0,\n        $279 = 0,\n        $28 = 0,\n        $280 = 0,\n        $281 = 0,\n        $282 = 0,\n        $283 = 0,\n        $284 = 0,\n        $285 = 0,\n        $286 = 0,\n        $287 = 0,\n        $288 = 0,\n        $289 = 0,\n        $29 = 0,\n        $290 = 0,\n        $291 = 0,\n        $292 = 0,\n        $293 = 0;\n    var $294 = 0,\n        $295 = 0,\n        $296 = 0,\n        $297 = 0,\n        $298 = 0,\n        $299 = 0,\n        $3 = 0,\n        $30 = 0,\n        $300 = 0,\n        $301 = 0,\n        $302 = 0,\n        $303 = 0,\n        $304 = 0,\n        $305 = 0,\n        $306 = 0,\n        $307 = 0,\n        $308 = 0,\n        $309 = 0,\n        $31 = 0,\n        $310 = 0;\n    var $311 = 0,\n        $312 = 0,\n        $313 = 0,\n        $314 = 0,\n        $315 = 0,\n        $316 = 0,\n        $317 = 0,\n        $318 = 0,\n        $319 = 0,\n        $32 = 0,\n        $320 = 0,\n        $321 = 0,\n        $322 = 0,\n        $323 = 0,\n        $324 = 0,\n        $325 = 0,\n        $326 = 0,\n        $327 = 0,\n        $328 = 0,\n        $329 = 0;\n    var $33 = 0,\n        $330 = 0,\n        $331 = 0,\n        $332 = 0,\n        $333 = 0,\n        $334 = 0,\n        $335 = 0,\n        $336 = 0,\n        $337 = 0,\n        $338 = 0,\n        $339 = 0,\n        $34 = 0,\n        $340 = 0,\n        $341 = 0,\n        $342 = 0,\n        $343 = 0,\n        $344 = 0,\n        $345 = 0,\n        $346 = 0,\n        $347 = 0;\n    var $348 = 0,\n        $349 = 0,\n        $35 = 0,\n        $350 = 0,\n        $351 = 0,\n        $352 = 0,\n        $353 = 0,\n        $354 = 0,\n        $355 = 0,\n        $356 = 0,\n        $357 = 0,\n        $358 = 0,\n        $359 = 0,\n        $36 = 0,\n        $360 = 0,\n        $361 = 0,\n        $362 = 0,\n        $363 = 0,\n        $364 = 0,\n        $365 = 0;\n    var $366 = 0,\n        $367 = 0,\n        $368 = 0,\n        $369 = 0,\n        $37 = 0,\n        $370 = 0,\n        $371 = 0,\n        $372 = 0,\n        $373 = 0,\n        $374 = 0,\n        $375 = 0,\n        $376 = 0,\n        $377 = 0,\n        $378 = 0,\n        $379 = 0,\n        $38 = 0,\n        $380 = 0,\n        $381 = 0,\n        $382 = 0,\n        $383 = 0;\n    var $384 = 0,\n        $385 = 0,\n        $386 = 0,\n        $387 = 0,\n        $388 = 0,\n        $389 = 0,\n        $39 = 0,\n        $390 = 0,\n        $391 = 0,\n        $392 = 0,\n        $393 = 0,\n        $394 = 0,\n        $395 = 0,\n        $396 = 0,\n        $397 = 0,\n        $398 = 0,\n        $399 = 0,\n        $4 = 0,\n        $40 = 0,\n        $400 = 0;\n    var $401 = 0,\n        $402 = 0,\n        $403 = 0,\n        $404 = 0,\n        $405 = 0,\n        $406 = 0,\n        $407 = 0,\n        $408 = 0,\n        $409 = 0,\n        $41 = 0,\n        $410 = 0,\n        $411 = 0,\n        $412 = 0,\n        $413 = 0,\n        $414 = 0,\n        $415 = 0,\n        $416 = 0,\n        $417 = 0,\n        $418 = 0,\n        $419 = 0;\n    var $42 = 0,\n        $420 = 0,\n        $421 = 0,\n        $422 = 0,\n        $423 = 0,\n        $424 = 0,\n        $425 = 0,\n        $426 = 0,\n        $427 = 0,\n        $428 = 0,\n        $429 = 0,\n        $43 = 0,\n        $430 = 0,\n        $431 = 0,\n        $432 = 0,\n        $433 = 0,\n        $434 = 0,\n        $435 = 0,\n        $436 = 0,\n        $437 = 0;\n    var $438 = 0,\n        $439 = 0,\n        $44 = 0,\n        $440 = 0,\n        $441 = 0,\n        $442 = 0,\n        $443 = 0,\n        $444 = 0,\n        $445 = 0,\n        $446 = 0,\n        $447 = 0,\n        $448 = 0,\n        $449 = 0,\n        $45 = 0,\n        $450 = 0,\n        $451 = 0,\n        $452 = 0,\n        $453 = 0,\n        $454 = 0,\n        $455 = 0;\n    var $456 = 0,\n        $457 = 0,\n        $458 = 0,\n        $459 = 0,\n        $46 = 0,\n        $460 = 0,\n        $461 = 0,\n        $462 = 0,\n        $463 = 0,\n        $464 = 0,\n        $465 = 0,\n        $466 = 0,\n        $467 = 0,\n        $468 = 0,\n        $469 = 0,\n        $47 = 0,\n        $470 = 0,\n        $471 = 0,\n        $472 = 0,\n        $473 = 0;\n    var $474 = 0,\n        $475 = 0,\n        $476 = 0,\n        $477 = 0,\n        $478 = 0,\n        $479 = 0,\n        $48 = 0,\n        $480 = 0,\n        $481 = 0,\n        $482 = 0,\n        $483 = 0,\n        $484 = 0,\n        $485 = 0,\n        $486 = 0,\n        $487 = 0,\n        $488 = 0,\n        $489 = 0,\n        $49 = 0,\n        $490 = 0,\n        $491 = 0;\n    var $492 = 0,\n        $493 = 0,\n        $494 = 0,\n        $495 = 0,\n        $496 = 0,\n        $497 = 0,\n        $498 = 0,\n        $499 = 0,\n        $5 = 0,\n        $50 = 0,\n        $500 = 0,\n        $501 = 0,\n        $502 = 0,\n        $503 = 0,\n        $504 = 0,\n        $505 = 0,\n        $506 = 0,\n        $507 = 0,\n        $508 = 0,\n        $509 = 0;\n    var $51 = 0,\n        $510 = 0,\n        $511 = 0,\n        $512 = 0,\n        $513 = 0,\n        $514 = 0,\n        $515 = 0,\n        $516 = 0,\n        $517 = 0,\n        $518 = 0,\n        $519 = 0,\n        $52 = 0,\n        $520 = 0,\n        $521 = 0,\n        $522 = 0,\n        $523 = 0,\n        $524 = 0,\n        $525 = 0,\n        $526 = 0,\n        $527 = 0;\n    var $528 = 0,\n        $529 = 0,\n        $53 = 0,\n        $530 = 0,\n        $531 = 0,\n        $532 = 0,\n        $533 = 0,\n        $534 = 0,\n        $535 = 0,\n        $536 = 0,\n        $537 = 0,\n        $538 = 0,\n        $539 = 0,\n        $54 = 0,\n        $540 = 0,\n        $541 = 0,\n        $542 = 0,\n        $543 = 0,\n        $544 = 0,\n        $545 = 0;\n    var $546 = 0,\n        $547 = 0,\n        $548 = 0,\n        $549 = 0,\n        $55 = 0,\n        $550 = 0,\n        $551 = 0,\n        $552 = 0,\n        $553 = 0,\n        $554 = 0,\n        $555 = 0,\n        $556 = 0,\n        $557 = 0,\n        $558 = 0,\n        $559 = 0,\n        $56 = 0,\n        $560 = 0,\n        $561 = 0,\n        $562 = 0,\n        $563 = 0;\n    var $564 = 0,\n        $565 = 0,\n        $566 = 0,\n        $567 = 0,\n        $568 = 0,\n        $569 = 0,\n        $57 = 0,\n        $570 = 0,\n        $571 = 0,\n        $572 = 0,\n        $573 = 0,\n        $574 = 0,\n        $575 = 0,\n        $576 = 0,\n        $577 = 0,\n        $578 = 0,\n        $579 = 0,\n        $58 = 0,\n        $580 = 0,\n        $581 = 0;\n    var $582 = 0,\n        $583 = 0,\n        $584 = 0,\n        $585 = 0,\n        $586 = 0,\n        $587 = 0,\n        $588 = 0,\n        $589 = 0,\n        $59 = 0,\n        $590 = 0,\n        $591 = 0,\n        $592 = 0,\n        $593 = 0,\n        $594 = 0,\n        $595 = 0,\n        $596 = 0,\n        $597 = 0,\n        $598 = 0,\n        $599 = 0,\n        $6 = 0;\n    var $60 = 0,\n        $600 = 0,\n        $601 = 0,\n        $602 = 0,\n        $603 = 0,\n        $604 = 0,\n        $605 = 0,\n        $606 = 0,\n        $607 = 0,\n        $608 = 0,\n        $609 = 0,\n        $61 = 0,\n        $610 = 0,\n        $611 = 0,\n        $612 = 0,\n        $613 = 0,\n        $614 = 0,\n        $615 = 0,\n        $616 = 0,\n        $617 = 0;\n    var $618 = 0,\n        $619 = 0,\n        $62 = 0,\n        $620 = 0,\n        $621 = 0,\n        $622 = 0,\n        $623 = 0,\n        $624 = 0,\n        $625 = 0,\n        $626 = 0,\n        $627 = 0,\n        $628 = 0,\n        $629 = 0,\n        $63 = 0,\n        $630 = 0,\n        $631 = 0,\n        $632 = 0,\n        $633 = 0,\n        $634 = 0,\n        $635 = 0;\n    var $636 = 0,\n        $637 = 0,\n        $638 = 0,\n        $639 = 0,\n        $64 = 0,\n        $640 = 0,\n        $641 = 0,\n        $642 = 0,\n        $643 = 0,\n        $644 = 0,\n        $645 = 0,\n        $646 = 0,\n        $647 = 0,\n        $648 = 0,\n        $649 = 0,\n        $65 = 0,\n        $650 = 0,\n        $651 = 0,\n        $652 = 0,\n        $653 = 0;\n    var $654 = 0,\n        $655 = 0,\n        $656 = 0,\n        $657 = 0,\n        $658 = 0,\n        $659 = 0,\n        $66 = 0,\n        $660 = 0,\n        $661 = 0,\n        $662 = 0,\n        $663 = 0,\n        $664 = 0,\n        $665 = 0,\n        $666 = 0,\n        $667 = 0,\n        $668 = 0,\n        $669 = 0,\n        $67 = 0,\n        $670 = 0,\n        $671 = 0;\n    var $672 = 0,\n        $673 = 0,\n        $674 = 0,\n        $675 = 0,\n        $676 = 0,\n        $677 = 0,\n        $678 = 0,\n        $679 = 0,\n        $68 = 0,\n        $680 = 0,\n        $681 = 0,\n        $682 = 0,\n        $683 = 0,\n        $684 = 0,\n        $685 = 0,\n        $686 = 0,\n        $687 = 0,\n        $688 = 0,\n        $689 = 0,\n        $69 = 0;\n    var $690 = 0,\n        $691 = 0,\n        $692 = 0,\n        $693 = 0,\n        $694 = 0,\n        $695 = 0,\n        $696 = 0,\n        $697 = 0,\n        $698 = 0,\n        $699 = 0,\n        $7 = 0,\n        $70 = 0,\n        $700 = 0,\n        $701 = 0,\n        $702 = 0,\n        $703 = 0,\n        $704 = 0,\n        $705 = 0,\n        $706 = 0,\n        $707 = 0;\n    var $708 = 0,\n        $709 = 0,\n        $71 = 0,\n        $710 = 0,\n        $711 = 0,\n        $712 = 0,\n        $713 = 0,\n        $714 = 0,\n        $715 = 0,\n        $716 = 0,\n        $717 = 0,\n        $718 = 0,\n        $719 = 0,\n        $72 = 0,\n        $720 = 0,\n        $721 = 0,\n        $722 = 0,\n        $723 = 0,\n        $724 = 0,\n        $725 = 0;\n    var $726 = 0,\n        $727 = 0,\n        $728 = 0,\n        $729 = 0,\n        $73 = 0,\n        $730 = 0,\n        $731 = 0,\n        $732 = 0,\n        $733 = 0,\n        $734 = 0,\n        $735 = 0,\n        $736 = 0,\n        $737 = 0,\n        $738 = 0,\n        $739 = 0,\n        $74 = 0,\n        $740 = 0,\n        $741 = 0,\n        $742 = 0,\n        $743 = 0;\n    var $744 = 0,\n        $745 = 0,\n        $746 = 0,\n        $747 = 0,\n        $748 = 0,\n        $749 = 0,\n        $75 = 0,\n        $750 = 0,\n        $751 = 0,\n        $752 = 0,\n        $753 = 0,\n        $754 = 0,\n        $755 = 0,\n        $756 = 0,\n        $757 = 0,\n        $758 = 0,\n        $759 = 0,\n        $76 = 0,\n        $760 = 0,\n        $761 = 0;\n    var $762 = 0,\n        $763 = 0,\n        $764 = 0,\n        $765 = 0,\n        $766 = 0,\n        $767 = 0,\n        $768 = 0,\n        $769 = 0,\n        $77 = 0,\n        $770 = 0,\n        $771 = 0,\n        $772 = 0,\n        $773 = 0,\n        $774 = 0,\n        $775 = 0,\n        $776 = 0,\n        $777 = 0,\n        $778 = 0,\n        $779 = 0,\n        $78 = 0;\n    var $780 = 0,\n        $781 = 0,\n        $782 = 0,\n        $783 = 0,\n        $784 = 0,\n        $785 = 0,\n        $786 = 0,\n        $787 = 0,\n        $788 = 0,\n        $789 = 0,\n        $79 = 0,\n        $790 = 0,\n        $791 = 0,\n        $792 = 0,\n        $793 = 0,\n        $794 = 0,\n        $795 = 0,\n        $796 = 0,\n        $797 = 0,\n        $798 = 0;\n    var $799 = 0,\n        $8 = 0,\n        $80 = 0,\n        $800 = 0,\n        $801 = 0,\n        $802 = 0,\n        $803 = 0,\n        $804 = 0,\n        $805 = 0,\n        $806 = 0,\n        $807 = 0,\n        $808 = 0,\n        $809 = 0,\n        $81 = 0,\n        $810 = 0,\n        $811 = 0,\n        $812 = 0,\n        $813 = 0,\n        $814 = 0,\n        $815 = 0;\n    var $816 = 0,\n        $817 = 0,\n        $818 = 0,\n        $819 = 0,\n        $82 = 0,\n        $820 = 0,\n        $821 = 0,\n        $822 = 0,\n        $823 = 0,\n        $824 = 0,\n        $825 = 0,\n        $826 = 0,\n        $827 = 0,\n        $828 = 0,\n        $829 = 0,\n        $83 = 0,\n        $830 = 0,\n        $831 = 0,\n        $832 = 0,\n        $833 = 0;\n    var $834 = 0,\n        $835 = 0,\n        $836 = 0,\n        $837 = 0,\n        $838 = 0,\n        $839 = 0,\n        $84 = 0,\n        $840 = 0,\n        $841 = 0,\n        $842 = 0,\n        $843 = 0,\n        $844 = 0,\n        $845 = 0,\n        $846 = 0,\n        $847 = 0,\n        $848 = 0,\n        $849 = 0,\n        $85 = 0,\n        $850 = 0,\n        $851 = 0;\n    var $852 = 0,\n        $853 = 0,\n        $854 = 0,\n        $855 = 0,\n        $856 = 0,\n        $857 = 0,\n        $858 = 0,\n        $859 = 0,\n        $86 = 0,\n        $860 = 0,\n        $861 = 0,\n        $862 = 0,\n        $863 = 0,\n        $864 = 0,\n        $865 = 0,\n        $866 = 0,\n        $867 = 0,\n        $868 = 0,\n        $869 = 0,\n        $87 = 0;\n    var $870 = 0,\n        $871 = 0,\n        $872 = 0,\n        $873 = 0,\n        $874 = 0,\n        $875 = 0,\n        $876 = 0,\n        $877 = 0,\n        $878 = 0,\n        $879 = 0,\n        $88 = 0,\n        $880 = 0,\n        $881 = 0,\n        $882 = 0,\n        $883 = 0,\n        $884 = 0,\n        $885 = 0,\n        $886 = 0,\n        $887 = 0,\n        $888 = 0;\n    var $889 = 0,\n        $89 = 0,\n        $890 = 0,\n        $891 = 0,\n        $892 = 0,\n        $893 = 0,\n        $894 = 0,\n        $895 = 0,\n        $896 = 0,\n        $897 = 0,\n        $898 = 0,\n        $899 = 0,\n        $9 = 0,\n        $90 = 0,\n        $900 = 0,\n        $901 = 0,\n        $902 = 0,\n        $903 = 0,\n        $904 = 0,\n        $905 = 0;\n    var $906 = 0,\n        $907 = 0,\n        $908 = 0,\n        $909 = 0,\n        $91 = 0,\n        $910 = 0,\n        $911 = 0,\n        $912 = 0,\n        $913 = 0,\n        $914 = 0,\n        $915 = 0,\n        $916 = 0,\n        $917 = 0,\n        $918 = 0,\n        $919 = 0,\n        $92 = 0,\n        $920 = 0,\n        $921 = 0,\n        $922 = 0,\n        $923 = 0;\n    var $924 = 0,\n        $925 = 0,\n        $926 = 0,\n        $927 = 0,\n        $928 = 0,\n        $929 = 0,\n        $93 = 0,\n        $930 = 0,\n        $931 = 0,\n        $932 = 0,\n        $933 = 0,\n        $934 = 0,\n        $935 = 0,\n        $936 = 0,\n        $937 = 0,\n        $938 = 0,\n        $939 = 0,\n        $94 = 0,\n        $940 = 0,\n        $941 = 0;\n    var $942 = 0,\n        $943 = 0,\n        $944 = 0,\n        $945 = 0,\n        $946 = 0,\n        $947 = 0,\n        $948 = 0,\n        $949 = 0,\n        $95 = 0,\n        $950 = 0,\n        $951 = 0,\n        $952 = 0,\n        $953 = 0,\n        $954 = 0,\n        $955 = 0,\n        $956 = 0,\n        $957 = 0,\n        $958 = 0,\n        $959 = 0,\n        $96 = 0;\n    var $960 = 0,\n        $961 = 0,\n        $962 = 0,\n        $963 = 0,\n        $964 = 0,\n        $965 = 0,\n        $966 = 0,\n        $967 = 0,\n        $968 = 0,\n        $969 = 0,\n        $97 = 0,\n        $970 = 0,\n        $971 = 0,\n        $972 = 0,\n        $973 = 0,\n        $974 = 0,\n        $975 = 0,\n        $976 = 0,\n        $977 = 0,\n        $978 = 0;\n    var $979 = 0,\n        $98 = 0,\n        $980 = 0,\n        $981 = 0,\n        $982 = 0,\n        $983 = 0,\n        $984 = 0,\n        $985 = 0,\n        $986 = 0,\n        $987 = 0,\n        $988 = 0,\n        $989 = 0,\n        $99 = 0,\n        $990 = 0,\n        $991 = 0,\n        $992 = 0,\n        $993 = 0,\n        $994 = 0,\n        $995 = 0,\n        $996 = 0;\n    var $997 = 0,\n        $998 = 0,\n        $999 = 0,\n        $cond$i = 0,\n        $cond$i$i = 0,\n        $cond$i207 = 0,\n        $not$$i = 0,\n        $or$cond$i = 0,\n        $or$cond$i213 = 0,\n        $or$cond1$i = 0,\n        $or$cond11$i = 0,\n        $or$cond2$i = 0,\n        $or$cond2$i214 = 0,\n        $or$cond5$i = 0,\n        $or$cond50$i = 0,\n        $or$cond51$i = 0,\n        $or$cond6$i = 0,\n        $or$cond7$i = 0,\n        $or$cond8$i = 0,\n        $or$cond8$not$i = 0;\n    var $spec$select$i = 0,\n        $spec$select$i205 = 0,\n        $spec$select1$i = 0,\n        $spec$select3$i = 0,\n        $spec$select49$i = 0,\n        $spec$select7$i = 0,\n        $spec$select9$i = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    STACKTOP = STACKTOP + 16 | 0;\n    if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);\n    $1 = sp;\n    $2 = $0 >>> 0 < 245;\n\n    do {\n      if ($2) {\n        $3 = $0 >>> 0 < 11;\n        $4 = $0 + 11 | 0;\n        $5 = $4 & -8;\n        $6 = $3 ? 16 : $5;\n        $7 = $6 >>> 3;\n        $8 = HEAP32[82400] | 0;\n        $9 = $8 >>> $7;\n        $10 = $9 & 3;\n        $11 = ($10 | 0) == 0;\n\n        if (!$11) {\n          $12 = $9 & 1;\n          $13 = $12 ^ 1;\n          $14 = $13 + $7 | 0;\n          $15 = $14 << 1;\n          $16 = 329640 + ($15 << 2) | 0;\n          $17 = $16 + 8 | 0;\n          $18 = HEAP32[$17 >> 2] | 0;\n          $19 = $18 + 8 | 0;\n          $20 = HEAP32[$19 >> 2] | 0;\n          $21 = ($20 | 0) == ($16 | 0);\n\n          do {\n            if ($21) {\n              $22 = 1 << $14;\n              $23 = $22 ^ -1;\n              $24 = $8 & $23;\n              HEAP32[82400] = $24;\n            } else {\n              $25 = HEAP32[329616 >> 2] | 0;\n              $26 = $25 >>> 0 > $20 >>> 0;\n\n              if ($26) {\n                _abort(); // unreachable;\n\n              }\n\n              $27 = $20 + 12 | 0;\n              $28 = HEAP32[$27 >> 2] | 0;\n              $29 = ($28 | 0) == ($18 | 0);\n\n              if ($29) {\n                HEAP32[$27 >> 2] = $16;\n                HEAP32[$17 >> 2] = $20;\n                break;\n              } else {\n                _abort(); // unreachable;\n\n              }\n            }\n          } while (0);\n\n          $30 = $14 << 3;\n          $31 = $30 | 3;\n          $32 = $18 + 4 | 0;\n          HEAP32[$32 >> 2] = $31;\n          $33 = $18 + $30 | 0;\n          $34 = $33 + 4 | 0;\n          $35 = HEAP32[$34 >> 2] | 0;\n          $36 = $35 | 1;\n          HEAP32[$34 >> 2] = $36;\n          $$0 = $19;\n          STACKTOP = sp;\n          return $$0 | 0;\n        }\n\n        $37 = HEAP32[329608 >> 2] | 0;\n        $38 = $6 >>> 0 > $37 >>> 0;\n\n        if ($38) {\n          $39 = ($9 | 0) == 0;\n\n          if (!$39) {\n            $40 = $9 << $7;\n            $41 = 2 << $7;\n            $42 = 0 - $41 | 0;\n            $43 = $41 | $42;\n            $44 = $40 & $43;\n            $45 = 0 - $44 | 0;\n            $46 = $44 & $45;\n            $47 = $46 + -1 | 0;\n            $48 = $47 >>> 12;\n            $49 = $48 & 16;\n            $50 = $47 >>> $49;\n            $51 = $50 >>> 5;\n            $52 = $51 & 8;\n            $53 = $52 | $49;\n            $54 = $50 >>> $52;\n            $55 = $54 >>> 2;\n            $56 = $55 & 4;\n            $57 = $53 | $56;\n            $58 = $54 >>> $56;\n            $59 = $58 >>> 1;\n            $60 = $59 & 2;\n            $61 = $57 | $60;\n            $62 = $58 >>> $60;\n            $63 = $62 >>> 1;\n            $64 = $63 & 1;\n            $65 = $61 | $64;\n            $66 = $62 >>> $64;\n            $67 = $65 + $66 | 0;\n            $68 = $67 << 1;\n            $69 = 329640 + ($68 << 2) | 0;\n            $70 = $69 + 8 | 0;\n            $71 = HEAP32[$70 >> 2] | 0;\n            $72 = $71 + 8 | 0;\n            $73 = HEAP32[$72 >> 2] | 0;\n            $74 = ($73 | 0) == ($69 | 0);\n\n            do {\n              if ($74) {\n                $75 = 1 << $67;\n                $76 = $75 ^ -1;\n                $77 = $8 & $76;\n                HEAP32[82400] = $77;\n                $98 = $77;\n              } else {\n                $78 = HEAP32[329616 >> 2] | 0;\n                $79 = $78 >>> 0 > $73 >>> 0;\n\n                if ($79) {\n                  _abort(); // unreachable;\n\n                }\n\n                $80 = $73 + 12 | 0;\n                $81 = HEAP32[$80 >> 2] | 0;\n                $82 = ($81 | 0) == ($71 | 0);\n\n                if ($82) {\n                  HEAP32[$80 >> 2] = $69;\n                  HEAP32[$70 >> 2] = $73;\n                  $98 = $8;\n                  break;\n                } else {\n                  _abort(); // unreachable;\n\n                }\n              }\n            } while (0);\n\n            $83 = $67 << 3;\n            $84 = $83 - $6 | 0;\n            $85 = $6 | 3;\n            $86 = $71 + 4 | 0;\n            HEAP32[$86 >> 2] = $85;\n            $87 = $71 + $6 | 0;\n            $88 = $84 | 1;\n            $89 = $87 + 4 | 0;\n            HEAP32[$89 >> 2] = $88;\n            $90 = $71 + $83 | 0;\n            HEAP32[$90 >> 2] = $84;\n            $91 = ($37 | 0) == 0;\n\n            if (!$91) {\n              $92 = HEAP32[329620 >> 2] | 0;\n              $93 = $37 >>> 3;\n              $94 = $93 << 1;\n              $95 = 329640 + ($94 << 2) | 0;\n              $96 = 1 << $93;\n              $97 = $98 & $96;\n              $99 = ($97 | 0) == 0;\n\n              if ($99) {\n                $100 = $98 | $96;\n                HEAP32[82400] = $100;\n                $$pre = $95 + 8 | 0;\n                $$0199 = $95;\n                $$pre$phiZ2D = $$pre;\n              } else {\n                $101 = $95 + 8 | 0;\n                $102 = HEAP32[$101 >> 2] | 0;\n                $103 = HEAP32[329616 >> 2] | 0;\n                $104 = $103 >>> 0 > $102 >>> 0;\n\n                if ($104) {\n                  _abort(); // unreachable;\n\n                } else {\n                  $$0199 = $102;\n                  $$pre$phiZ2D = $101;\n                }\n              }\n\n              HEAP32[$$pre$phiZ2D >> 2] = $92;\n              $105 = $$0199 + 12 | 0;\n              HEAP32[$105 >> 2] = $92;\n              $106 = $92 + 8 | 0;\n              HEAP32[$106 >> 2] = $$0199;\n              $107 = $92 + 12 | 0;\n              HEAP32[$107 >> 2] = $95;\n            }\n\n            HEAP32[329608 >> 2] = $84;\n            HEAP32[329620 >> 2] = $87;\n            $$0 = $72;\n            STACKTOP = sp;\n            return $$0 | 0;\n          }\n\n          $108 = HEAP32[329604 >> 2] | 0;\n          $109 = ($108 | 0) == 0;\n\n          if ($109) {\n            $$0197 = $6;\n          } else {\n            $110 = 0 - $108 | 0;\n            $111 = $108 & $110;\n            $112 = $111 + -1 | 0;\n            $113 = $112 >>> 12;\n            $114 = $113 & 16;\n            $115 = $112 >>> $114;\n            $116 = $115 >>> 5;\n            $117 = $116 & 8;\n            $118 = $117 | $114;\n            $119 = $115 >>> $117;\n            $120 = $119 >>> 2;\n            $121 = $120 & 4;\n            $122 = $118 | $121;\n            $123 = $119 >>> $121;\n            $124 = $123 >>> 1;\n            $125 = $124 & 2;\n            $126 = $122 | $125;\n            $127 = $123 >>> $125;\n            $128 = $127 >>> 1;\n            $129 = $128 & 1;\n            $130 = $126 | $129;\n            $131 = $127 >>> $129;\n            $132 = $130 + $131 | 0;\n            $133 = 329904 + ($132 << 2) | 0;\n            $134 = HEAP32[$133 >> 2] | 0;\n            $135 = $134 + 4 | 0;\n            $136 = HEAP32[$135 >> 2] | 0;\n            $137 = $136 & -8;\n            $138 = $137 - $6 | 0;\n            $$0189$i = $134;\n            $$0190$i = $134;\n            $$0191$i = $138;\n\n            while (1) {\n              $139 = $$0189$i + 16 | 0;\n              $140 = HEAP32[$139 >> 2] | 0;\n              $141 = ($140 | 0) == (0 | 0);\n\n              if ($141) {\n                $142 = $$0189$i + 20 | 0;\n                $143 = HEAP32[$142 >> 2] | 0;\n                $144 = ($143 | 0) == (0 | 0);\n\n                if ($144) {\n                  break;\n                } else {\n                  $146 = $143;\n                }\n              } else {\n                $146 = $140;\n              }\n\n              $145 = $146 + 4 | 0;\n              $147 = HEAP32[$145 >> 2] | 0;\n              $148 = $147 & -8;\n              $149 = $148 - $6 | 0;\n              $150 = $149 >>> 0 < $$0191$i >>> 0;\n              $spec$select$i = $150 ? $149 : $$0191$i;\n              $spec$select1$i = $150 ? $146 : $$0190$i;\n              $$0189$i = $146;\n              $$0190$i = $spec$select1$i;\n              $$0191$i = $spec$select$i;\n            }\n\n            $151 = HEAP32[329616 >> 2] | 0;\n            $152 = $151 >>> 0 > $$0190$i >>> 0;\n\n            if ($152) {\n              _abort(); // unreachable;\n\n            }\n\n            $153 = $$0190$i + $6 | 0;\n            $154 = $153 >>> 0 > $$0190$i >>> 0;\n\n            if (!$154) {\n              _abort(); // unreachable;\n\n            }\n\n            $155 = $$0190$i + 24 | 0;\n            $156 = HEAP32[$155 >> 2] | 0;\n            $157 = $$0190$i + 12 | 0;\n            $158 = HEAP32[$157 >> 2] | 0;\n            $159 = ($158 | 0) == ($$0190$i | 0);\n\n            do {\n              if ($159) {\n                $169 = $$0190$i + 20 | 0;\n                $170 = HEAP32[$169 >> 2] | 0;\n                $171 = ($170 | 0) == (0 | 0);\n\n                if ($171) {\n                  $172 = $$0190$i + 16 | 0;\n                  $173 = HEAP32[$172 >> 2] | 0;\n                  $174 = ($173 | 0) == (0 | 0);\n\n                  if ($174) {\n                    $$3$i = 0;\n                    break;\n                  } else {\n                    $$1194$i$ph = $173;\n                    $$1196$i$ph = $172;\n                  }\n                } else {\n                  $$1194$i$ph = $170;\n                  $$1196$i$ph = $169;\n                }\n\n                $$1194$i = $$1194$i$ph;\n                $$1196$i = $$1196$i$ph;\n\n                while (1) {\n                  $175 = $$1194$i + 20 | 0;\n                  $176 = HEAP32[$175 >> 2] | 0;\n                  $177 = ($176 | 0) == (0 | 0);\n\n                  if ($177) {\n                    $178 = $$1194$i + 16 | 0;\n                    $179 = HEAP32[$178 >> 2] | 0;\n                    $180 = ($179 | 0) == (0 | 0);\n\n                    if ($180) {\n                      break;\n                    } else {\n                      $$1194$i$be = $179;\n                      $$1196$i$be = $178;\n                    }\n                  } else {\n                    $$1194$i$be = $176;\n                    $$1196$i$be = $175;\n                  }\n\n                  $$1194$i = $$1194$i$be;\n                  $$1196$i = $$1196$i$be;\n                }\n\n                $181 = $151 >>> 0 > $$1196$i >>> 0;\n\n                if ($181) {\n                  _abort(); // unreachable;\n\n                } else {\n                  HEAP32[$$1196$i >> 2] = 0;\n                  $$3$i = $$1194$i;\n                  break;\n                }\n              } else {\n                $160 = $$0190$i + 8 | 0;\n                $161 = HEAP32[$160 >> 2] | 0;\n                $162 = $151 >>> 0 > $161 >>> 0;\n\n                if ($162) {\n                  _abort(); // unreachable;\n\n                }\n\n                $163 = $161 + 12 | 0;\n                $164 = HEAP32[$163 >> 2] | 0;\n                $165 = ($164 | 0) == ($$0190$i | 0);\n\n                if (!$165) {\n                  _abort(); // unreachable;\n\n                }\n\n                $166 = $158 + 8 | 0;\n                $167 = HEAP32[$166 >> 2] | 0;\n                $168 = ($167 | 0) == ($$0190$i | 0);\n\n                if ($168) {\n                  HEAP32[$163 >> 2] = $158;\n                  HEAP32[$166 >> 2] = $161;\n                  $$3$i = $158;\n                  break;\n                } else {\n                  _abort(); // unreachable;\n\n                }\n              }\n            } while (0);\n\n            $182 = ($156 | 0) == (0 | 0);\n\n            L78: do {\n              if (!$182) {\n                $183 = $$0190$i + 28 | 0;\n                $184 = HEAP32[$183 >> 2] | 0;\n                $185 = 329904 + ($184 << 2) | 0;\n                $186 = HEAP32[$185 >> 2] | 0;\n                $187 = ($$0190$i | 0) == ($186 | 0);\n\n                do {\n                  if ($187) {\n                    HEAP32[$185 >> 2] = $$3$i;\n                    $cond$i = ($$3$i | 0) == (0 | 0);\n\n                    if ($cond$i) {\n                      $188 = 1 << $184;\n                      $189 = $188 ^ -1;\n                      $190 = $108 & $189;\n                      HEAP32[329604 >> 2] = $190;\n                      break L78;\n                    }\n                  } else {\n                    $191 = HEAP32[329616 >> 2] | 0;\n                    $192 = $191 >>> 0 > $156 >>> 0;\n\n                    if ($192) {\n                      _abort(); // unreachable;\n\n                    } else {\n                      $193 = $156 + 16 | 0;\n                      $194 = HEAP32[$193 >> 2] | 0;\n                      $195 = ($194 | 0) == ($$0190$i | 0);\n                      $196 = $156 + 20 | 0;\n                      $$sink = $195 ? $193 : $196;\n                      HEAP32[$$sink >> 2] = $$3$i;\n                      $197 = ($$3$i | 0) == (0 | 0);\n\n                      if ($197) {\n                        break L78;\n                      } else {\n                        break;\n                      }\n                    }\n                  }\n                } while (0);\n\n                $198 = HEAP32[329616 >> 2] | 0;\n                $199 = $198 >>> 0 > $$3$i >>> 0;\n\n                if ($199) {\n                  _abort(); // unreachable;\n\n                }\n\n                $200 = $$3$i + 24 | 0;\n                HEAP32[$200 >> 2] = $156;\n                $201 = $$0190$i + 16 | 0;\n                $202 = HEAP32[$201 >> 2] | 0;\n                $203 = ($202 | 0) == (0 | 0);\n\n                do {\n                  if (!$203) {\n                    $204 = $198 >>> 0 > $202 >>> 0;\n\n                    if ($204) {\n                      _abort(); // unreachable;\n\n                    } else {\n                      $205 = $$3$i + 16 | 0;\n                      HEAP32[$205 >> 2] = $202;\n                      $206 = $202 + 24 | 0;\n                      HEAP32[$206 >> 2] = $$3$i;\n                      break;\n                    }\n                  }\n                } while (0);\n\n                $207 = $$0190$i + 20 | 0;\n                $208 = HEAP32[$207 >> 2] | 0;\n                $209 = ($208 | 0) == (0 | 0);\n\n                if (!$209) {\n                  $210 = HEAP32[329616 >> 2] | 0;\n                  $211 = $210 >>> 0 > $208 >>> 0;\n\n                  if ($211) {\n                    _abort(); // unreachable;\n\n                  } else {\n                    $212 = $$3$i + 20 | 0;\n                    HEAP32[$212 >> 2] = $208;\n                    $213 = $208 + 24 | 0;\n                    HEAP32[$213 >> 2] = $$3$i;\n                    break;\n                  }\n                }\n              }\n            } while (0);\n\n            $214 = $$0191$i >>> 0 < 16;\n\n            if ($214) {\n              $215 = $$0191$i + $6 | 0;\n              $216 = $215 | 3;\n              $217 = $$0190$i + 4 | 0;\n              HEAP32[$217 >> 2] = $216;\n              $218 = $$0190$i + $215 | 0;\n              $219 = $218 + 4 | 0;\n              $220 = HEAP32[$219 >> 2] | 0;\n              $221 = $220 | 1;\n              HEAP32[$219 >> 2] = $221;\n            } else {\n              $222 = $6 | 3;\n              $223 = $$0190$i + 4 | 0;\n              HEAP32[$223 >> 2] = $222;\n              $224 = $$0191$i | 1;\n              $225 = $153 + 4 | 0;\n              HEAP32[$225 >> 2] = $224;\n              $226 = $153 + $$0191$i | 0;\n              HEAP32[$226 >> 2] = $$0191$i;\n              $227 = ($37 | 0) == 0;\n\n              if (!$227) {\n                $228 = HEAP32[329620 >> 2] | 0;\n                $229 = $37 >>> 3;\n                $230 = $229 << 1;\n                $231 = 329640 + ($230 << 2) | 0;\n                $232 = 1 << $229;\n                $233 = $232 & $8;\n                $234 = ($233 | 0) == 0;\n\n                if ($234) {\n                  $235 = $232 | $8;\n                  HEAP32[82400] = $235;\n                  $$pre$i = $231 + 8 | 0;\n                  $$0187$i = $231;\n                  $$pre$phi$iZ2D = $$pre$i;\n                } else {\n                  $236 = $231 + 8 | 0;\n                  $237 = HEAP32[$236 >> 2] | 0;\n                  $238 = HEAP32[329616 >> 2] | 0;\n                  $239 = $238 >>> 0 > $237 >>> 0;\n\n                  if ($239) {\n                    _abort(); // unreachable;\n\n                  } else {\n                    $$0187$i = $237;\n                    $$pre$phi$iZ2D = $236;\n                  }\n                }\n\n                HEAP32[$$pre$phi$iZ2D >> 2] = $228;\n                $240 = $$0187$i + 12 | 0;\n                HEAP32[$240 >> 2] = $228;\n                $241 = $228 + 8 | 0;\n                HEAP32[$241 >> 2] = $$0187$i;\n                $242 = $228 + 12 | 0;\n                HEAP32[$242 >> 2] = $231;\n              }\n\n              HEAP32[329608 >> 2] = $$0191$i;\n              HEAP32[329620 >> 2] = $153;\n            }\n\n            $243 = $$0190$i + 8 | 0;\n            $$0 = $243;\n            STACKTOP = sp;\n            return $$0 | 0;\n          }\n        } else {\n          $$0197 = $6;\n        }\n      } else {\n        $244 = $0 >>> 0 > 4294967231;\n\n        if ($244) {\n          $$0197 = -1;\n        } else {\n          $245 = $0 + 11 | 0;\n          $246 = $245 & -8;\n          $247 = HEAP32[329604 >> 2] | 0;\n          $248 = ($247 | 0) == 0;\n\n          if ($248) {\n            $$0197 = $246;\n          } else {\n            $249 = 0 - $246 | 0;\n            $250 = $245 >>> 8;\n            $251 = ($250 | 0) == 0;\n\n            if ($251) {\n              $$0357$i = 0;\n            } else {\n              $252 = $246 >>> 0 > 16777215;\n\n              if ($252) {\n                $$0357$i = 31;\n              } else {\n                $253 = $250 + 1048320 | 0;\n                $254 = $253 >>> 16;\n                $255 = $254 & 8;\n                $256 = $250 << $255;\n                $257 = $256 + 520192 | 0;\n                $258 = $257 >>> 16;\n                $259 = $258 & 4;\n                $260 = $259 | $255;\n                $261 = $256 << $259;\n                $262 = $261 + 245760 | 0;\n                $263 = $262 >>> 16;\n                $264 = $263 & 2;\n                $265 = $260 | $264;\n                $266 = 14 - $265 | 0;\n                $267 = $261 << $264;\n                $268 = $267 >>> 15;\n                $269 = $266 + $268 | 0;\n                $270 = $269 << 1;\n                $271 = $269 + 7 | 0;\n                $272 = $246 >>> $271;\n                $273 = $272 & 1;\n                $274 = $273 | $270;\n                $$0357$i = $274;\n              }\n            }\n\n            $275 = 329904 + ($$0357$i << 2) | 0;\n            $276 = HEAP32[$275 >> 2] | 0;\n            $277 = ($276 | 0) == (0 | 0);\n\n            L122: do {\n              if ($277) {\n                $$2353$i = 0;\n                $$3$i203 = 0;\n                $$3348$i = $249;\n                label = 85;\n              } else {\n                $278 = ($$0357$i | 0) == 31;\n                $279 = $$0357$i >>> 1;\n                $280 = 25 - $279 | 0;\n                $281 = $278 ? 0 : $280;\n                $282 = $246 << $281;\n                $$0340$i = 0;\n                $$0345$i = $249;\n                $$0351$i = $276;\n                $$0358$i = $282;\n                $$0361$i = 0;\n\n                while (1) {\n                  $283 = $$0351$i + 4 | 0;\n                  $284 = HEAP32[$283 >> 2] | 0;\n                  $285 = $284 & -8;\n                  $286 = $285 - $246 | 0;\n                  $287 = $286 >>> 0 < $$0345$i >>> 0;\n\n                  if ($287) {\n                    $288 = ($286 | 0) == 0;\n\n                    if ($288) {\n                      $$420$i$ph = $$0351$i;\n                      $$434919$i$ph = 0;\n                      $$535618$i$ph = $$0351$i;\n                      label = 89;\n                      break L122;\n                    } else {\n                      $$1341$i = $$0351$i;\n                      $$1346$i = $286;\n                    }\n                  } else {\n                    $$1341$i = $$0340$i;\n                    $$1346$i = $$0345$i;\n                  }\n\n                  $289 = $$0351$i + 20 | 0;\n                  $290 = HEAP32[$289 >> 2] | 0;\n                  $291 = $$0358$i >>> 31;\n                  $292 = ($$0351$i + 16 | 0) + ($291 << 2) | 0;\n                  $293 = HEAP32[$292 >> 2] | 0;\n                  $294 = ($290 | 0) == (0 | 0);\n                  $295 = ($290 | 0) == ($293 | 0);\n                  $or$cond2$i = $294 | $295;\n                  $$1362$i = $or$cond2$i ? $$0361$i : $290;\n                  $296 = ($293 | 0) == (0 | 0);\n                  $spec$select7$i = $$0358$i << 1;\n\n                  if ($296) {\n                    $$2353$i = $$1362$i;\n                    $$3$i203 = $$1341$i;\n                    $$3348$i = $$1346$i;\n                    label = 85;\n                    break;\n                  } else {\n                    $$0340$i = $$1341$i;\n                    $$0345$i = $$1346$i;\n                    $$0351$i = $293;\n                    $$0358$i = $spec$select7$i;\n                    $$0361$i = $$1362$i;\n                  }\n                }\n              }\n            } while (0);\n\n            if ((label | 0) == 85) {\n              $297 = ($$2353$i | 0) == (0 | 0);\n              $298 = ($$3$i203 | 0) == (0 | 0);\n              $or$cond$i = $297 & $298;\n\n              if ($or$cond$i) {\n                $299 = 2 << $$0357$i;\n                $300 = 0 - $299 | 0;\n                $301 = $299 | $300;\n                $302 = $301 & $247;\n                $303 = ($302 | 0) == 0;\n\n                if ($303) {\n                  $$0197 = $246;\n                  break;\n                }\n\n                $304 = 0 - $302 | 0;\n                $305 = $302 & $304;\n                $306 = $305 + -1 | 0;\n                $307 = $306 >>> 12;\n                $308 = $307 & 16;\n                $309 = $306 >>> $308;\n                $310 = $309 >>> 5;\n                $311 = $310 & 8;\n                $312 = $311 | $308;\n                $313 = $309 >>> $311;\n                $314 = $313 >>> 2;\n                $315 = $314 & 4;\n                $316 = $312 | $315;\n                $317 = $313 >>> $315;\n                $318 = $317 >>> 1;\n                $319 = $318 & 2;\n                $320 = $316 | $319;\n                $321 = $317 >>> $319;\n                $322 = $321 >>> 1;\n                $323 = $322 & 1;\n                $324 = $320 | $323;\n                $325 = $321 >>> $323;\n                $326 = $324 + $325 | 0;\n                $327 = 329904 + ($326 << 2) | 0;\n                $328 = HEAP32[$327 >> 2] | 0;\n                $$3$i203218 = 0;\n                $$4355$i = $328;\n              } else {\n                $$3$i203218 = $$3$i203;\n                $$4355$i = $$2353$i;\n              }\n\n              $329 = ($$4355$i | 0) == (0 | 0);\n\n              if ($329) {\n                $$4$lcssa$i = $$3$i203218;\n                $$4349$lcssa$i = $$3348$i;\n              } else {\n                $$420$i$ph = $$3$i203218;\n                $$434919$i$ph = $$3348$i;\n                $$535618$i$ph = $$4355$i;\n                label = 89;\n              }\n            }\n\n            if ((label | 0) == 89) {\n              $$420$i = $$420$i$ph;\n              $$434919$i = $$434919$i$ph;\n              $$535618$i = $$535618$i$ph;\n\n              while (1) {\n                $330 = $$535618$i + 4 | 0;\n                $331 = HEAP32[$330 >> 2] | 0;\n                $332 = $331 & -8;\n                $333 = $332 - $246 | 0;\n                $334 = $333 >>> 0 < $$434919$i >>> 0;\n                $spec$select$i205 = $334 ? $333 : $$434919$i;\n                $spec$select3$i = $334 ? $$535618$i : $$420$i;\n                $335 = $$535618$i + 16 | 0;\n                $336 = HEAP32[$335 >> 2] | 0;\n                $337 = ($336 | 0) == (0 | 0);\n\n                if ($337) {\n                  $338 = $$535618$i + 20 | 0;\n                  $339 = HEAP32[$338 >> 2] | 0;\n                  $341 = $339;\n                } else {\n                  $341 = $336;\n                }\n\n                $340 = ($341 | 0) == (0 | 0);\n\n                if ($340) {\n                  $$4$lcssa$i = $spec$select3$i;\n                  $$4349$lcssa$i = $spec$select$i205;\n                  break;\n                } else {\n                  $$420$i = $spec$select3$i;\n                  $$434919$i = $spec$select$i205;\n                  $$535618$i = $341;\n                }\n              }\n            }\n\n            $342 = ($$4$lcssa$i | 0) == (0 | 0);\n\n            if ($342) {\n              $$0197 = $246;\n            } else {\n              $343 = HEAP32[329608 >> 2] | 0;\n              $344 = $343 - $246 | 0;\n              $345 = $$4349$lcssa$i >>> 0 < $344 >>> 0;\n\n              if ($345) {\n                $346 = HEAP32[329616 >> 2] | 0;\n                $347 = $346 >>> 0 > $$4$lcssa$i >>> 0;\n\n                if ($347) {\n                  _abort(); // unreachable;\n\n                }\n\n                $348 = $$4$lcssa$i + $246 | 0;\n                $349 = $348 >>> 0 > $$4$lcssa$i >>> 0;\n\n                if (!$349) {\n                  _abort(); // unreachable;\n\n                }\n\n                $350 = $$4$lcssa$i + 24 | 0;\n                $351 = HEAP32[$350 >> 2] | 0;\n                $352 = $$4$lcssa$i + 12 | 0;\n                $353 = HEAP32[$352 >> 2] | 0;\n                $354 = ($353 | 0) == ($$4$lcssa$i | 0);\n\n                do {\n                  if ($354) {\n                    $364 = $$4$lcssa$i + 20 | 0;\n                    $365 = HEAP32[$364 >> 2] | 0;\n                    $366 = ($365 | 0) == (0 | 0);\n\n                    if ($366) {\n                      $367 = $$4$lcssa$i + 16 | 0;\n                      $368 = HEAP32[$367 >> 2] | 0;\n                      $369 = ($368 | 0) == (0 | 0);\n\n                      if ($369) {\n                        $$3371$i = 0;\n                        break;\n                      } else {\n                        $$1369$i$ph = $368;\n                        $$1373$i$ph = $367;\n                      }\n                    } else {\n                      $$1369$i$ph = $365;\n                      $$1373$i$ph = $364;\n                    }\n\n                    $$1369$i = $$1369$i$ph;\n                    $$1373$i = $$1373$i$ph;\n\n                    while (1) {\n                      $370 = $$1369$i + 20 | 0;\n                      $371 = HEAP32[$370 >> 2] | 0;\n                      $372 = ($371 | 0) == (0 | 0);\n\n                      if ($372) {\n                        $373 = $$1369$i + 16 | 0;\n                        $374 = HEAP32[$373 >> 2] | 0;\n                        $375 = ($374 | 0) == (0 | 0);\n\n                        if ($375) {\n                          break;\n                        } else {\n                          $$1369$i$be = $374;\n                          $$1373$i$be = $373;\n                        }\n                      } else {\n                        $$1369$i$be = $371;\n                        $$1373$i$be = $370;\n                      }\n\n                      $$1369$i = $$1369$i$be;\n                      $$1373$i = $$1373$i$be;\n                    }\n\n                    $376 = $346 >>> 0 > $$1373$i >>> 0;\n\n                    if ($376) {\n                      _abort(); // unreachable;\n\n                    } else {\n                      HEAP32[$$1373$i >> 2] = 0;\n                      $$3371$i = $$1369$i;\n                      break;\n                    }\n                  } else {\n                    $355 = $$4$lcssa$i + 8 | 0;\n                    $356 = HEAP32[$355 >> 2] | 0;\n                    $357 = $346 >>> 0 > $356 >>> 0;\n\n                    if ($357) {\n                      _abort(); // unreachable;\n\n                    }\n\n                    $358 = $356 + 12 | 0;\n                    $359 = HEAP32[$358 >> 2] | 0;\n                    $360 = ($359 | 0) == ($$4$lcssa$i | 0);\n\n                    if (!$360) {\n                      _abort(); // unreachable;\n\n                    }\n\n                    $361 = $353 + 8 | 0;\n                    $362 = HEAP32[$361 >> 2] | 0;\n                    $363 = ($362 | 0) == ($$4$lcssa$i | 0);\n\n                    if ($363) {\n                      HEAP32[$358 >> 2] = $353;\n                      HEAP32[$361 >> 2] = $356;\n                      $$3371$i = $353;\n                      break;\n                    } else {\n                      _abort(); // unreachable;\n\n                    }\n                  }\n                } while (0);\n\n                $377 = ($351 | 0) == (0 | 0);\n\n                L176: do {\n                  if ($377) {\n                    $469 = $247;\n                  } else {\n                    $378 = $$4$lcssa$i + 28 | 0;\n                    $379 = HEAP32[$378 >> 2] | 0;\n                    $380 = 329904 + ($379 << 2) | 0;\n                    $381 = HEAP32[$380 >> 2] | 0;\n                    $382 = ($$4$lcssa$i | 0) == ($381 | 0);\n\n                    do {\n                      if ($382) {\n                        HEAP32[$380 >> 2] = $$3371$i;\n                        $cond$i207 = ($$3371$i | 0) == (0 | 0);\n\n                        if ($cond$i207) {\n                          $383 = 1 << $379;\n                          $384 = $383 ^ -1;\n                          $385 = $247 & $384;\n                          HEAP32[329604 >> 2] = $385;\n                          $469 = $385;\n                          break L176;\n                        }\n                      } else {\n                        $386 = HEAP32[329616 >> 2] | 0;\n                        $387 = $386 >>> 0 > $351 >>> 0;\n\n                        if ($387) {\n                          _abort(); // unreachable;\n\n                        } else {\n                          $388 = $351 + 16 | 0;\n                          $389 = HEAP32[$388 >> 2] | 0;\n                          $390 = ($389 | 0) == ($$4$lcssa$i | 0);\n                          $391 = $351 + 20 | 0;\n                          $$sink325 = $390 ? $388 : $391;\n                          HEAP32[$$sink325 >> 2] = $$3371$i;\n                          $392 = ($$3371$i | 0) == (0 | 0);\n\n                          if ($392) {\n                            $469 = $247;\n                            break L176;\n                          } else {\n                            break;\n                          }\n                        }\n                      }\n                    } while (0);\n\n                    $393 = HEAP32[329616 >> 2] | 0;\n                    $394 = $393 >>> 0 > $$3371$i >>> 0;\n\n                    if ($394) {\n                      _abort(); // unreachable;\n\n                    }\n\n                    $395 = $$3371$i + 24 | 0;\n                    HEAP32[$395 >> 2] = $351;\n                    $396 = $$4$lcssa$i + 16 | 0;\n                    $397 = HEAP32[$396 >> 2] | 0;\n                    $398 = ($397 | 0) == (0 | 0);\n\n                    do {\n                      if (!$398) {\n                        $399 = $393 >>> 0 > $397 >>> 0;\n\n                        if ($399) {\n                          _abort(); // unreachable;\n\n                        } else {\n                          $400 = $$3371$i + 16 | 0;\n                          HEAP32[$400 >> 2] = $397;\n                          $401 = $397 + 24 | 0;\n                          HEAP32[$401 >> 2] = $$3371$i;\n                          break;\n                        }\n                      }\n                    } while (0);\n\n                    $402 = $$4$lcssa$i + 20 | 0;\n                    $403 = HEAP32[$402 >> 2] | 0;\n                    $404 = ($403 | 0) == (0 | 0);\n\n                    if ($404) {\n                      $469 = $247;\n                    } else {\n                      $405 = HEAP32[329616 >> 2] | 0;\n                      $406 = $405 >>> 0 > $403 >>> 0;\n\n                      if ($406) {\n                        _abort(); // unreachable;\n\n                      } else {\n                        $407 = $$3371$i + 20 | 0;\n                        HEAP32[$407 >> 2] = $403;\n                        $408 = $403 + 24 | 0;\n                        HEAP32[$408 >> 2] = $$3371$i;\n                        $469 = $247;\n                        break;\n                      }\n                    }\n                  }\n                } while (0);\n\n                $409 = $$4349$lcssa$i >>> 0 < 16;\n\n                L200: do {\n                  if ($409) {\n                    $410 = $$4349$lcssa$i + $246 | 0;\n                    $411 = $410 | 3;\n                    $412 = $$4$lcssa$i + 4 | 0;\n                    HEAP32[$412 >> 2] = $411;\n                    $413 = $$4$lcssa$i + $410 | 0;\n                    $414 = $413 + 4 | 0;\n                    $415 = HEAP32[$414 >> 2] | 0;\n                    $416 = $415 | 1;\n                    HEAP32[$414 >> 2] = $416;\n                  } else {\n                    $417 = $246 | 3;\n                    $418 = $$4$lcssa$i + 4 | 0;\n                    HEAP32[$418 >> 2] = $417;\n                    $419 = $$4349$lcssa$i | 1;\n                    $420 = $348 + 4 | 0;\n                    HEAP32[$420 >> 2] = $419;\n                    $421 = $348 + $$4349$lcssa$i | 0;\n                    HEAP32[$421 >> 2] = $$4349$lcssa$i;\n                    $422 = $$4349$lcssa$i >>> 3;\n                    $423 = $$4349$lcssa$i >>> 0 < 256;\n\n                    if ($423) {\n                      $424 = $422 << 1;\n                      $425 = 329640 + ($424 << 2) | 0;\n                      $426 = HEAP32[82400] | 0;\n                      $427 = 1 << $422;\n                      $428 = $426 & $427;\n                      $429 = ($428 | 0) == 0;\n\n                      if ($429) {\n                        $430 = $426 | $427;\n                        HEAP32[82400] = $430;\n                        $$pre$i208 = $425 + 8 | 0;\n                        $$0367$i = $425;\n                        $$pre$phi$i209Z2D = $$pre$i208;\n                      } else {\n                        $431 = $425 + 8 | 0;\n                        $432 = HEAP32[$431 >> 2] | 0;\n                        $433 = HEAP32[329616 >> 2] | 0;\n                        $434 = $433 >>> 0 > $432 >>> 0;\n\n                        if ($434) {\n                          _abort(); // unreachable;\n\n                        } else {\n                          $$0367$i = $432;\n                          $$pre$phi$i209Z2D = $431;\n                        }\n                      }\n\n                      HEAP32[$$pre$phi$i209Z2D >> 2] = $348;\n                      $435 = $$0367$i + 12 | 0;\n                      HEAP32[$435 >> 2] = $348;\n                      $436 = $348 + 8 | 0;\n                      HEAP32[$436 >> 2] = $$0367$i;\n                      $437 = $348 + 12 | 0;\n                      HEAP32[$437 >> 2] = $425;\n                      break;\n                    }\n\n                    $438 = $$4349$lcssa$i >>> 8;\n                    $439 = ($438 | 0) == 0;\n\n                    if ($439) {\n                      $$0360$i = 0;\n                    } else {\n                      $440 = $$4349$lcssa$i >>> 0 > 16777215;\n\n                      if ($440) {\n                        $$0360$i = 31;\n                      } else {\n                        $441 = $438 + 1048320 | 0;\n                        $442 = $441 >>> 16;\n                        $443 = $442 & 8;\n                        $444 = $438 << $443;\n                        $445 = $444 + 520192 | 0;\n                        $446 = $445 >>> 16;\n                        $447 = $446 & 4;\n                        $448 = $447 | $443;\n                        $449 = $444 << $447;\n                        $450 = $449 + 245760 | 0;\n                        $451 = $450 >>> 16;\n                        $452 = $451 & 2;\n                        $453 = $448 | $452;\n                        $454 = 14 - $453 | 0;\n                        $455 = $449 << $452;\n                        $456 = $455 >>> 15;\n                        $457 = $454 + $456 | 0;\n                        $458 = $457 << 1;\n                        $459 = $457 + 7 | 0;\n                        $460 = $$4349$lcssa$i >>> $459;\n                        $461 = $460 & 1;\n                        $462 = $461 | $458;\n                        $$0360$i = $462;\n                      }\n                    }\n\n                    $463 = 329904 + ($$0360$i << 2) | 0;\n                    $464 = $348 + 28 | 0;\n                    HEAP32[$464 >> 2] = $$0360$i;\n                    $465 = $348 + 16 | 0;\n                    $466 = $465 + 4 | 0;\n                    HEAP32[$466 >> 2] = 0;\n                    HEAP32[$465 >> 2] = 0;\n                    $467 = 1 << $$0360$i;\n                    $468 = $469 & $467;\n                    $470 = ($468 | 0) == 0;\n\n                    if ($470) {\n                      $471 = $469 | $467;\n                      HEAP32[329604 >> 2] = $471;\n                      HEAP32[$463 >> 2] = $348;\n                      $472 = $348 + 24 | 0;\n                      HEAP32[$472 >> 2] = $463;\n                      $473 = $348 + 12 | 0;\n                      HEAP32[$473 >> 2] = $348;\n                      $474 = $348 + 8 | 0;\n                      HEAP32[$474 >> 2] = $348;\n                      break;\n                    }\n\n                    $475 = HEAP32[$463 >> 2] | 0;\n                    $476 = $475 + 4 | 0;\n                    $477 = HEAP32[$476 >> 2] | 0;\n                    $478 = $477 & -8;\n                    $479 = ($478 | 0) == ($$4349$lcssa$i | 0);\n\n                    L218: do {\n                      if ($479) {\n                        $$0343$lcssa$i = $475;\n                      } else {\n                        $480 = ($$0360$i | 0) == 31;\n                        $481 = $$0360$i >>> 1;\n                        $482 = 25 - $481 | 0;\n                        $483 = $480 ? 0 : $482;\n                        $484 = $$4349$lcssa$i << $483;\n                        $$034217$i = $484;\n                        $$034316$i = $475;\n\n                        while (1) {\n                          $491 = $$034217$i >>> 31;\n                          $492 = ($$034316$i + 16 | 0) + ($491 << 2) | 0;\n                          $487 = HEAP32[$492 >> 2] | 0;\n                          $493 = ($487 | 0) == (0 | 0);\n\n                          if ($493) {\n                            break;\n                          }\n\n                          $485 = $$034217$i << 1;\n                          $486 = $487 + 4 | 0;\n                          $488 = HEAP32[$486 >> 2] | 0;\n                          $489 = $488 & -8;\n                          $490 = ($489 | 0) == ($$4349$lcssa$i | 0);\n\n                          if ($490) {\n                            $$0343$lcssa$i = $487;\n                            break L218;\n                          } else {\n                            $$034217$i = $485;\n                            $$034316$i = $487;\n                          }\n                        }\n\n                        $494 = HEAP32[329616 >> 2] | 0;\n                        $495 = $494 >>> 0 > $492 >>> 0;\n\n                        if ($495) {\n                          _abort(); // unreachable;\n\n                        } else {\n                          HEAP32[$492 >> 2] = $348;\n                          $496 = $348 + 24 | 0;\n                          HEAP32[$496 >> 2] = $$034316$i;\n                          $497 = $348 + 12 | 0;\n                          HEAP32[$497 >> 2] = $348;\n                          $498 = $348 + 8 | 0;\n                          HEAP32[$498 >> 2] = $348;\n                          break L200;\n                        }\n                      }\n                    } while (0);\n\n                    $499 = $$0343$lcssa$i + 8 | 0;\n                    $500 = HEAP32[$499 >> 2] | 0;\n                    $501 = HEAP32[329616 >> 2] | 0;\n                    $502 = $501 >>> 0 <= $$0343$lcssa$i >>> 0;\n                    $503 = $501 >>> 0 <= $500 >>> 0;\n                    $504 = $503 & $502;\n\n                    if ($504) {\n                      $505 = $500 + 12 | 0;\n                      HEAP32[$505 >> 2] = $348;\n                      HEAP32[$499 >> 2] = $348;\n                      $506 = $348 + 8 | 0;\n                      HEAP32[$506 >> 2] = $500;\n                      $507 = $348 + 12 | 0;\n                      HEAP32[$507 >> 2] = $$0343$lcssa$i;\n                      $508 = $348 + 24 | 0;\n                      HEAP32[$508 >> 2] = 0;\n                      break;\n                    } else {\n                      _abort(); // unreachable;\n\n                    }\n                  }\n                } while (0);\n\n                $509 = $$4$lcssa$i + 8 | 0;\n                $$0 = $509;\n                STACKTOP = sp;\n                return $$0 | 0;\n              } else {\n                $$0197 = $246;\n              }\n            }\n          }\n        }\n      }\n    } while (0);\n\n    $510 = HEAP32[329608 >> 2] | 0;\n    $511 = $510 >>> 0 < $$0197 >>> 0;\n\n    if (!$511) {\n      $512 = $510 - $$0197 | 0;\n      $513 = HEAP32[329620 >> 2] | 0;\n      $514 = $512 >>> 0 > 15;\n\n      if ($514) {\n        $515 = $513 + $$0197 | 0;\n        HEAP32[329620 >> 2] = $515;\n        HEAP32[329608 >> 2] = $512;\n        $516 = $512 | 1;\n        $517 = $515 + 4 | 0;\n        HEAP32[$517 >> 2] = $516;\n        $518 = $513 + $510 | 0;\n        HEAP32[$518 >> 2] = $512;\n        $519 = $$0197 | 3;\n        $520 = $513 + 4 | 0;\n        HEAP32[$520 >> 2] = $519;\n      } else {\n        HEAP32[329608 >> 2] = 0;\n        HEAP32[329620 >> 2] = 0;\n        $521 = $510 | 3;\n        $522 = $513 + 4 | 0;\n        HEAP32[$522 >> 2] = $521;\n        $523 = $513 + $510 | 0;\n        $524 = $523 + 4 | 0;\n        $525 = HEAP32[$524 >> 2] | 0;\n        $526 = $525 | 1;\n        HEAP32[$524 >> 2] = $526;\n      }\n\n      $527 = $513 + 8 | 0;\n      $$0 = $527;\n      STACKTOP = sp;\n      return $$0 | 0;\n    }\n\n    $528 = HEAP32[329612 >> 2] | 0;\n    $529 = $528 >>> 0 > $$0197 >>> 0;\n\n    if ($529) {\n      $530 = $528 - $$0197 | 0;\n      HEAP32[329612 >> 2] = $530;\n      $531 = HEAP32[329624 >> 2] | 0;\n      $532 = $531 + $$0197 | 0;\n      HEAP32[329624 >> 2] = $532;\n      $533 = $530 | 1;\n      $534 = $532 + 4 | 0;\n      HEAP32[$534 >> 2] = $533;\n      $535 = $$0197 | 3;\n      $536 = $531 + 4 | 0;\n      HEAP32[$536 >> 2] = $535;\n      $537 = $531 + 8 | 0;\n      $$0 = $537;\n      STACKTOP = sp;\n      return $$0 | 0;\n    }\n\n    $538 = HEAP32[82518] | 0;\n    $539 = ($538 | 0) == 0;\n\n    if ($539) {\n      HEAP32[330080 >> 2] = 4096;\n      HEAP32[330076 >> 2] = 4096;\n      HEAP32[330084 >> 2] = -1;\n      HEAP32[330088 >> 2] = -1;\n      HEAP32[330092 >> 2] = 0;\n      HEAP32[330044 >> 2] = 0;\n      $540 = $1;\n      $541 = $540 & -16;\n      $542 = $541 ^ 1431655768;\n      HEAP32[82518] = $542;\n      $546 = 4096;\n    } else {\n      $$pre$i210 = HEAP32[330080 >> 2] | 0;\n      $546 = $$pre$i210;\n    }\n\n    $543 = $$0197 + 48 | 0;\n    $544 = $$0197 + 47 | 0;\n    $545 = $546 + $544 | 0;\n    $547 = 0 - $546 | 0;\n    $548 = $545 & $547;\n    $549 = $548 >>> 0 > $$0197 >>> 0;\n\n    if (!$549) {\n      $$0 = 0;\n      STACKTOP = sp;\n      return $$0 | 0;\n    }\n\n    $550 = HEAP32[330040 >> 2] | 0;\n    $551 = ($550 | 0) == 0;\n\n    if (!$551) {\n      $552 = HEAP32[330032 >> 2] | 0;\n      $553 = $552 + $548 | 0;\n      $554 = $553 >>> 0 <= $552 >>> 0;\n      $555 = $553 >>> 0 > $550 >>> 0;\n      $or$cond1$i = $554 | $555;\n\n      if ($or$cond1$i) {\n        $$0 = 0;\n        STACKTOP = sp;\n        return $$0 | 0;\n      }\n    }\n\n    $556 = HEAP32[330044 >> 2] | 0;\n    $557 = $556 & 4;\n    $558 = ($557 | 0) == 0;\n\n    L257: do {\n      if ($558) {\n        $559 = HEAP32[329624 >> 2] | 0;\n        $560 = ($559 | 0) == (0 | 0);\n\n        L259: do {\n          if ($560) {\n            label = 173;\n          } else {\n            $$0$i$i = 330048;\n\n            while (1) {\n              $561 = HEAP32[$$0$i$i >> 2] | 0;\n              $562 = $561 >>> 0 > $559 >>> 0;\n\n              if (!$562) {\n                $563 = $$0$i$i + 4 | 0;\n                $564 = HEAP32[$563 >> 2] | 0;\n                $565 = $561 + $564 | 0;\n                $566 = $565 >>> 0 > $559 >>> 0;\n\n                if ($566) {\n                  break;\n                }\n              }\n\n              $567 = $$0$i$i + 8 | 0;\n              $568 = HEAP32[$567 >> 2] | 0;\n              $569 = ($568 | 0) == (0 | 0);\n\n              if ($569) {\n                label = 173;\n                break L259;\n              } else {\n                $$0$i$i = $568;\n              }\n            }\n\n            $592 = $545 - $528 | 0;\n            $593 = $592 & $547;\n            $594 = $593 >>> 0 < 2147483647;\n\n            if ($594) {\n              $595 = $$0$i$i + 4 | 0;\n              $596 = _sbrk($593 | 0) | 0;\n              $597 = HEAP32[$$0$i$i >> 2] | 0;\n              $598 = HEAP32[$595 >> 2] | 0;\n              $599 = $597 + $598 | 0;\n              $600 = ($596 | 0) == ($599 | 0);\n\n              if ($600) {\n                $601 = ($596 | 0) == (-1 | 0);\n\n                if ($601) {\n                  $$2234243136$i = $593;\n                } else {\n                  $$723947$i = $593;\n                  $$748$i = $596;\n                  label = 190;\n                  break L257;\n                }\n              } else {\n                $$2247$ph$i = $596;\n                $$2253$ph$i = $593;\n                label = 181;\n              }\n            } else {\n              $$2234243136$i = 0;\n            }\n          }\n        } while (0);\n\n        do {\n          if ((label | 0) == 173) {\n            $570 = _sbrk(0) | 0;\n            $571 = ($570 | 0) == (-1 | 0);\n\n            if ($571) {\n              $$2234243136$i = 0;\n            } else {\n              $572 = $570;\n              $573 = HEAP32[330076 >> 2] | 0;\n              $574 = $573 + -1 | 0;\n              $575 = $574 & $572;\n              $576 = ($575 | 0) == 0;\n              $577 = $574 + $572 | 0;\n              $578 = 0 - $573 | 0;\n              $579 = $577 & $578;\n              $580 = $579 - $572 | 0;\n              $581 = $576 ? 0 : $580;\n              $spec$select49$i = $581 + $548 | 0;\n              $582 = HEAP32[330032 >> 2] | 0;\n              $583 = $spec$select49$i + $582 | 0;\n              $584 = $spec$select49$i >>> 0 > $$0197 >>> 0;\n              $585 = $spec$select49$i >>> 0 < 2147483647;\n              $or$cond$i213 = $584 & $585;\n\n              if ($or$cond$i213) {\n                $586 = HEAP32[330040 >> 2] | 0;\n                $587 = ($586 | 0) == 0;\n\n                if (!$587) {\n                  $588 = $583 >>> 0 <= $582 >>> 0;\n                  $589 = $583 >>> 0 > $586 >>> 0;\n                  $or$cond2$i214 = $588 | $589;\n\n                  if ($or$cond2$i214) {\n                    $$2234243136$i = 0;\n                    break;\n                  }\n                }\n\n                $590 = _sbrk($spec$select49$i | 0) | 0;\n                $591 = ($590 | 0) == ($570 | 0);\n\n                if ($591) {\n                  $$723947$i = $spec$select49$i;\n                  $$748$i = $570;\n                  label = 190;\n                  break L257;\n                } else {\n                  $$2247$ph$i = $590;\n                  $$2253$ph$i = $spec$select49$i;\n                  label = 181;\n                }\n              } else {\n                $$2234243136$i = 0;\n              }\n            }\n          }\n        } while (0);\n\n        do {\n          if ((label | 0) == 181) {\n            $602 = 0 - $$2253$ph$i | 0;\n            $603 = ($$2247$ph$i | 0) != (-1 | 0);\n            $604 = $$2253$ph$i >>> 0 < 2147483647;\n            $or$cond7$i = $604 & $603;\n            $605 = $543 >>> 0 > $$2253$ph$i >>> 0;\n            $or$cond6$i = $605 & $or$cond7$i;\n\n            if (!$or$cond6$i) {\n              $615 = ($$2247$ph$i | 0) == (-1 | 0);\n\n              if ($615) {\n                $$2234243136$i = 0;\n                break;\n              } else {\n                $$723947$i = $$2253$ph$i;\n                $$748$i = $$2247$ph$i;\n                label = 190;\n                break L257;\n              }\n            }\n\n            $606 = HEAP32[330080 >> 2] | 0;\n            $607 = $544 - $$2253$ph$i | 0;\n            $608 = $607 + $606 | 0;\n            $609 = 0 - $606 | 0;\n            $610 = $608 & $609;\n            $611 = $610 >>> 0 < 2147483647;\n\n            if (!$611) {\n              $$723947$i = $$2253$ph$i;\n              $$748$i = $$2247$ph$i;\n              label = 190;\n              break L257;\n            }\n\n            $612 = _sbrk($610 | 0) | 0;\n            $613 = ($612 | 0) == (-1 | 0);\n\n            if ($613) {\n              _sbrk($602 | 0) | 0;\n              $$2234243136$i = 0;\n              break;\n            } else {\n              $614 = $610 + $$2253$ph$i | 0;\n              $$723947$i = $614;\n              $$748$i = $$2247$ph$i;\n              label = 190;\n              break L257;\n            }\n          }\n        } while (0);\n\n        $616 = HEAP32[330044 >> 2] | 0;\n        $617 = $616 | 4;\n        HEAP32[330044 >> 2] = $617;\n        $$4236$i = $$2234243136$i;\n        label = 188;\n      } else {\n        $$4236$i = 0;\n        label = 188;\n      }\n    } while (0);\n\n    if ((label | 0) == 188) {\n      $618 = $548 >>> 0 < 2147483647;\n\n      if ($618) {\n        $619 = _sbrk($548 | 0) | 0;\n        $620 = _sbrk(0) | 0;\n        $621 = ($619 | 0) != (-1 | 0);\n        $622 = ($620 | 0) != (-1 | 0);\n        $or$cond5$i = $621 & $622;\n        $623 = $619 >>> 0 < $620 >>> 0;\n        $or$cond8$i = $623 & $or$cond5$i;\n        $624 = $620;\n        $625 = $619;\n        $626 = $624 - $625 | 0;\n        $627 = $$0197 + 40 | 0;\n        $628 = $626 >>> 0 > $627 >>> 0;\n        $spec$select9$i = $628 ? $626 : $$4236$i;\n        $or$cond8$not$i = $or$cond8$i ^ 1;\n        $629 = ($619 | 0) == (-1 | 0);\n        $not$$i = $628 ^ 1;\n        $630 = $629 | $not$$i;\n        $or$cond50$i = $630 | $or$cond8$not$i;\n\n        if (!$or$cond50$i) {\n          $$723947$i = $spec$select9$i;\n          $$748$i = $619;\n          label = 190;\n        }\n      }\n    }\n\n    if ((label | 0) == 190) {\n      $631 = HEAP32[330032 >> 2] | 0;\n      $632 = $631 + $$723947$i | 0;\n      HEAP32[330032 >> 2] = $632;\n      $633 = HEAP32[330036 >> 2] | 0;\n      $634 = $632 >>> 0 > $633 >>> 0;\n\n      if ($634) {\n        HEAP32[330036 >> 2] = $632;\n      }\n\n      $635 = HEAP32[329624 >> 2] | 0;\n      $636 = ($635 | 0) == (0 | 0);\n\n      L294: do {\n        if ($636) {\n          $637 = HEAP32[329616 >> 2] | 0;\n          $638 = ($637 | 0) == (0 | 0);\n          $639 = $$748$i >>> 0 < $637 >>> 0;\n          $or$cond11$i = $638 | $639;\n\n          if ($or$cond11$i) {\n            HEAP32[329616 >> 2] = $$748$i;\n          }\n\n          HEAP32[330048 >> 2] = $$748$i;\n          HEAP32[330052 >> 2] = $$723947$i;\n          HEAP32[330060 >> 2] = 0;\n          $640 = HEAP32[82518] | 0;\n          HEAP32[329636 >> 2] = $640;\n          HEAP32[329632 >> 2] = -1;\n          HEAP32[329652 >> 2] = 329640;\n          HEAP32[329648 >> 2] = 329640;\n          HEAP32[329660 >> 2] = 329648;\n          HEAP32[329656 >> 2] = 329648;\n          HEAP32[329668 >> 2] = 329656;\n          HEAP32[329664 >> 2] = 329656;\n          HEAP32[329676 >> 2] = 329664;\n          HEAP32[329672 >> 2] = 329664;\n          HEAP32[329684 >> 2] = 329672;\n          HEAP32[329680 >> 2] = 329672;\n          HEAP32[329692 >> 2] = 329680;\n          HEAP32[329688 >> 2] = 329680;\n          HEAP32[329700 >> 2] = 329688;\n          HEAP32[329696 >> 2] = 329688;\n          HEAP32[329708 >> 2] = 329696;\n          HEAP32[329704 >> 2] = 329696;\n          HEAP32[329716 >> 2] = 329704;\n          HEAP32[329712 >> 2] = 329704;\n          HEAP32[329724 >> 2] = 329712;\n          HEAP32[329720 >> 2] = 329712;\n          HEAP32[329732 >> 2] = 329720;\n          HEAP32[329728 >> 2] = 329720;\n          HEAP32[329740 >> 2] = 329728;\n          HEAP32[329736 >> 2] = 329728;\n          HEAP32[329748 >> 2] = 329736;\n          HEAP32[329744 >> 2] = 329736;\n          HEAP32[329756 >> 2] = 329744;\n          HEAP32[329752 >> 2] = 329744;\n          HEAP32[329764 >> 2] = 329752;\n          HEAP32[329760 >> 2] = 329752;\n          HEAP32[329772 >> 2] = 329760;\n          HEAP32[329768 >> 2] = 329760;\n          HEAP32[329780 >> 2] = 329768;\n          HEAP32[329776 >> 2] = 329768;\n          HEAP32[329788 >> 2] = 329776;\n          HEAP32[329784 >> 2] = 329776;\n          HEAP32[329796 >> 2] = 329784;\n          HEAP32[329792 >> 2] = 329784;\n          HEAP32[329804 >> 2] = 329792;\n          HEAP32[329800 >> 2] = 329792;\n          HEAP32[329812 >> 2] = 329800;\n          HEAP32[329808 >> 2] = 329800;\n          HEAP32[329820 >> 2] = 329808;\n          HEAP32[329816 >> 2] = 329808;\n          HEAP32[329828 >> 2] = 329816;\n          HEAP32[329824 >> 2] = 329816;\n          HEAP32[329836 >> 2] = 329824;\n          HEAP32[329832 >> 2] = 329824;\n          HEAP32[329844 >> 2] = 329832;\n          HEAP32[329840 >> 2] = 329832;\n          HEAP32[329852 >> 2] = 329840;\n          HEAP32[329848 >> 2] = 329840;\n          HEAP32[329860 >> 2] = 329848;\n          HEAP32[329856 >> 2] = 329848;\n          HEAP32[329868 >> 2] = 329856;\n          HEAP32[329864 >> 2] = 329856;\n          HEAP32[329876 >> 2] = 329864;\n          HEAP32[329872 >> 2] = 329864;\n          HEAP32[329884 >> 2] = 329872;\n          HEAP32[329880 >> 2] = 329872;\n          HEAP32[329892 >> 2] = 329880;\n          HEAP32[329888 >> 2] = 329880;\n          HEAP32[329900 >> 2] = 329888;\n          HEAP32[329896 >> 2] = 329888;\n          $641 = $$723947$i + -40 | 0;\n          $642 = $$748$i + 8 | 0;\n          $643 = $642;\n          $644 = $643 & 7;\n          $645 = ($644 | 0) == 0;\n          $646 = 0 - $643 | 0;\n          $647 = $646 & 7;\n          $648 = $645 ? 0 : $647;\n          $649 = $$748$i + $648 | 0;\n          $650 = $641 - $648 | 0;\n          HEAP32[329624 >> 2] = $649;\n          HEAP32[329612 >> 2] = $650;\n          $651 = $650 | 1;\n          $652 = $649 + 4 | 0;\n          HEAP32[$652 >> 2] = $651;\n          $653 = $$748$i + $641 | 0;\n          $654 = $653 + 4 | 0;\n          HEAP32[$654 >> 2] = 40;\n          $655 = HEAP32[330088 >> 2] | 0;\n          HEAP32[329628 >> 2] = $655;\n        } else {\n          $$024372$i = 330048;\n\n          while (1) {\n            $656 = HEAP32[$$024372$i >> 2] | 0;\n            $657 = $$024372$i + 4 | 0;\n            $658 = HEAP32[$657 >> 2] | 0;\n            $659 = $656 + $658 | 0;\n            $660 = ($$748$i | 0) == ($659 | 0);\n\n            if ($660) {\n              label = 199;\n              break;\n            }\n\n            $661 = $$024372$i + 8 | 0;\n            $662 = HEAP32[$661 >> 2] | 0;\n            $663 = ($662 | 0) == (0 | 0);\n\n            if ($663) {\n              break;\n            } else {\n              $$024372$i = $662;\n            }\n          }\n\n          if ((label | 0) == 199) {\n            $664 = $$024372$i + 4 | 0;\n            $665 = $$024372$i + 12 | 0;\n            $666 = HEAP32[$665 >> 2] | 0;\n            $667 = $666 & 8;\n            $668 = ($667 | 0) == 0;\n\n            if ($668) {\n              $669 = $656 >>> 0 <= $635 >>> 0;\n              $670 = $$748$i >>> 0 > $635 >>> 0;\n              $or$cond51$i = $670 & $669;\n\n              if ($or$cond51$i) {\n                $671 = $658 + $$723947$i | 0;\n                HEAP32[$664 >> 2] = $671;\n                $672 = HEAP32[329612 >> 2] | 0;\n                $673 = $672 + $$723947$i | 0;\n                $674 = $635 + 8 | 0;\n                $675 = $674;\n                $676 = $675 & 7;\n                $677 = ($676 | 0) == 0;\n                $678 = 0 - $675 | 0;\n                $679 = $678 & 7;\n                $680 = $677 ? 0 : $679;\n                $681 = $635 + $680 | 0;\n                $682 = $673 - $680 | 0;\n                HEAP32[329624 >> 2] = $681;\n                HEAP32[329612 >> 2] = $682;\n                $683 = $682 | 1;\n                $684 = $681 + 4 | 0;\n                HEAP32[$684 >> 2] = $683;\n                $685 = $635 + $673 | 0;\n                $686 = $685 + 4 | 0;\n                HEAP32[$686 >> 2] = 40;\n                $687 = HEAP32[330088 >> 2] | 0;\n                HEAP32[329628 >> 2] = $687;\n                break;\n              }\n            }\n          }\n\n          $688 = HEAP32[329616 >> 2] | 0;\n          $689 = $$748$i >>> 0 < $688 >>> 0;\n\n          if ($689) {\n            HEAP32[329616 >> 2] = $$748$i;\n            $753 = $$748$i;\n          } else {\n            $753 = $688;\n          }\n\n          $690 = $$748$i + $$723947$i | 0;\n          $$124471$i = 330048;\n\n          while (1) {\n            $691 = HEAP32[$$124471$i >> 2] | 0;\n            $692 = ($691 | 0) == ($690 | 0);\n\n            if ($692) {\n              label = 207;\n              break;\n            }\n\n            $693 = $$124471$i + 8 | 0;\n            $694 = HEAP32[$693 >> 2] | 0;\n            $695 = ($694 | 0) == (0 | 0);\n\n            if ($695) {\n              break;\n            } else {\n              $$124471$i = $694;\n            }\n          }\n\n          if ((label | 0) == 207) {\n            $696 = $$124471$i + 12 | 0;\n            $697 = HEAP32[$696 >> 2] | 0;\n            $698 = $697 & 8;\n            $699 = ($698 | 0) == 0;\n\n            if ($699) {\n              HEAP32[$$124471$i >> 2] = $$748$i;\n              $700 = $$124471$i + 4 | 0;\n              $701 = HEAP32[$700 >> 2] | 0;\n              $702 = $701 + $$723947$i | 0;\n              HEAP32[$700 >> 2] = $702;\n              $703 = $$748$i + 8 | 0;\n              $704 = $703;\n              $705 = $704 & 7;\n              $706 = ($705 | 0) == 0;\n              $707 = 0 - $704 | 0;\n              $708 = $707 & 7;\n              $709 = $706 ? 0 : $708;\n              $710 = $$748$i + $709 | 0;\n              $711 = $690 + 8 | 0;\n              $712 = $711;\n              $713 = $712 & 7;\n              $714 = ($713 | 0) == 0;\n              $715 = 0 - $712 | 0;\n              $716 = $715 & 7;\n              $717 = $714 ? 0 : $716;\n              $718 = $690 + $717 | 0;\n              $719 = $718;\n              $720 = $710;\n              $721 = $719 - $720 | 0;\n              $722 = $710 + $$0197 | 0;\n              $723 = $721 - $$0197 | 0;\n              $724 = $$0197 | 3;\n              $725 = $710 + 4 | 0;\n              HEAP32[$725 >> 2] = $724;\n              $726 = ($635 | 0) == ($718 | 0);\n\n              L317: do {\n                if ($726) {\n                  $727 = HEAP32[329612 >> 2] | 0;\n                  $728 = $727 + $723 | 0;\n                  HEAP32[329612 >> 2] = $728;\n                  HEAP32[329624 >> 2] = $722;\n                  $729 = $728 | 1;\n                  $730 = $722 + 4 | 0;\n                  HEAP32[$730 >> 2] = $729;\n                } else {\n                  $731 = HEAP32[329620 >> 2] | 0;\n                  $732 = ($731 | 0) == ($718 | 0);\n\n                  if ($732) {\n                    $733 = HEAP32[329608 >> 2] | 0;\n                    $734 = $733 + $723 | 0;\n                    HEAP32[329608 >> 2] = $734;\n                    HEAP32[329620 >> 2] = $722;\n                    $735 = $734 | 1;\n                    $736 = $722 + 4 | 0;\n                    HEAP32[$736 >> 2] = $735;\n                    $737 = $722 + $734 | 0;\n                    HEAP32[$737 >> 2] = $734;\n                    break;\n                  }\n\n                  $738 = $718 + 4 | 0;\n                  $739 = HEAP32[$738 >> 2] | 0;\n                  $740 = $739 & 3;\n                  $741 = ($740 | 0) == 1;\n\n                  if ($741) {\n                    $742 = $739 & -8;\n                    $743 = $739 >>> 3;\n                    $744 = $739 >>> 0 < 256;\n\n                    L325: do {\n                      if ($744) {\n                        $745 = $718 + 8 | 0;\n                        $746 = HEAP32[$745 >> 2] | 0;\n                        $747 = $718 + 12 | 0;\n                        $748 = HEAP32[$747 >> 2] | 0;\n                        $749 = $743 << 1;\n                        $750 = 329640 + ($749 << 2) | 0;\n                        $751 = ($746 | 0) == ($750 | 0);\n\n                        do {\n                          if (!$751) {\n                            $752 = $753 >>> 0 > $746 >>> 0;\n\n                            if ($752) {\n                              _abort(); // unreachable;\n\n                            }\n\n                            $754 = $746 + 12 | 0;\n                            $755 = HEAP32[$754 >> 2] | 0;\n                            $756 = ($755 | 0) == ($718 | 0);\n\n                            if ($756) {\n                              break;\n                            }\n\n                            _abort(); // unreachable;\n\n                          }\n                        } while (0);\n\n                        $757 = ($748 | 0) == ($746 | 0);\n\n                        if ($757) {\n                          $758 = 1 << $743;\n                          $759 = $758 ^ -1;\n                          $760 = HEAP32[82400] | 0;\n                          $761 = $760 & $759;\n                          HEAP32[82400] = $761;\n                          break;\n                        }\n\n                        $762 = ($748 | 0) == ($750 | 0);\n\n                        do {\n                          if ($762) {\n                            $$pre16$i$i = $748 + 8 | 0;\n                            $$pre$phi17$i$iZ2D = $$pre16$i$i;\n                          } else {\n                            $763 = $753 >>> 0 > $748 >>> 0;\n\n                            if ($763) {\n                              _abort(); // unreachable;\n\n                            }\n\n                            $764 = $748 + 8 | 0;\n                            $765 = HEAP32[$764 >> 2] | 0;\n                            $766 = ($765 | 0) == ($718 | 0);\n\n                            if ($766) {\n                              $$pre$phi17$i$iZ2D = $764;\n                              break;\n                            }\n\n                            _abort(); // unreachable;\n\n                          }\n                        } while (0);\n\n                        $767 = $746 + 12 | 0;\n                        HEAP32[$767 >> 2] = $748;\n                        HEAP32[$$pre$phi17$i$iZ2D >> 2] = $746;\n                      } else {\n                        $768 = $718 + 24 | 0;\n                        $769 = HEAP32[$768 >> 2] | 0;\n                        $770 = $718 + 12 | 0;\n                        $771 = HEAP32[$770 >> 2] | 0;\n                        $772 = ($771 | 0) == ($718 | 0);\n\n                        do {\n                          if ($772) {\n                            $782 = $718 + 16 | 0;\n                            $783 = $782 + 4 | 0;\n                            $784 = HEAP32[$783 >> 2] | 0;\n                            $785 = ($784 | 0) == (0 | 0);\n\n                            if ($785) {\n                              $786 = HEAP32[$782 >> 2] | 0;\n                              $787 = ($786 | 0) == (0 | 0);\n\n                              if ($787) {\n                                $$3$i$i = 0;\n                                break;\n                              } else {\n                                $$1290$i$i$ph = $786;\n                                $$1292$i$i$ph = $782;\n                              }\n                            } else {\n                              $$1290$i$i$ph = $784;\n                              $$1292$i$i$ph = $783;\n                            }\n\n                            $$1290$i$i = $$1290$i$i$ph;\n                            $$1292$i$i = $$1292$i$i$ph;\n\n                            while (1) {\n                              $788 = $$1290$i$i + 20 | 0;\n                              $789 = HEAP32[$788 >> 2] | 0;\n                              $790 = ($789 | 0) == (0 | 0);\n\n                              if ($790) {\n                                $791 = $$1290$i$i + 16 | 0;\n                                $792 = HEAP32[$791 >> 2] | 0;\n                                $793 = ($792 | 0) == (0 | 0);\n\n                                if ($793) {\n                                  break;\n                                } else {\n                                  $$1290$i$i$be = $792;\n                                  $$1292$i$i$be = $791;\n                                }\n                              } else {\n                                $$1290$i$i$be = $789;\n                                $$1292$i$i$be = $788;\n                              }\n\n                              $$1290$i$i = $$1290$i$i$be;\n                              $$1292$i$i = $$1292$i$i$be;\n                            }\n\n                            $794 = $753 >>> 0 > $$1292$i$i >>> 0;\n\n                            if ($794) {\n                              _abort(); // unreachable;\n\n                            } else {\n                              HEAP32[$$1292$i$i >> 2] = 0;\n                              $$3$i$i = $$1290$i$i;\n                              break;\n                            }\n                          } else {\n                            $773 = $718 + 8 | 0;\n                            $774 = HEAP32[$773 >> 2] | 0;\n                            $775 = $753 >>> 0 > $774 >>> 0;\n\n                            if ($775) {\n                              _abort(); // unreachable;\n\n                            }\n\n                            $776 = $774 + 12 | 0;\n                            $777 = HEAP32[$776 >> 2] | 0;\n                            $778 = ($777 | 0) == ($718 | 0);\n\n                            if (!$778) {\n                              _abort(); // unreachable;\n\n                            }\n\n                            $779 = $771 + 8 | 0;\n                            $780 = HEAP32[$779 >> 2] | 0;\n                            $781 = ($780 | 0) == ($718 | 0);\n\n                            if ($781) {\n                              HEAP32[$776 >> 2] = $771;\n                              HEAP32[$779 >> 2] = $774;\n                              $$3$i$i = $771;\n                              break;\n                            } else {\n                              _abort(); // unreachable;\n\n                            }\n                          }\n                        } while (0);\n\n                        $795 = ($769 | 0) == (0 | 0);\n\n                        if ($795) {\n                          break;\n                        }\n\n                        $796 = $718 + 28 | 0;\n                        $797 = HEAP32[$796 >> 2] | 0;\n                        $798 = 329904 + ($797 << 2) | 0;\n                        $799 = HEAP32[$798 >> 2] | 0;\n                        $800 = ($799 | 0) == ($718 | 0);\n\n                        do {\n                          if ($800) {\n                            HEAP32[$798 >> 2] = $$3$i$i;\n                            $cond$i$i = ($$3$i$i | 0) == (0 | 0);\n\n                            if (!$cond$i$i) {\n                              break;\n                            }\n\n                            $801 = 1 << $797;\n                            $802 = $801 ^ -1;\n                            $803 = HEAP32[329604 >> 2] | 0;\n                            $804 = $803 & $802;\n                            HEAP32[329604 >> 2] = $804;\n                            break L325;\n                          } else {\n                            $805 = HEAP32[329616 >> 2] | 0;\n                            $806 = $805 >>> 0 > $769 >>> 0;\n\n                            if ($806) {\n                              _abort(); // unreachable;\n\n                            } else {\n                              $807 = $769 + 16 | 0;\n                              $808 = HEAP32[$807 >> 2] | 0;\n                              $809 = ($808 | 0) == ($718 | 0);\n                              $810 = $769 + 20 | 0;\n                              $$sink326 = $809 ? $807 : $810;\n                              HEAP32[$$sink326 >> 2] = $$3$i$i;\n                              $811 = ($$3$i$i | 0) == (0 | 0);\n\n                              if ($811) {\n                                break L325;\n                              } else {\n                                break;\n                              }\n                            }\n                          }\n                        } while (0);\n\n                        $812 = HEAP32[329616 >> 2] | 0;\n                        $813 = $812 >>> 0 > $$3$i$i >>> 0;\n\n                        if ($813) {\n                          _abort(); // unreachable;\n\n                        }\n\n                        $814 = $$3$i$i + 24 | 0;\n                        HEAP32[$814 >> 2] = $769;\n                        $815 = $718 + 16 | 0;\n                        $816 = HEAP32[$815 >> 2] | 0;\n                        $817 = ($816 | 0) == (0 | 0);\n\n                        do {\n                          if (!$817) {\n                            $818 = $812 >>> 0 > $816 >>> 0;\n\n                            if ($818) {\n                              _abort(); // unreachable;\n\n                            } else {\n                              $819 = $$3$i$i + 16 | 0;\n                              HEAP32[$819 >> 2] = $816;\n                              $820 = $816 + 24 | 0;\n                              HEAP32[$820 >> 2] = $$3$i$i;\n                              break;\n                            }\n                          }\n                        } while (0);\n\n                        $821 = $815 + 4 | 0;\n                        $822 = HEAP32[$821 >> 2] | 0;\n                        $823 = ($822 | 0) == (0 | 0);\n\n                        if ($823) {\n                          break;\n                        }\n\n                        $824 = HEAP32[329616 >> 2] | 0;\n                        $825 = $824 >>> 0 > $822 >>> 0;\n\n                        if ($825) {\n                          _abort(); // unreachable;\n\n                        } else {\n                          $826 = $$3$i$i + 20 | 0;\n                          HEAP32[$826 >> 2] = $822;\n                          $827 = $822 + 24 | 0;\n                          HEAP32[$827 >> 2] = $$3$i$i;\n                          break;\n                        }\n                      }\n                    } while (0);\n\n                    $828 = $718 + $742 | 0;\n                    $829 = $742 + $723 | 0;\n                    $$0$i16$i = $828;\n                    $$0286$i$i = $829;\n                  } else {\n                    $$0$i16$i = $718;\n                    $$0286$i$i = $723;\n                  }\n\n                  $830 = $$0$i16$i + 4 | 0;\n                  $831 = HEAP32[$830 >> 2] | 0;\n                  $832 = $831 & -2;\n                  HEAP32[$830 >> 2] = $832;\n                  $833 = $$0286$i$i | 1;\n                  $834 = $722 + 4 | 0;\n                  HEAP32[$834 >> 2] = $833;\n                  $835 = $722 + $$0286$i$i | 0;\n                  HEAP32[$835 >> 2] = $$0286$i$i;\n                  $836 = $$0286$i$i >>> 3;\n                  $837 = $$0286$i$i >>> 0 < 256;\n\n                  if ($837) {\n                    $838 = $836 << 1;\n                    $839 = 329640 + ($838 << 2) | 0;\n                    $840 = HEAP32[82400] | 0;\n                    $841 = 1 << $836;\n                    $842 = $840 & $841;\n                    $843 = ($842 | 0) == 0;\n\n                    do {\n                      if ($843) {\n                        $844 = $840 | $841;\n                        HEAP32[82400] = $844;\n                        $$pre$i17$i = $839 + 8 | 0;\n                        $$0294$i$i = $839;\n                        $$pre$phi$i18$iZ2D = $$pre$i17$i;\n                      } else {\n                        $845 = $839 + 8 | 0;\n                        $846 = HEAP32[$845 >> 2] | 0;\n                        $847 = HEAP32[329616 >> 2] | 0;\n                        $848 = $847 >>> 0 > $846 >>> 0;\n\n                        if (!$848) {\n                          $$0294$i$i = $846;\n                          $$pre$phi$i18$iZ2D = $845;\n                          break;\n                        }\n\n                        _abort(); // unreachable;\n\n                      }\n                    } while (0);\n\n                    HEAP32[$$pre$phi$i18$iZ2D >> 2] = $722;\n                    $849 = $$0294$i$i + 12 | 0;\n                    HEAP32[$849 >> 2] = $722;\n                    $850 = $722 + 8 | 0;\n                    HEAP32[$850 >> 2] = $$0294$i$i;\n                    $851 = $722 + 12 | 0;\n                    HEAP32[$851 >> 2] = $839;\n                    break;\n                  }\n\n                  $852 = $$0286$i$i >>> 8;\n                  $853 = ($852 | 0) == 0;\n\n                  do {\n                    if ($853) {\n                      $$0295$i$i = 0;\n                    } else {\n                      $854 = $$0286$i$i >>> 0 > 16777215;\n\n                      if ($854) {\n                        $$0295$i$i = 31;\n                        break;\n                      }\n\n                      $855 = $852 + 1048320 | 0;\n                      $856 = $855 >>> 16;\n                      $857 = $856 & 8;\n                      $858 = $852 << $857;\n                      $859 = $858 + 520192 | 0;\n                      $860 = $859 >>> 16;\n                      $861 = $860 & 4;\n                      $862 = $861 | $857;\n                      $863 = $858 << $861;\n                      $864 = $863 + 245760 | 0;\n                      $865 = $864 >>> 16;\n                      $866 = $865 & 2;\n                      $867 = $862 | $866;\n                      $868 = 14 - $867 | 0;\n                      $869 = $863 << $866;\n                      $870 = $869 >>> 15;\n                      $871 = $868 + $870 | 0;\n                      $872 = $871 << 1;\n                      $873 = $871 + 7 | 0;\n                      $874 = $$0286$i$i >>> $873;\n                      $875 = $874 & 1;\n                      $876 = $875 | $872;\n                      $$0295$i$i = $876;\n                    }\n                  } while (0);\n\n                  $877 = 329904 + ($$0295$i$i << 2) | 0;\n                  $878 = $722 + 28 | 0;\n                  HEAP32[$878 >> 2] = $$0295$i$i;\n                  $879 = $722 + 16 | 0;\n                  $880 = $879 + 4 | 0;\n                  HEAP32[$880 >> 2] = 0;\n                  HEAP32[$879 >> 2] = 0;\n                  $881 = HEAP32[329604 >> 2] | 0;\n                  $882 = 1 << $$0295$i$i;\n                  $883 = $881 & $882;\n                  $884 = ($883 | 0) == 0;\n\n                  if ($884) {\n                    $885 = $881 | $882;\n                    HEAP32[329604 >> 2] = $885;\n                    HEAP32[$877 >> 2] = $722;\n                    $886 = $722 + 24 | 0;\n                    HEAP32[$886 >> 2] = $877;\n                    $887 = $722 + 12 | 0;\n                    HEAP32[$887 >> 2] = $722;\n                    $888 = $722 + 8 | 0;\n                    HEAP32[$888 >> 2] = $722;\n                    break;\n                  }\n\n                  $889 = HEAP32[$877 >> 2] | 0;\n                  $890 = $889 + 4 | 0;\n                  $891 = HEAP32[$890 >> 2] | 0;\n                  $892 = $891 & -8;\n                  $893 = ($892 | 0) == ($$0286$i$i | 0);\n\n                  L410: do {\n                    if ($893) {\n                      $$0288$lcssa$i$i = $889;\n                    } else {\n                      $894 = ($$0295$i$i | 0) == 31;\n                      $895 = $$0295$i$i >>> 1;\n                      $896 = 25 - $895 | 0;\n                      $897 = $894 ? 0 : $896;\n                      $898 = $$0286$i$i << $897;\n                      $$028711$i$i = $898;\n                      $$028810$i$i = $889;\n\n                      while (1) {\n                        $905 = $$028711$i$i >>> 31;\n                        $906 = ($$028810$i$i + 16 | 0) + ($905 << 2) | 0;\n                        $901 = HEAP32[$906 >> 2] | 0;\n                        $907 = ($901 | 0) == (0 | 0);\n\n                        if ($907) {\n                          break;\n                        }\n\n                        $899 = $$028711$i$i << 1;\n                        $900 = $901 + 4 | 0;\n                        $902 = HEAP32[$900 >> 2] | 0;\n                        $903 = $902 & -8;\n                        $904 = ($903 | 0) == ($$0286$i$i | 0);\n\n                        if ($904) {\n                          $$0288$lcssa$i$i = $901;\n                          break L410;\n                        } else {\n                          $$028711$i$i = $899;\n                          $$028810$i$i = $901;\n                        }\n                      }\n\n                      $908 = HEAP32[329616 >> 2] | 0;\n                      $909 = $908 >>> 0 > $906 >>> 0;\n\n                      if ($909) {\n                        _abort(); // unreachable;\n\n                      } else {\n                        HEAP32[$906 >> 2] = $722;\n                        $910 = $722 + 24 | 0;\n                        HEAP32[$910 >> 2] = $$028810$i$i;\n                        $911 = $722 + 12 | 0;\n                        HEAP32[$911 >> 2] = $722;\n                        $912 = $722 + 8 | 0;\n                        HEAP32[$912 >> 2] = $722;\n                        break L317;\n                      }\n                    }\n                  } while (0);\n\n                  $913 = $$0288$lcssa$i$i + 8 | 0;\n                  $914 = HEAP32[$913 >> 2] | 0;\n                  $915 = HEAP32[329616 >> 2] | 0;\n                  $916 = $915 >>> 0 <= $$0288$lcssa$i$i >>> 0;\n                  $917 = $915 >>> 0 <= $914 >>> 0;\n                  $918 = $917 & $916;\n\n                  if ($918) {\n                    $919 = $914 + 12 | 0;\n                    HEAP32[$919 >> 2] = $722;\n                    HEAP32[$913 >> 2] = $722;\n                    $920 = $722 + 8 | 0;\n                    HEAP32[$920 >> 2] = $914;\n                    $921 = $722 + 12 | 0;\n                    HEAP32[$921 >> 2] = $$0288$lcssa$i$i;\n                    $922 = $722 + 24 | 0;\n                    HEAP32[$922 >> 2] = 0;\n                    break;\n                  } else {\n                    _abort(); // unreachable;\n\n                  }\n                }\n              } while (0);\n\n              $1059 = $710 + 8 | 0;\n              $$0 = $1059;\n              STACKTOP = sp;\n              return $$0 | 0;\n            }\n          }\n\n          $$0$i$i$i = 330048;\n\n          while (1) {\n            $923 = HEAP32[$$0$i$i$i >> 2] | 0;\n            $924 = $923 >>> 0 > $635 >>> 0;\n\n            if (!$924) {\n              $925 = $$0$i$i$i + 4 | 0;\n              $926 = HEAP32[$925 >> 2] | 0;\n              $927 = $923 + $926 | 0;\n              $928 = $927 >>> 0 > $635 >>> 0;\n\n              if ($928) {\n                break;\n              }\n            }\n\n            $929 = $$0$i$i$i + 8 | 0;\n            $930 = HEAP32[$929 >> 2] | 0;\n            $$0$i$i$i = $930;\n          }\n\n          $931 = $927 + -47 | 0;\n          $932 = $931 + 8 | 0;\n          $933 = $932;\n          $934 = $933 & 7;\n          $935 = ($934 | 0) == 0;\n          $936 = 0 - $933 | 0;\n          $937 = $936 & 7;\n          $938 = $935 ? 0 : $937;\n          $939 = $931 + $938 | 0;\n          $940 = $635 + 16 | 0;\n          $941 = $939 >>> 0 < $940 >>> 0;\n          $942 = $941 ? $635 : $939;\n          $943 = $942 + 8 | 0;\n          $944 = $942 + 24 | 0;\n          $945 = $$723947$i + -40 | 0;\n          $946 = $$748$i + 8 | 0;\n          $947 = $946;\n          $948 = $947 & 7;\n          $949 = ($948 | 0) == 0;\n          $950 = 0 - $947 | 0;\n          $951 = $950 & 7;\n          $952 = $949 ? 0 : $951;\n          $953 = $$748$i + $952 | 0;\n          $954 = $945 - $952 | 0;\n          HEAP32[329624 >> 2] = $953;\n          HEAP32[329612 >> 2] = $954;\n          $955 = $954 | 1;\n          $956 = $953 + 4 | 0;\n          HEAP32[$956 >> 2] = $955;\n          $957 = $$748$i + $945 | 0;\n          $958 = $957 + 4 | 0;\n          HEAP32[$958 >> 2] = 40;\n          $959 = HEAP32[330088 >> 2] | 0;\n          HEAP32[329628 >> 2] = $959;\n          $960 = $942 + 4 | 0;\n          HEAP32[$960 >> 2] = 27;\n          ;\n          HEAP32[$943 >> 2] = HEAP32[330048 >> 2] | 0;\n          HEAP32[$943 + 4 >> 2] = HEAP32[330048 + 4 >> 2] | 0;\n          HEAP32[$943 + 8 >> 2] = HEAP32[330048 + 8 >> 2] | 0;\n          HEAP32[$943 + 12 >> 2] = HEAP32[330048 + 12 >> 2] | 0;\n          HEAP32[330048 >> 2] = $$748$i;\n          HEAP32[330052 >> 2] = $$723947$i;\n          HEAP32[330060 >> 2] = 0;\n          HEAP32[330056 >> 2] = $943;\n          $962 = $944;\n\n          while (1) {\n            $961 = $962 + 4 | 0;\n            HEAP32[$961 >> 2] = 7;\n            $963 = $962 + 8 | 0;\n            $964 = $963 >>> 0 < $927 >>> 0;\n\n            if ($964) {\n              $962 = $961;\n            } else {\n              break;\n            }\n          }\n\n          $965 = ($942 | 0) == ($635 | 0);\n\n          if (!$965) {\n            $966 = $942;\n            $967 = $635;\n            $968 = $966 - $967 | 0;\n            $969 = HEAP32[$960 >> 2] | 0;\n            $970 = $969 & -2;\n            HEAP32[$960 >> 2] = $970;\n            $971 = $968 | 1;\n            $972 = $635 + 4 | 0;\n            HEAP32[$972 >> 2] = $971;\n            HEAP32[$942 >> 2] = $968;\n            $973 = $968 >>> 3;\n            $974 = $968 >>> 0 < 256;\n\n            if ($974) {\n              $975 = $973 << 1;\n              $976 = 329640 + ($975 << 2) | 0;\n              $977 = HEAP32[82400] | 0;\n              $978 = 1 << $973;\n              $979 = $977 & $978;\n              $980 = ($979 | 0) == 0;\n\n              if ($980) {\n                $981 = $977 | $978;\n                HEAP32[82400] = $981;\n                $$pre$i$i = $976 + 8 | 0;\n                $$0211$i$i = $976;\n                $$pre$phi$i$iZ2D = $$pre$i$i;\n              } else {\n                $982 = $976 + 8 | 0;\n                $983 = HEAP32[$982 >> 2] | 0;\n                $984 = HEAP32[329616 >> 2] | 0;\n                $985 = $984 >>> 0 > $983 >>> 0;\n\n                if ($985) {\n                  _abort(); // unreachable;\n\n                } else {\n                  $$0211$i$i = $983;\n                  $$pre$phi$i$iZ2D = $982;\n                }\n              }\n\n              HEAP32[$$pre$phi$i$iZ2D >> 2] = $635;\n              $986 = $$0211$i$i + 12 | 0;\n              HEAP32[$986 >> 2] = $635;\n              $987 = $635 + 8 | 0;\n              HEAP32[$987 >> 2] = $$0211$i$i;\n              $988 = $635 + 12 | 0;\n              HEAP32[$988 >> 2] = $976;\n              break;\n            }\n\n            $989 = $968 >>> 8;\n            $990 = ($989 | 0) == 0;\n\n            if ($990) {\n              $$0212$i$i = 0;\n            } else {\n              $991 = $968 >>> 0 > 16777215;\n\n              if ($991) {\n                $$0212$i$i = 31;\n              } else {\n                $992 = $989 + 1048320 | 0;\n                $993 = $992 >>> 16;\n                $994 = $993 & 8;\n                $995 = $989 << $994;\n                $996 = $995 + 520192 | 0;\n                $997 = $996 >>> 16;\n                $998 = $997 & 4;\n                $999 = $998 | $994;\n                $1000 = $995 << $998;\n                $1001 = $1000 + 245760 | 0;\n                $1002 = $1001 >>> 16;\n                $1003 = $1002 & 2;\n                $1004 = $999 | $1003;\n                $1005 = 14 - $1004 | 0;\n                $1006 = $1000 << $1003;\n                $1007 = $1006 >>> 15;\n                $1008 = $1005 + $1007 | 0;\n                $1009 = $1008 << 1;\n                $1010 = $1008 + 7 | 0;\n                $1011 = $968 >>> $1010;\n                $1012 = $1011 & 1;\n                $1013 = $1012 | $1009;\n                $$0212$i$i = $1013;\n              }\n            }\n\n            $1014 = 329904 + ($$0212$i$i << 2) | 0;\n            $1015 = $635 + 28 | 0;\n            HEAP32[$1015 >> 2] = $$0212$i$i;\n            $1016 = $635 + 20 | 0;\n            HEAP32[$1016 >> 2] = 0;\n            HEAP32[$940 >> 2] = 0;\n            $1017 = HEAP32[329604 >> 2] | 0;\n            $1018 = 1 << $$0212$i$i;\n            $1019 = $1017 & $1018;\n            $1020 = ($1019 | 0) == 0;\n\n            if ($1020) {\n              $1021 = $1017 | $1018;\n              HEAP32[329604 >> 2] = $1021;\n              HEAP32[$1014 >> 2] = $635;\n              $1022 = $635 + 24 | 0;\n              HEAP32[$1022 >> 2] = $1014;\n              $1023 = $635 + 12 | 0;\n              HEAP32[$1023 >> 2] = $635;\n              $1024 = $635 + 8 | 0;\n              HEAP32[$1024 >> 2] = $635;\n              break;\n            }\n\n            $1025 = HEAP32[$1014 >> 2] | 0;\n            $1026 = $1025 + 4 | 0;\n            $1027 = HEAP32[$1026 >> 2] | 0;\n            $1028 = $1027 & -8;\n            $1029 = ($1028 | 0) == ($968 | 0);\n\n            L451: do {\n              if ($1029) {\n                $$0207$lcssa$i$i = $1025;\n              } else {\n                $1030 = ($$0212$i$i | 0) == 31;\n                $1031 = $$0212$i$i >>> 1;\n                $1032 = 25 - $1031 | 0;\n                $1033 = $1030 ? 0 : $1032;\n                $1034 = $968 << $1033;\n                $$02065$i$i = $1034;\n                $$02074$i$i = $1025;\n\n                while (1) {\n                  $1041 = $$02065$i$i >>> 31;\n                  $1042 = ($$02074$i$i + 16 | 0) + ($1041 << 2) | 0;\n                  $1037 = HEAP32[$1042 >> 2] | 0;\n                  $1043 = ($1037 | 0) == (0 | 0);\n\n                  if ($1043) {\n                    break;\n                  }\n\n                  $1035 = $$02065$i$i << 1;\n                  $1036 = $1037 + 4 | 0;\n                  $1038 = HEAP32[$1036 >> 2] | 0;\n                  $1039 = $1038 & -8;\n                  $1040 = ($1039 | 0) == ($968 | 0);\n\n                  if ($1040) {\n                    $$0207$lcssa$i$i = $1037;\n                    break L451;\n                  } else {\n                    $$02065$i$i = $1035;\n                    $$02074$i$i = $1037;\n                  }\n                }\n\n                $1044 = HEAP32[329616 >> 2] | 0;\n                $1045 = $1044 >>> 0 > $1042 >>> 0;\n\n                if ($1045) {\n                  _abort(); // unreachable;\n\n                } else {\n                  HEAP32[$1042 >> 2] = $635;\n                  $1046 = $635 + 24 | 0;\n                  HEAP32[$1046 >> 2] = $$02074$i$i;\n                  $1047 = $635 + 12 | 0;\n                  HEAP32[$1047 >> 2] = $635;\n                  $1048 = $635 + 8 | 0;\n                  HEAP32[$1048 >> 2] = $635;\n                  break L294;\n                }\n              }\n            } while (0);\n\n            $1049 = $$0207$lcssa$i$i + 8 | 0;\n            $1050 = HEAP32[$1049 >> 2] | 0;\n            $1051 = HEAP32[329616 >> 2] | 0;\n            $1052 = $1051 >>> 0 <= $$0207$lcssa$i$i >>> 0;\n            $1053 = $1051 >>> 0 <= $1050 >>> 0;\n            $1054 = $1053 & $1052;\n\n            if ($1054) {\n              $1055 = $1050 + 12 | 0;\n              HEAP32[$1055 >> 2] = $635;\n              HEAP32[$1049 >> 2] = $635;\n              $1056 = $635 + 8 | 0;\n              HEAP32[$1056 >> 2] = $1050;\n              $1057 = $635 + 12 | 0;\n              HEAP32[$1057 >> 2] = $$0207$lcssa$i$i;\n              $1058 = $635 + 24 | 0;\n              HEAP32[$1058 >> 2] = 0;\n              break;\n            } else {\n              _abort(); // unreachable;\n\n            }\n          }\n        }\n      } while (0);\n\n      $1060 = HEAP32[329612 >> 2] | 0;\n      $1061 = $1060 >>> 0 > $$0197 >>> 0;\n\n      if ($1061) {\n        $1062 = $1060 - $$0197 | 0;\n        HEAP32[329612 >> 2] = $1062;\n        $1063 = HEAP32[329624 >> 2] | 0;\n        $1064 = $1063 + $$0197 | 0;\n        HEAP32[329624 >> 2] = $1064;\n        $1065 = $1062 | 1;\n        $1066 = $1064 + 4 | 0;\n        HEAP32[$1066 >> 2] = $1065;\n        $1067 = $$0197 | 3;\n        $1068 = $1063 + 4 | 0;\n        HEAP32[$1068 >> 2] = $1067;\n        $1069 = $1063 + 8 | 0;\n        $$0 = $1069;\n        STACKTOP = sp;\n        return $$0 | 0;\n      }\n    }\n\n    $1070 = ___errno_location() | 0;\n    HEAP32[$1070 >> 2] = 12;\n    $$0 = 0;\n    STACKTOP = sp;\n    return $$0 | 0;\n  }\n\n  function _free($0) {\n    $0 = $0 | 0;\n    var $$0211$i = 0,\n        $$0211$in$i = 0,\n        $$0381438 = 0,\n        $$0382$lcssa = 0,\n        $$0382437 = 0,\n        $$0394 = 0,\n        $$0401 = 0,\n        $$1 = 0,\n        $$1380 = 0,\n        $$1385 = 0,\n        $$1385$be = 0,\n        $$1385$ph = 0,\n        $$1388 = 0,\n        $$1388$be = 0,\n        $$1388$ph = 0,\n        $$1396 = 0,\n        $$1396$be = 0,\n        $$1396$ph = 0,\n        $$1400 = 0,\n        $$1400$be = 0;\n    var $$1400$ph = 0,\n        $$2 = 0,\n        $$3 = 0,\n        $$3398 = 0,\n        $$pre = 0,\n        $$pre$phi444Z2D = 0,\n        $$pre$phi446Z2D = 0,\n        $$pre$phiZ2D = 0,\n        $$pre443 = 0,\n        $$pre445 = 0,\n        $$sink = 0,\n        $$sink456 = 0,\n        $1 = 0,\n        $10 = 0,\n        $100 = 0,\n        $101 = 0,\n        $102 = 0,\n        $103 = 0,\n        $104 = 0,\n        $105 = 0;\n    var $106 = 0,\n        $107 = 0,\n        $108 = 0,\n        $109 = 0,\n        $11 = 0,\n        $110 = 0,\n        $111 = 0,\n        $112 = 0,\n        $113 = 0,\n        $114 = 0,\n        $115 = 0,\n        $116 = 0,\n        $117 = 0,\n        $118 = 0,\n        $119 = 0,\n        $12 = 0,\n        $120 = 0,\n        $121 = 0,\n        $122 = 0,\n        $123 = 0;\n    var $124 = 0,\n        $125 = 0,\n        $126 = 0,\n        $127 = 0,\n        $128 = 0,\n        $129 = 0,\n        $13 = 0,\n        $130 = 0,\n        $131 = 0,\n        $132 = 0,\n        $133 = 0,\n        $134 = 0,\n        $135 = 0,\n        $136 = 0,\n        $137 = 0,\n        $138 = 0,\n        $139 = 0,\n        $14 = 0,\n        $140 = 0,\n        $141 = 0;\n    var $142 = 0,\n        $143 = 0,\n        $144 = 0,\n        $145 = 0,\n        $146 = 0,\n        $147 = 0,\n        $148 = 0,\n        $149 = 0,\n        $15 = 0,\n        $150 = 0,\n        $151 = 0,\n        $152 = 0,\n        $153 = 0,\n        $154 = 0,\n        $155 = 0,\n        $156 = 0,\n        $157 = 0,\n        $158 = 0,\n        $159 = 0,\n        $16 = 0;\n    var $160 = 0,\n        $161 = 0,\n        $162 = 0,\n        $163 = 0,\n        $164 = 0,\n        $165 = 0,\n        $166 = 0,\n        $167 = 0,\n        $168 = 0,\n        $169 = 0,\n        $17 = 0,\n        $170 = 0,\n        $171 = 0,\n        $172 = 0,\n        $173 = 0,\n        $174 = 0,\n        $175 = 0,\n        $176 = 0,\n        $177 = 0,\n        $178 = 0;\n    var $179 = 0,\n        $18 = 0,\n        $180 = 0,\n        $181 = 0,\n        $182 = 0,\n        $183 = 0,\n        $184 = 0,\n        $185 = 0,\n        $186 = 0,\n        $187 = 0,\n        $188 = 0,\n        $189 = 0,\n        $19 = 0,\n        $190 = 0,\n        $191 = 0,\n        $192 = 0,\n        $193 = 0,\n        $194 = 0,\n        $195 = 0,\n        $196 = 0;\n    var $197 = 0,\n        $198 = 0,\n        $199 = 0,\n        $2 = 0,\n        $20 = 0,\n        $200 = 0,\n        $201 = 0,\n        $202 = 0,\n        $203 = 0,\n        $204 = 0,\n        $205 = 0,\n        $206 = 0,\n        $207 = 0,\n        $208 = 0,\n        $209 = 0,\n        $21 = 0,\n        $210 = 0,\n        $211 = 0,\n        $212 = 0,\n        $213 = 0;\n    var $214 = 0,\n        $215 = 0,\n        $216 = 0,\n        $217 = 0,\n        $218 = 0,\n        $219 = 0,\n        $22 = 0,\n        $220 = 0,\n        $221 = 0,\n        $222 = 0,\n        $223 = 0,\n        $224 = 0,\n        $225 = 0,\n        $226 = 0,\n        $227 = 0,\n        $228 = 0,\n        $229 = 0,\n        $23 = 0,\n        $230 = 0,\n        $231 = 0;\n    var $232 = 0,\n        $233 = 0,\n        $234 = 0,\n        $235 = 0,\n        $236 = 0,\n        $237 = 0,\n        $238 = 0,\n        $239 = 0,\n        $24 = 0,\n        $240 = 0,\n        $241 = 0,\n        $242 = 0,\n        $243 = 0,\n        $244 = 0,\n        $245 = 0,\n        $246 = 0,\n        $247 = 0,\n        $248 = 0,\n        $249 = 0,\n        $25 = 0;\n    var $250 = 0,\n        $251 = 0,\n        $252 = 0,\n        $253 = 0,\n        $254 = 0,\n        $255 = 0,\n        $256 = 0,\n        $257 = 0,\n        $258 = 0,\n        $259 = 0,\n        $26 = 0,\n        $260 = 0,\n        $261 = 0,\n        $262 = 0,\n        $263 = 0,\n        $264 = 0,\n        $265 = 0,\n        $266 = 0,\n        $267 = 0,\n        $268 = 0;\n    var $269 = 0,\n        $27 = 0,\n        $270 = 0,\n        $271 = 0,\n        $272 = 0,\n        $273 = 0,\n        $274 = 0,\n        $275 = 0,\n        $276 = 0,\n        $277 = 0,\n        $278 = 0,\n        $279 = 0,\n        $28 = 0,\n        $280 = 0,\n        $281 = 0,\n        $282 = 0,\n        $283 = 0,\n        $284 = 0,\n        $285 = 0,\n        $286 = 0;\n    var $287 = 0,\n        $288 = 0,\n        $289 = 0,\n        $29 = 0,\n        $290 = 0,\n        $291 = 0,\n        $292 = 0,\n        $293 = 0,\n        $294 = 0,\n        $295 = 0,\n        $296 = 0,\n        $297 = 0,\n        $298 = 0,\n        $299 = 0,\n        $3 = 0,\n        $30 = 0,\n        $300 = 0,\n        $301 = 0,\n        $302 = 0,\n        $303 = 0;\n    var $304 = 0,\n        $305 = 0,\n        $306 = 0,\n        $307 = 0,\n        $308 = 0,\n        $309 = 0,\n        $31 = 0,\n        $310 = 0,\n        $311 = 0,\n        $312 = 0,\n        $313 = 0,\n        $314 = 0,\n        $315 = 0,\n        $316 = 0,\n        $317 = 0,\n        $318 = 0,\n        $319 = 0,\n        $32 = 0,\n        $320 = 0,\n        $321 = 0;\n    var $322 = 0,\n        $323 = 0,\n        $324 = 0,\n        $325 = 0,\n        $326 = 0,\n        $33 = 0,\n        $34 = 0,\n        $35 = 0,\n        $36 = 0,\n        $37 = 0,\n        $38 = 0,\n        $39 = 0,\n        $4 = 0,\n        $40 = 0,\n        $41 = 0,\n        $42 = 0,\n        $43 = 0,\n        $44 = 0,\n        $45 = 0,\n        $46 = 0;\n    var $47 = 0,\n        $48 = 0,\n        $49 = 0,\n        $5 = 0,\n        $50 = 0,\n        $51 = 0,\n        $52 = 0,\n        $53 = 0,\n        $54 = 0,\n        $55 = 0,\n        $56 = 0,\n        $57 = 0,\n        $58 = 0,\n        $59 = 0,\n        $6 = 0,\n        $60 = 0,\n        $61 = 0,\n        $62 = 0,\n        $63 = 0,\n        $64 = 0;\n    var $65 = 0,\n        $66 = 0,\n        $67 = 0,\n        $68 = 0,\n        $69 = 0,\n        $7 = 0,\n        $70 = 0,\n        $71 = 0,\n        $72 = 0,\n        $73 = 0,\n        $74 = 0,\n        $75 = 0,\n        $76 = 0,\n        $77 = 0,\n        $78 = 0,\n        $79 = 0,\n        $8 = 0,\n        $80 = 0,\n        $81 = 0,\n        $82 = 0;\n    var $83 = 0,\n        $84 = 0,\n        $85 = 0,\n        $86 = 0,\n        $87 = 0,\n        $88 = 0,\n        $89 = 0,\n        $9 = 0,\n        $90 = 0,\n        $91 = 0,\n        $92 = 0,\n        $93 = 0,\n        $94 = 0,\n        $95 = 0,\n        $96 = 0,\n        $97 = 0,\n        $98 = 0,\n        $99 = 0,\n        $cond419 = 0,\n        $cond420 = 0;\n    var label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    $1 = ($0 | 0) == (0 | 0);\n\n    if ($1) {\n      return;\n    }\n\n    $2 = $0 + -8 | 0;\n    $3 = HEAP32[329616 >> 2] | 0;\n    $4 = $2 >>> 0 < $3 >>> 0;\n\n    if ($4) {\n      _abort(); // unreachable;\n\n    }\n\n    $5 = $0 + -4 | 0;\n    $6 = HEAP32[$5 >> 2] | 0;\n    $7 = $6 & 3;\n    $8 = ($7 | 0) == 1;\n\n    if ($8) {\n      _abort(); // unreachable;\n\n    }\n\n    $9 = $6 & -8;\n    $10 = $2 + $9 | 0;\n    $11 = $6 & 1;\n    $12 = ($11 | 0) == 0;\n\n    L10: do {\n      if ($12) {\n        $13 = HEAP32[$2 >> 2] | 0;\n        $14 = ($7 | 0) == 0;\n\n        if ($14) {\n          return;\n        }\n\n        $15 = 0 - $13 | 0;\n        $16 = $2 + $15 | 0;\n        $17 = $13 + $9 | 0;\n        $18 = $16 >>> 0 < $3 >>> 0;\n\n        if ($18) {\n          _abort(); // unreachable;\n\n        }\n\n        $19 = HEAP32[329620 >> 2] | 0;\n        $20 = ($19 | 0) == ($16 | 0);\n\n        if ($20) {\n          $105 = $10 + 4 | 0;\n          $106 = HEAP32[$105 >> 2] | 0;\n          $107 = $106 & 3;\n          $108 = ($107 | 0) == 3;\n\n          if (!$108) {\n            $$1 = $16;\n            $$1380 = $17;\n            $114 = $16;\n            break;\n          }\n\n          $109 = $16 + $17 | 0;\n          $110 = $16 + 4 | 0;\n          $111 = $17 | 1;\n          $112 = $106 & -2;\n          HEAP32[329608 >> 2] = $17;\n          HEAP32[$105 >> 2] = $112;\n          HEAP32[$110 >> 2] = $111;\n          HEAP32[$109 >> 2] = $17;\n          return;\n        }\n\n        $21 = $13 >>> 3;\n        $22 = $13 >>> 0 < 256;\n\n        if ($22) {\n          $23 = $16 + 8 | 0;\n          $24 = HEAP32[$23 >> 2] | 0;\n          $25 = $16 + 12 | 0;\n          $26 = HEAP32[$25 >> 2] | 0;\n          $27 = $21 << 1;\n          $28 = 329640 + ($27 << 2) | 0;\n          $29 = ($24 | 0) == ($28 | 0);\n\n          if (!$29) {\n            $30 = $3 >>> 0 > $24 >>> 0;\n\n            if ($30) {\n              _abort(); // unreachable;\n\n            }\n\n            $31 = $24 + 12 | 0;\n            $32 = HEAP32[$31 >> 2] | 0;\n            $33 = ($32 | 0) == ($16 | 0);\n\n            if (!$33) {\n              _abort(); // unreachable;\n\n            }\n          }\n\n          $34 = ($26 | 0) == ($24 | 0);\n\n          if ($34) {\n            $35 = 1 << $21;\n            $36 = $35 ^ -1;\n            $37 = HEAP32[82400] | 0;\n            $38 = $37 & $36;\n            HEAP32[82400] = $38;\n            $$1 = $16;\n            $$1380 = $17;\n            $114 = $16;\n            break;\n          }\n\n          $39 = ($26 | 0) == ($28 | 0);\n\n          if ($39) {\n            $$pre445 = $26 + 8 | 0;\n            $$pre$phi446Z2D = $$pre445;\n          } else {\n            $40 = $3 >>> 0 > $26 >>> 0;\n\n            if ($40) {\n              _abort(); // unreachable;\n\n            }\n\n            $41 = $26 + 8 | 0;\n            $42 = HEAP32[$41 >> 2] | 0;\n            $43 = ($42 | 0) == ($16 | 0);\n\n            if ($43) {\n              $$pre$phi446Z2D = $41;\n            } else {\n              _abort(); // unreachable;\n\n            }\n          }\n\n          $44 = $24 + 12 | 0;\n          HEAP32[$44 >> 2] = $26;\n          HEAP32[$$pre$phi446Z2D >> 2] = $24;\n          $$1 = $16;\n          $$1380 = $17;\n          $114 = $16;\n          break;\n        }\n\n        $45 = $16 + 24 | 0;\n        $46 = HEAP32[$45 >> 2] | 0;\n        $47 = $16 + 12 | 0;\n        $48 = HEAP32[$47 >> 2] | 0;\n        $49 = ($48 | 0) == ($16 | 0);\n\n        do {\n          if ($49) {\n            $59 = $16 + 16 | 0;\n            $60 = $59 + 4 | 0;\n            $61 = HEAP32[$60 >> 2] | 0;\n            $62 = ($61 | 0) == (0 | 0);\n\n            if ($62) {\n              $63 = HEAP32[$59 >> 2] | 0;\n              $64 = ($63 | 0) == (0 | 0);\n\n              if ($64) {\n                $$3 = 0;\n                break;\n              } else {\n                $$1385$ph = $63;\n                $$1388$ph = $59;\n              }\n            } else {\n              $$1385$ph = $61;\n              $$1388$ph = $60;\n            }\n\n            $$1385 = $$1385$ph;\n            $$1388 = $$1388$ph;\n\n            while (1) {\n              $65 = $$1385 + 20 | 0;\n              $66 = HEAP32[$65 >> 2] | 0;\n              $67 = ($66 | 0) == (0 | 0);\n\n              if ($67) {\n                $68 = $$1385 + 16 | 0;\n                $69 = HEAP32[$68 >> 2] | 0;\n                $70 = ($69 | 0) == (0 | 0);\n\n                if ($70) {\n                  break;\n                } else {\n                  $$1385$be = $69;\n                  $$1388$be = $68;\n                }\n              } else {\n                $$1385$be = $66;\n                $$1388$be = $65;\n              }\n\n              $$1385 = $$1385$be;\n              $$1388 = $$1388$be;\n            }\n\n            $71 = $3 >>> 0 > $$1388 >>> 0;\n\n            if ($71) {\n              _abort(); // unreachable;\n\n            } else {\n              HEAP32[$$1388 >> 2] = 0;\n              $$3 = $$1385;\n              break;\n            }\n          } else {\n            $50 = $16 + 8 | 0;\n            $51 = HEAP32[$50 >> 2] | 0;\n            $52 = $3 >>> 0 > $51 >>> 0;\n\n            if ($52) {\n              _abort(); // unreachable;\n\n            }\n\n            $53 = $51 + 12 | 0;\n            $54 = HEAP32[$53 >> 2] | 0;\n            $55 = ($54 | 0) == ($16 | 0);\n\n            if (!$55) {\n              _abort(); // unreachable;\n\n            }\n\n            $56 = $48 + 8 | 0;\n            $57 = HEAP32[$56 >> 2] | 0;\n            $58 = ($57 | 0) == ($16 | 0);\n\n            if ($58) {\n              HEAP32[$53 >> 2] = $48;\n              HEAP32[$56 >> 2] = $51;\n              $$3 = $48;\n              break;\n            } else {\n              _abort(); // unreachable;\n\n            }\n          }\n        } while (0);\n\n        $72 = ($46 | 0) == (0 | 0);\n\n        if ($72) {\n          $$1 = $16;\n          $$1380 = $17;\n          $114 = $16;\n        } else {\n          $73 = $16 + 28 | 0;\n          $74 = HEAP32[$73 >> 2] | 0;\n          $75 = 329904 + ($74 << 2) | 0;\n          $76 = HEAP32[$75 >> 2] | 0;\n          $77 = ($76 | 0) == ($16 | 0);\n\n          do {\n            if ($77) {\n              HEAP32[$75 >> 2] = $$3;\n              $cond419 = ($$3 | 0) == (0 | 0);\n\n              if ($cond419) {\n                $78 = 1 << $74;\n                $79 = $78 ^ -1;\n                $80 = HEAP32[329604 >> 2] | 0;\n                $81 = $80 & $79;\n                HEAP32[329604 >> 2] = $81;\n                $$1 = $16;\n                $$1380 = $17;\n                $114 = $16;\n                break L10;\n              }\n            } else {\n              $82 = HEAP32[329616 >> 2] | 0;\n              $83 = $82 >>> 0 > $46 >>> 0;\n\n              if ($83) {\n                _abort(); // unreachable;\n\n              } else {\n                $84 = $46 + 16 | 0;\n                $85 = HEAP32[$84 >> 2] | 0;\n                $86 = ($85 | 0) == ($16 | 0);\n                $87 = $46 + 20 | 0;\n                $$sink = $86 ? $84 : $87;\n                HEAP32[$$sink >> 2] = $$3;\n                $88 = ($$3 | 0) == (0 | 0);\n\n                if ($88) {\n                  $$1 = $16;\n                  $$1380 = $17;\n                  $114 = $16;\n                  break L10;\n                } else {\n                  break;\n                }\n              }\n            }\n          } while (0);\n\n          $89 = HEAP32[329616 >> 2] | 0;\n          $90 = $89 >>> 0 > $$3 >>> 0;\n\n          if ($90) {\n            _abort(); // unreachable;\n\n          }\n\n          $91 = $$3 + 24 | 0;\n          HEAP32[$91 >> 2] = $46;\n          $92 = $16 + 16 | 0;\n          $93 = HEAP32[$92 >> 2] | 0;\n          $94 = ($93 | 0) == (0 | 0);\n\n          do {\n            if (!$94) {\n              $95 = $89 >>> 0 > $93 >>> 0;\n\n              if ($95) {\n                _abort(); // unreachable;\n\n              } else {\n                $96 = $$3 + 16 | 0;\n                HEAP32[$96 >> 2] = $93;\n                $97 = $93 + 24 | 0;\n                HEAP32[$97 >> 2] = $$3;\n                break;\n              }\n            }\n          } while (0);\n\n          $98 = $92 + 4 | 0;\n          $99 = HEAP32[$98 >> 2] | 0;\n          $100 = ($99 | 0) == (0 | 0);\n\n          if ($100) {\n            $$1 = $16;\n            $$1380 = $17;\n            $114 = $16;\n          } else {\n            $101 = HEAP32[329616 >> 2] | 0;\n            $102 = $101 >>> 0 > $99 >>> 0;\n\n            if ($102) {\n              _abort(); // unreachable;\n\n            } else {\n              $103 = $$3 + 20 | 0;\n              HEAP32[$103 >> 2] = $99;\n              $104 = $99 + 24 | 0;\n              HEAP32[$104 >> 2] = $$3;\n              $$1 = $16;\n              $$1380 = $17;\n              $114 = $16;\n              break;\n            }\n          }\n        }\n      } else {\n        $$1 = $2;\n        $$1380 = $9;\n        $114 = $2;\n      }\n    } while (0);\n\n    $113 = $114 >>> 0 < $10 >>> 0;\n\n    if (!$113) {\n      _abort(); // unreachable;\n\n    }\n\n    $115 = $10 + 4 | 0;\n    $116 = HEAP32[$115 >> 2] | 0;\n    $117 = $116 & 1;\n    $118 = ($117 | 0) == 0;\n\n    if ($118) {\n      _abort(); // unreachable;\n\n    }\n\n    $119 = $116 & 2;\n    $120 = ($119 | 0) == 0;\n\n    if ($120) {\n      $121 = HEAP32[329624 >> 2] | 0;\n      $122 = ($121 | 0) == ($10 | 0);\n\n      if ($122) {\n        $123 = HEAP32[329612 >> 2] | 0;\n        $124 = $123 + $$1380 | 0;\n        HEAP32[329612 >> 2] = $124;\n        HEAP32[329624 >> 2] = $$1;\n        $125 = $124 | 1;\n        $126 = $$1 + 4 | 0;\n        HEAP32[$126 >> 2] = $125;\n        $127 = HEAP32[329620 >> 2] | 0;\n        $128 = ($$1 | 0) == ($127 | 0);\n\n        if (!$128) {\n          return;\n        }\n\n        HEAP32[329620 >> 2] = 0;\n        HEAP32[329608 >> 2] = 0;\n        return;\n      }\n\n      $129 = HEAP32[329620 >> 2] | 0;\n      $130 = ($129 | 0) == ($10 | 0);\n\n      if ($130) {\n        $131 = HEAP32[329608 >> 2] | 0;\n        $132 = $131 + $$1380 | 0;\n        HEAP32[329608 >> 2] = $132;\n        HEAP32[329620 >> 2] = $114;\n        $133 = $132 | 1;\n        $134 = $$1 + 4 | 0;\n        HEAP32[$134 >> 2] = $133;\n        $135 = $114 + $132 | 0;\n        HEAP32[$135 >> 2] = $132;\n        return;\n      }\n\n      $136 = $116 & -8;\n      $137 = $136 + $$1380 | 0;\n      $138 = $116 >>> 3;\n      $139 = $116 >>> 0 < 256;\n\n      L111: do {\n        if ($139) {\n          $140 = $10 + 8 | 0;\n          $141 = HEAP32[$140 >> 2] | 0;\n          $142 = $10 + 12 | 0;\n          $143 = HEAP32[$142 >> 2] | 0;\n          $144 = $138 << 1;\n          $145 = 329640 + ($144 << 2) | 0;\n          $146 = ($141 | 0) == ($145 | 0);\n\n          if (!$146) {\n            $147 = HEAP32[329616 >> 2] | 0;\n            $148 = $147 >>> 0 > $141 >>> 0;\n\n            if ($148) {\n              _abort(); // unreachable;\n\n            }\n\n            $149 = $141 + 12 | 0;\n            $150 = HEAP32[$149 >> 2] | 0;\n            $151 = ($150 | 0) == ($10 | 0);\n\n            if (!$151) {\n              _abort(); // unreachable;\n\n            }\n          }\n\n          $152 = ($143 | 0) == ($141 | 0);\n\n          if ($152) {\n            $153 = 1 << $138;\n            $154 = $153 ^ -1;\n            $155 = HEAP32[82400] | 0;\n            $156 = $155 & $154;\n            HEAP32[82400] = $156;\n            break;\n          }\n\n          $157 = ($143 | 0) == ($145 | 0);\n\n          if ($157) {\n            $$pre443 = $143 + 8 | 0;\n            $$pre$phi444Z2D = $$pre443;\n          } else {\n            $158 = HEAP32[329616 >> 2] | 0;\n            $159 = $158 >>> 0 > $143 >>> 0;\n\n            if ($159) {\n              _abort(); // unreachable;\n\n            }\n\n            $160 = $143 + 8 | 0;\n            $161 = HEAP32[$160 >> 2] | 0;\n            $162 = ($161 | 0) == ($10 | 0);\n\n            if ($162) {\n              $$pre$phi444Z2D = $160;\n            } else {\n              _abort(); // unreachable;\n\n            }\n          }\n\n          $163 = $141 + 12 | 0;\n          HEAP32[$163 >> 2] = $143;\n          HEAP32[$$pre$phi444Z2D >> 2] = $141;\n        } else {\n          $164 = $10 + 24 | 0;\n          $165 = HEAP32[$164 >> 2] | 0;\n          $166 = $10 + 12 | 0;\n          $167 = HEAP32[$166 >> 2] | 0;\n          $168 = ($167 | 0) == ($10 | 0);\n\n          do {\n            if ($168) {\n              $179 = $10 + 16 | 0;\n              $180 = $179 + 4 | 0;\n              $181 = HEAP32[$180 >> 2] | 0;\n              $182 = ($181 | 0) == (0 | 0);\n\n              if ($182) {\n                $183 = HEAP32[$179 >> 2] | 0;\n                $184 = ($183 | 0) == (0 | 0);\n\n                if ($184) {\n                  $$3398 = 0;\n                  break;\n                } else {\n                  $$1396$ph = $183;\n                  $$1400$ph = $179;\n                }\n              } else {\n                $$1396$ph = $181;\n                $$1400$ph = $180;\n              }\n\n              $$1396 = $$1396$ph;\n              $$1400 = $$1400$ph;\n\n              while (1) {\n                $185 = $$1396 + 20 | 0;\n                $186 = HEAP32[$185 >> 2] | 0;\n                $187 = ($186 | 0) == (0 | 0);\n\n                if ($187) {\n                  $188 = $$1396 + 16 | 0;\n                  $189 = HEAP32[$188 >> 2] | 0;\n                  $190 = ($189 | 0) == (0 | 0);\n\n                  if ($190) {\n                    break;\n                  } else {\n                    $$1396$be = $189;\n                    $$1400$be = $188;\n                  }\n                } else {\n                  $$1396$be = $186;\n                  $$1400$be = $185;\n                }\n\n                $$1396 = $$1396$be;\n                $$1400 = $$1400$be;\n              }\n\n              $191 = HEAP32[329616 >> 2] | 0;\n              $192 = $191 >>> 0 > $$1400 >>> 0;\n\n              if ($192) {\n                _abort(); // unreachable;\n\n              } else {\n                HEAP32[$$1400 >> 2] = 0;\n                $$3398 = $$1396;\n                break;\n              }\n            } else {\n              $169 = $10 + 8 | 0;\n              $170 = HEAP32[$169 >> 2] | 0;\n              $171 = HEAP32[329616 >> 2] | 0;\n              $172 = $171 >>> 0 > $170 >>> 0;\n\n              if ($172) {\n                _abort(); // unreachable;\n\n              }\n\n              $173 = $170 + 12 | 0;\n              $174 = HEAP32[$173 >> 2] | 0;\n              $175 = ($174 | 0) == ($10 | 0);\n\n              if (!$175) {\n                _abort(); // unreachable;\n\n              }\n\n              $176 = $167 + 8 | 0;\n              $177 = HEAP32[$176 >> 2] | 0;\n              $178 = ($177 | 0) == ($10 | 0);\n\n              if ($178) {\n                HEAP32[$173 >> 2] = $167;\n                HEAP32[$176 >> 2] = $170;\n                $$3398 = $167;\n                break;\n              } else {\n                _abort(); // unreachable;\n\n              }\n            }\n          } while (0);\n\n          $193 = ($165 | 0) == (0 | 0);\n\n          if (!$193) {\n            $194 = $10 + 28 | 0;\n            $195 = HEAP32[$194 >> 2] | 0;\n            $196 = 329904 + ($195 << 2) | 0;\n            $197 = HEAP32[$196 >> 2] | 0;\n            $198 = ($197 | 0) == ($10 | 0);\n\n            do {\n              if ($198) {\n                HEAP32[$196 >> 2] = $$3398;\n                $cond420 = ($$3398 | 0) == (0 | 0);\n\n                if ($cond420) {\n                  $199 = 1 << $195;\n                  $200 = $199 ^ -1;\n                  $201 = HEAP32[329604 >> 2] | 0;\n                  $202 = $201 & $200;\n                  HEAP32[329604 >> 2] = $202;\n                  break L111;\n                }\n              } else {\n                $203 = HEAP32[329616 >> 2] | 0;\n                $204 = $203 >>> 0 > $165 >>> 0;\n\n                if ($204) {\n                  _abort(); // unreachable;\n\n                } else {\n                  $205 = $165 + 16 | 0;\n                  $206 = HEAP32[$205 >> 2] | 0;\n                  $207 = ($206 | 0) == ($10 | 0);\n                  $208 = $165 + 20 | 0;\n                  $$sink456 = $207 ? $205 : $208;\n                  HEAP32[$$sink456 >> 2] = $$3398;\n                  $209 = ($$3398 | 0) == (0 | 0);\n\n                  if ($209) {\n                    break L111;\n                  } else {\n                    break;\n                  }\n                }\n              }\n            } while (0);\n\n            $210 = HEAP32[329616 >> 2] | 0;\n            $211 = $210 >>> 0 > $$3398 >>> 0;\n\n            if ($211) {\n              _abort(); // unreachable;\n\n            }\n\n            $212 = $$3398 + 24 | 0;\n            HEAP32[$212 >> 2] = $165;\n            $213 = $10 + 16 | 0;\n            $214 = HEAP32[$213 >> 2] | 0;\n            $215 = ($214 | 0) == (0 | 0);\n\n            do {\n              if (!$215) {\n                $216 = $210 >>> 0 > $214 >>> 0;\n\n                if ($216) {\n                  _abort(); // unreachable;\n\n                } else {\n                  $217 = $$3398 + 16 | 0;\n                  HEAP32[$217 >> 2] = $214;\n                  $218 = $214 + 24 | 0;\n                  HEAP32[$218 >> 2] = $$3398;\n                  break;\n                }\n              }\n            } while (0);\n\n            $219 = $213 + 4 | 0;\n            $220 = HEAP32[$219 >> 2] | 0;\n            $221 = ($220 | 0) == (0 | 0);\n\n            if (!$221) {\n              $222 = HEAP32[329616 >> 2] | 0;\n              $223 = $222 >>> 0 > $220 >>> 0;\n\n              if ($223) {\n                _abort(); // unreachable;\n\n              } else {\n                $224 = $$3398 + 20 | 0;\n                HEAP32[$224 >> 2] = $220;\n                $225 = $220 + 24 | 0;\n                HEAP32[$225 >> 2] = $$3398;\n                break;\n              }\n            }\n          }\n        }\n      } while (0);\n\n      $226 = $137 | 1;\n      $227 = $$1 + 4 | 0;\n      HEAP32[$227 >> 2] = $226;\n      $228 = $114 + $137 | 0;\n      HEAP32[$228 >> 2] = $137;\n      $229 = HEAP32[329620 >> 2] | 0;\n      $230 = ($$1 | 0) == ($229 | 0);\n\n      if ($230) {\n        HEAP32[329608 >> 2] = $137;\n        return;\n      } else {\n        $$2 = $137;\n      }\n    } else {\n      $231 = $116 & -2;\n      HEAP32[$115 >> 2] = $231;\n      $232 = $$1380 | 1;\n      $233 = $$1 + 4 | 0;\n      HEAP32[$233 >> 2] = $232;\n      $234 = $114 + $$1380 | 0;\n      HEAP32[$234 >> 2] = $$1380;\n      $$2 = $$1380;\n    }\n\n    $235 = $$2 >>> 3;\n    $236 = $$2 >>> 0 < 256;\n\n    if ($236) {\n      $237 = $235 << 1;\n      $238 = 329640 + ($237 << 2) | 0;\n      $239 = HEAP32[82400] | 0;\n      $240 = 1 << $235;\n      $241 = $239 & $240;\n      $242 = ($241 | 0) == 0;\n\n      if ($242) {\n        $243 = $239 | $240;\n        HEAP32[82400] = $243;\n        $$pre = $238 + 8 | 0;\n        $$0401 = $238;\n        $$pre$phiZ2D = $$pre;\n      } else {\n        $244 = $238 + 8 | 0;\n        $245 = HEAP32[$244 >> 2] | 0;\n        $246 = HEAP32[329616 >> 2] | 0;\n        $247 = $246 >>> 0 > $245 >>> 0;\n\n        if ($247) {\n          _abort(); // unreachable;\n\n        } else {\n          $$0401 = $245;\n          $$pre$phiZ2D = $244;\n        }\n      }\n\n      HEAP32[$$pre$phiZ2D >> 2] = $$1;\n      $248 = $$0401 + 12 | 0;\n      HEAP32[$248 >> 2] = $$1;\n      $249 = $$1 + 8 | 0;\n      HEAP32[$249 >> 2] = $$0401;\n      $250 = $$1 + 12 | 0;\n      HEAP32[$250 >> 2] = $238;\n      return;\n    }\n\n    $251 = $$2 >>> 8;\n    $252 = ($251 | 0) == 0;\n\n    if ($252) {\n      $$0394 = 0;\n    } else {\n      $253 = $$2 >>> 0 > 16777215;\n\n      if ($253) {\n        $$0394 = 31;\n      } else {\n        $254 = $251 + 1048320 | 0;\n        $255 = $254 >>> 16;\n        $256 = $255 & 8;\n        $257 = $251 << $256;\n        $258 = $257 + 520192 | 0;\n        $259 = $258 >>> 16;\n        $260 = $259 & 4;\n        $261 = $260 | $256;\n        $262 = $257 << $260;\n        $263 = $262 + 245760 | 0;\n        $264 = $263 >>> 16;\n        $265 = $264 & 2;\n        $266 = $261 | $265;\n        $267 = 14 - $266 | 0;\n        $268 = $262 << $265;\n        $269 = $268 >>> 15;\n        $270 = $267 + $269 | 0;\n        $271 = $270 << 1;\n        $272 = $270 + 7 | 0;\n        $273 = $$2 >>> $272;\n        $274 = $273 & 1;\n        $275 = $274 | $271;\n        $$0394 = $275;\n      }\n    }\n\n    $276 = 329904 + ($$0394 << 2) | 0;\n    $277 = $$1 + 28 | 0;\n    HEAP32[$277 >> 2] = $$0394;\n    $278 = $$1 + 16 | 0;\n    $279 = $$1 + 20 | 0;\n    HEAP32[$279 >> 2] = 0;\n    HEAP32[$278 >> 2] = 0;\n    $280 = HEAP32[329604 >> 2] | 0;\n    $281 = 1 << $$0394;\n    $282 = $280 & $281;\n    $283 = ($282 | 0) == 0;\n\n    L197: do {\n      if ($283) {\n        $284 = $280 | $281;\n        HEAP32[329604 >> 2] = $284;\n        HEAP32[$276 >> 2] = $$1;\n        $285 = $$1 + 24 | 0;\n        HEAP32[$285 >> 2] = $276;\n        $286 = $$1 + 12 | 0;\n        HEAP32[$286 >> 2] = $$1;\n        $287 = $$1 + 8 | 0;\n        HEAP32[$287 >> 2] = $$1;\n      } else {\n        $288 = HEAP32[$276 >> 2] | 0;\n        $289 = $288 + 4 | 0;\n        $290 = HEAP32[$289 >> 2] | 0;\n        $291 = $290 & -8;\n        $292 = ($291 | 0) == ($$2 | 0);\n\n        L200: do {\n          if ($292) {\n            $$0382$lcssa = $288;\n          } else {\n            $293 = ($$0394 | 0) == 31;\n            $294 = $$0394 >>> 1;\n            $295 = 25 - $294 | 0;\n            $296 = $293 ? 0 : $295;\n            $297 = $$2 << $296;\n            $$0381438 = $297;\n            $$0382437 = $288;\n\n            while (1) {\n              $304 = $$0381438 >>> 31;\n              $305 = ($$0382437 + 16 | 0) + ($304 << 2) | 0;\n              $300 = HEAP32[$305 >> 2] | 0;\n              $306 = ($300 | 0) == (0 | 0);\n\n              if ($306) {\n                break;\n              }\n\n              $298 = $$0381438 << 1;\n              $299 = $300 + 4 | 0;\n              $301 = HEAP32[$299 >> 2] | 0;\n              $302 = $301 & -8;\n              $303 = ($302 | 0) == ($$2 | 0);\n\n              if ($303) {\n                $$0382$lcssa = $300;\n                break L200;\n              } else {\n                $$0381438 = $298;\n                $$0382437 = $300;\n              }\n            }\n\n            $307 = HEAP32[329616 >> 2] | 0;\n            $308 = $307 >>> 0 > $305 >>> 0;\n\n            if ($308) {\n              _abort(); // unreachable;\n\n            } else {\n              HEAP32[$305 >> 2] = $$1;\n              $309 = $$1 + 24 | 0;\n              HEAP32[$309 >> 2] = $$0382437;\n              $310 = $$1 + 12 | 0;\n              HEAP32[$310 >> 2] = $$1;\n              $311 = $$1 + 8 | 0;\n              HEAP32[$311 >> 2] = $$1;\n              break L197;\n            }\n          }\n        } while (0);\n\n        $312 = $$0382$lcssa + 8 | 0;\n        $313 = HEAP32[$312 >> 2] | 0;\n        $314 = HEAP32[329616 >> 2] | 0;\n        $315 = $314 >>> 0 <= $$0382$lcssa >>> 0;\n        $316 = $314 >>> 0 <= $313 >>> 0;\n        $317 = $316 & $315;\n\n        if ($317) {\n          $318 = $313 + 12 | 0;\n          HEAP32[$318 >> 2] = $$1;\n          HEAP32[$312 >> 2] = $$1;\n          $319 = $$1 + 8 | 0;\n          HEAP32[$319 >> 2] = $313;\n          $320 = $$1 + 12 | 0;\n          HEAP32[$320 >> 2] = $$0382$lcssa;\n          $321 = $$1 + 24 | 0;\n          HEAP32[$321 >> 2] = 0;\n          break;\n        } else {\n          _abort(); // unreachable;\n\n        }\n      }\n    } while (0);\n\n    $322 = HEAP32[329632 >> 2] | 0;\n    $323 = $322 + -1 | 0;\n    HEAP32[329632 >> 2] = $323;\n    $324 = ($323 | 0) == 0;\n\n    if (!$324) {\n      return;\n    }\n\n    $$0211$in$i = 330056;\n\n    while (1) {\n      $$0211$i = HEAP32[$$0211$in$i >> 2] | 0;\n      $325 = ($$0211$i | 0) == (0 | 0);\n      $326 = $$0211$i + 8 | 0;\n\n      if ($325) {\n        break;\n      } else {\n        $$0211$in$i = $326;\n      }\n    }\n\n    HEAP32[329632 >> 2] = -1;\n    return;\n  }\n\n  function _calloc($0, $1) {\n    $0 = $0 | 0;\n    $1 = $1 | 0;\n    var $$0 = 0,\n        $10 = 0,\n        $11 = 0,\n        $12 = 0,\n        $13 = 0,\n        $2 = 0,\n        $3 = 0,\n        $4 = 0,\n        $5 = 0,\n        $6 = 0,\n        $7 = 0,\n        $8 = 0,\n        $9 = 0,\n        $spec$select = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    $2 = ($0 | 0) == 0;\n\n    if ($2) {\n      $$0 = 0;\n    } else {\n      $3 = Math_imul($1, $0) | 0;\n      $4 = $1 | $0;\n      $5 = $4 >>> 0 > 65535;\n\n      if ($5) {\n        $6 = ($3 >>> 0) / ($0 >>> 0) & -1;\n        $7 = ($6 | 0) == ($1 | 0);\n        $spec$select = $7 ? $3 : -1;\n        $$0 = $spec$select;\n      } else {\n        $$0 = $3;\n      }\n    }\n\n    $8 = _malloc($$0) | 0;\n    $9 = ($8 | 0) == (0 | 0);\n\n    if ($9) {\n      return $8 | 0;\n    }\n\n    $10 = $8 + -4 | 0;\n    $11 = HEAP32[$10 >> 2] | 0;\n    $12 = $11 & 3;\n    $13 = ($12 | 0) == 0;\n\n    if ($13) {\n      return $8 | 0;\n    }\n\n    _memset($8 | 0, 0, $$0 | 0) | 0;\n    return $8 | 0;\n  }\n\n  function ___stdio_close($0) {\n    $0 = $0 | 0;\n    var $1 = 0,\n        $2 = 0,\n        $3 = 0,\n        $4 = 0,\n        $5 = 0,\n        $vararg_buffer = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    STACKTOP = STACKTOP + 16 | 0;\n    if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);\n    $vararg_buffer = sp;\n    $1 = $0 + 60 | 0;\n    $2 = HEAP32[$1 >> 2] | 0;\n    $3 = _dummy_734($2) | 0;\n    HEAP32[$vararg_buffer >> 2] = $3;\n    $4 = ___syscall6(6, $vararg_buffer | 0) | 0;\n    $5 = ___syscall_ret($4) | 0;\n    STACKTOP = sp;\n    return $5 | 0;\n  }\n\n  function ___stdio_write($0, $1, $2) {\n    $0 = $0 | 0;\n    $1 = $1 | 0;\n    $2 = $2 | 0;\n    var $$0 = 0,\n        $$04756 = 0,\n        $$04855 = 0,\n        $$04954 = 0,\n        $$051 = 0,\n        $$1 = 0,\n        $$150 = 0,\n        $10 = 0,\n        $11 = 0,\n        $12 = 0,\n        $13 = 0,\n        $14 = 0,\n        $15 = 0,\n        $16 = 0,\n        $17 = 0,\n        $18 = 0,\n        $19 = 0,\n        $20 = 0,\n        $21 = 0,\n        $22 = 0;\n    var $23 = 0,\n        $24 = 0,\n        $25 = 0,\n        $26 = 0,\n        $27 = 0,\n        $28 = 0,\n        $29 = 0,\n        $3 = 0,\n        $30 = 0,\n        $31 = 0,\n        $32 = 0,\n        $33 = 0,\n        $34 = 0,\n        $35 = 0,\n        $36 = 0,\n        $37 = 0,\n        $38 = 0,\n        $39 = 0,\n        $4 = 0,\n        $40 = 0;\n    var $41 = 0,\n        $42 = 0,\n        $43 = 0,\n        $44 = 0,\n        $45 = 0,\n        $46 = 0,\n        $47 = 0,\n        $48 = 0,\n        $49 = 0,\n        $5 = 0,\n        $50 = 0,\n        $51 = 0,\n        $6 = 0,\n        $7 = 0,\n        $8 = 0,\n        $9 = 0,\n        $vararg_buffer = 0,\n        $vararg_buffer3 = 0,\n        $vararg_ptr1 = 0,\n        $vararg_ptr2 = 0;\n    var $vararg_ptr6 = 0,\n        $vararg_ptr7 = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    STACKTOP = STACKTOP + 48 | 0;\n    if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);\n    $vararg_buffer3 = sp + 32 | 0;\n    $vararg_buffer = sp + 16 | 0;\n    $3 = sp;\n    $4 = $0 + 28 | 0;\n    $5 = HEAP32[$4 >> 2] | 0;\n    HEAP32[$3 >> 2] = $5;\n    $6 = $3 + 4 | 0;\n    $7 = $0 + 20 | 0;\n    $8 = HEAP32[$7 >> 2] | 0;\n    $9 = $8 - $5 | 0;\n    HEAP32[$6 >> 2] = $9;\n    $10 = $3 + 8 | 0;\n    HEAP32[$10 >> 2] = $1;\n    $11 = $3 + 12 | 0;\n    HEAP32[$11 >> 2] = $2;\n    $12 = $9 + $2 | 0;\n    $13 = $0 + 60 | 0;\n    $14 = HEAP32[$13 >> 2] | 0;\n    $15 = $3;\n    HEAP32[$vararg_buffer >> 2] = $14;\n    $vararg_ptr1 = $vararg_buffer + 4 | 0;\n    HEAP32[$vararg_ptr1 >> 2] = $15;\n    $vararg_ptr2 = $vararg_buffer + 8 | 0;\n    HEAP32[$vararg_ptr2 >> 2] = 2;\n    $16 = ___syscall146(146, $vararg_buffer | 0) | 0;\n    $17 = ___syscall_ret($16) | 0;\n    $18 = ($12 | 0) == ($17 | 0);\n\n    L1: do {\n      if ($18) {\n        label = 3;\n      } else {\n        $$04756 = 2;\n        $$04855 = $12;\n        $$04954 = $3;\n        $27 = $17;\n\n        while (1) {\n          $26 = ($27 | 0) < 0;\n\n          if ($26) {\n            break;\n          }\n\n          $35 = $$04855 - $27 | 0;\n          $36 = $$04954 + 4 | 0;\n          $37 = HEAP32[$36 >> 2] | 0;\n          $38 = $27 >>> 0 > $37 >>> 0;\n          $39 = $$04954 + 8 | 0;\n          $$150 = $38 ? $39 : $$04954;\n          $40 = $38 << 31 >> 31;\n          $$1 = $$04756 + $40 | 0;\n          $41 = $38 ? $37 : 0;\n          $$0 = $27 - $41 | 0;\n          $42 = HEAP32[$$150 >> 2] | 0;\n          $43 = $42 + $$0 | 0;\n          HEAP32[$$150 >> 2] = $43;\n          $44 = $$150 + 4 | 0;\n          $45 = HEAP32[$44 >> 2] | 0;\n          $46 = $45 - $$0 | 0;\n          HEAP32[$44 >> 2] = $46;\n          $47 = HEAP32[$13 >> 2] | 0;\n          $48 = $$150;\n          HEAP32[$vararg_buffer3 >> 2] = $47;\n          $vararg_ptr6 = $vararg_buffer3 + 4 | 0;\n          HEAP32[$vararg_ptr6 >> 2] = $48;\n          $vararg_ptr7 = $vararg_buffer3 + 8 | 0;\n          HEAP32[$vararg_ptr7 >> 2] = $$1;\n          $49 = ___syscall146(146, $vararg_buffer3 | 0) | 0;\n          $50 = ___syscall_ret($49) | 0;\n          $51 = ($35 | 0) == ($50 | 0);\n\n          if ($51) {\n            label = 3;\n            break L1;\n          } else {\n            $$04756 = $$1;\n            $$04855 = $35;\n            $$04954 = $$150;\n            $27 = $50;\n          }\n        }\n\n        $28 = $0 + 16 | 0;\n        HEAP32[$28 >> 2] = 0;\n        HEAP32[$4 >> 2] = 0;\n        HEAP32[$7 >> 2] = 0;\n        $29 = HEAP32[$0 >> 2] | 0;\n        $30 = $29 | 32;\n        HEAP32[$0 >> 2] = $30;\n        $31 = ($$04756 | 0) == 2;\n\n        if ($31) {\n          $$051 = 0;\n        } else {\n          $32 = $$04954 + 4 | 0;\n          $33 = HEAP32[$32 >> 2] | 0;\n          $34 = $2 - $33 | 0;\n          $$051 = $34;\n        }\n      }\n    } while (0);\n\n    if ((label | 0) == 3) {\n      $19 = $0 + 44 | 0;\n      $20 = HEAP32[$19 >> 2] | 0;\n      $21 = $0 + 48 | 0;\n      $22 = HEAP32[$21 >> 2] | 0;\n      $23 = $20 + $22 | 0;\n      $24 = $0 + 16 | 0;\n      HEAP32[$24 >> 2] = $23;\n      $25 = $20;\n      HEAP32[$4 >> 2] = $25;\n      HEAP32[$7 >> 2] = $25;\n      $$051 = $2;\n    }\n\n    STACKTOP = sp;\n    return $$051 | 0;\n  }\n\n  function ___stdio_seek($0, $1, $2) {\n    $0 = $0 | 0;\n    $1 = $1 | 0;\n    $2 = $2 | 0;\n    var $$pre = 0,\n        $10 = 0,\n        $3 = 0,\n        $4 = 0,\n        $5 = 0,\n        $6 = 0,\n        $7 = 0,\n        $8 = 0,\n        $9 = 0,\n        $vararg_buffer = 0,\n        $vararg_ptr1 = 0,\n        $vararg_ptr2 = 0,\n        $vararg_ptr3 = 0,\n        $vararg_ptr4 = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    STACKTOP = STACKTOP + 32 | 0;\n    if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);\n    $vararg_buffer = sp;\n    $3 = sp + 20 | 0;\n    $4 = $0 + 60 | 0;\n    $5 = HEAP32[$4 >> 2] | 0;\n    $6 = $3;\n    HEAP32[$vararg_buffer >> 2] = $5;\n    $vararg_ptr1 = $vararg_buffer + 4 | 0;\n    HEAP32[$vararg_ptr1 >> 2] = 0;\n    $vararg_ptr2 = $vararg_buffer + 8 | 0;\n    HEAP32[$vararg_ptr2 >> 2] = $1;\n    $vararg_ptr3 = $vararg_buffer + 12 | 0;\n    HEAP32[$vararg_ptr3 >> 2] = $6;\n    $vararg_ptr4 = $vararg_buffer + 16 | 0;\n    HEAP32[$vararg_ptr4 >> 2] = $2;\n    $7 = ___syscall140(140, $vararg_buffer | 0) | 0;\n    $8 = ___syscall_ret($7) | 0;\n    $9 = ($8 | 0) < 0;\n\n    if ($9) {\n      HEAP32[$3 >> 2] = -1;\n      $10 = -1;\n    } else {\n      $$pre = HEAP32[$3 >> 2] | 0;\n      $10 = $$pre;\n    }\n\n    STACKTOP = sp;\n    return $10 | 0;\n  }\n\n  function ___syscall_ret($0) {\n    $0 = $0 | 0;\n    var $$0 = 0,\n        $1 = 0,\n        $2 = 0,\n        $3 = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    $1 = $0 >>> 0 > 4294963200;\n\n    if ($1) {\n      $2 = 0 - $0 | 0;\n      $3 = ___errno_location() | 0;\n      HEAP32[$3 >> 2] = $2;\n      $$0 = -1;\n    } else {\n      $$0 = $0;\n    }\n\n    return $$0 | 0;\n  }\n\n  function ___errno_location() {\n    var label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    return 330096 | 0;\n  }\n\n  function _dummy_734($0) {\n    $0 = $0 | 0;\n    var label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    return $0 | 0;\n  }\n\n  function ___stdout_write($0, $1, $2) {\n    $0 = $0 | 0;\n    $1 = $1 | 0;\n    $2 = $2 | 0;\n    var $10 = 0,\n        $11 = 0,\n        $12 = 0,\n        $13 = 0,\n        $14 = 0,\n        $3 = 0,\n        $4 = 0,\n        $5 = 0,\n        $6 = 0,\n        $7 = 0,\n        $8 = 0,\n        $9 = 0,\n        $vararg_buffer = 0,\n        $vararg_ptr1 = 0,\n        $vararg_ptr2 = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    STACKTOP = STACKTOP + 32 | 0;\n    if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);\n    $vararg_buffer = sp;\n    $3 = sp + 16 | 0;\n    $4 = $0 + 36 | 0;\n    HEAP32[$4 >> 2] = 5;\n    $5 = HEAP32[$0 >> 2] | 0;\n    $6 = $5 & 64;\n    $7 = ($6 | 0) == 0;\n\n    if ($7) {\n      $8 = $0 + 60 | 0;\n      $9 = HEAP32[$8 >> 2] | 0;\n      $10 = $3;\n      HEAP32[$vararg_buffer >> 2] = $9;\n      $vararg_ptr1 = $vararg_buffer + 4 | 0;\n      HEAP32[$vararg_ptr1 >> 2] = 21523;\n      $vararg_ptr2 = $vararg_buffer + 8 | 0;\n      HEAP32[$vararg_ptr2 >> 2] = $10;\n      $11 = ___syscall54(54, $vararg_buffer | 0) | 0;\n      $12 = ($11 | 0) == 0;\n\n      if (!$12) {\n        $13 = $0 + 75 | 0;\n        HEAP8[$13 >> 0] = -1;\n      }\n    }\n\n    $14 = ___stdio_write($0, $1, $2) | 0;\n    STACKTOP = sp;\n    return $14 | 0;\n  }\n\n  function ___lockfile($0) {\n    $0 = $0 | 0;\n    var label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    return 0;\n  }\n\n  function ___unlockfile($0) {\n    $0 = $0 | 0;\n    var label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    return;\n  }\n\n  function ___fwritex($0, $1, $2) {\n    $0 = $0 | 0;\n    $1 = $1 | 0;\n    $2 = $2 | 0;\n    var $$03846 = 0,\n        $$042 = 0,\n        $$1 = 0,\n        $$139 = 0,\n        $$141 = 0,\n        $$143 = 0,\n        $$pre = 0,\n        $$pre48 = 0,\n        $10 = 0,\n        $11 = 0,\n        $12 = 0,\n        $13 = 0,\n        $14 = 0,\n        $15 = 0,\n        $16 = 0,\n        $17 = 0,\n        $18 = 0,\n        $19 = 0,\n        $20 = 0,\n        $21 = 0;\n    var $22 = 0,\n        $23 = 0,\n        $24 = 0,\n        $25 = 0,\n        $26 = 0,\n        $27 = 0,\n        $28 = 0,\n        $29 = 0,\n        $3 = 0,\n        $30 = 0,\n        $31 = 0,\n        $32 = 0,\n        $33 = 0,\n        $34 = 0,\n        $35 = 0,\n        $4 = 0,\n        $5 = 0,\n        $6 = 0,\n        $7 = 0,\n        $8 = 0;\n    var $9 = 0,\n        $or$cond = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    $3 = $2 + 16 | 0;\n    $4 = HEAP32[$3 >> 2] | 0;\n    $5 = ($4 | 0) == (0 | 0);\n\n    if ($5) {\n      $7 = ___towrite($2) | 0;\n      $8 = ($7 | 0) == 0;\n\n      if ($8) {\n        $$pre = HEAP32[$3 >> 2] | 0;\n        $12 = $$pre;\n        label = 5;\n      } else {\n        $$1 = 0;\n      }\n    } else {\n      $6 = $4;\n      $12 = $6;\n      label = 5;\n    }\n\n    L5: do {\n      if ((label | 0) == 5) {\n        $9 = $2 + 20 | 0;\n        $10 = HEAP32[$9 >> 2] | 0;\n        $11 = $12 - $10 | 0;\n        $13 = $11 >>> 0 < $1 >>> 0;\n        $14 = $10;\n\n        if ($13) {\n          $15 = $2 + 36 | 0;\n          $16 = HEAP32[$15 >> 2] | 0;\n          $17 = FUNCTION_TABLE_iiii[$16 & 7]($2, $0, $1) | 0;\n          $$1 = $17;\n          break;\n        }\n\n        $18 = $2 + 75 | 0;\n        $19 = HEAP8[$18 >> 0] | 0;\n        $20 = $19 << 24 >> 24 < 0;\n        $21 = ($1 | 0) == 0;\n        $or$cond = $20 | $21;\n\n        L10: do {\n          if ($or$cond) {\n            $$139 = 0;\n            $$141 = $0;\n            $$143 = $1;\n            $32 = $14;\n          } else {\n            $$03846 = $1;\n\n            while (1) {\n              $23 = $$03846 + -1 | 0;\n              $24 = $0 + $23 | 0;\n              $25 = HEAP8[$24 >> 0] | 0;\n              $26 = $25 << 24 >> 24 == 10;\n\n              if ($26) {\n                break;\n              }\n\n              $22 = ($23 | 0) == 0;\n\n              if ($22) {\n                $$139 = 0;\n                $$141 = $0;\n                $$143 = $1;\n                $32 = $14;\n                break L10;\n              } else {\n                $$03846 = $23;\n              }\n            }\n\n            $27 = $2 + 36 | 0;\n            $28 = HEAP32[$27 >> 2] | 0;\n            $29 = FUNCTION_TABLE_iiii[$28 & 7]($2, $0, $$03846) | 0;\n            $30 = $29 >>> 0 < $$03846 >>> 0;\n\n            if ($30) {\n              $$1 = $29;\n              break L5;\n            }\n\n            $31 = $0 + $$03846 | 0;\n            $$042 = $1 - $$03846 | 0;\n            $$pre48 = HEAP32[$9 >> 2] | 0;\n            $$139 = $$03846;\n            $$141 = $31;\n            $$143 = $$042;\n            $32 = $$pre48;\n          }\n        } while (0);\n\n        _memcpy($32 | 0, $$141 | 0, $$143 | 0) | 0;\n        $33 = HEAP32[$9 >> 2] | 0;\n        $34 = $33 + $$143 | 0;\n        HEAP32[$9 >> 2] = $34;\n        $35 = $$139 + $$143 | 0;\n        $$1 = $35;\n      }\n    } while (0);\n\n    return $$1 | 0;\n  }\n\n  function ___towrite($0) {\n    $0 = $0 | 0;\n    var $$0 = 0,\n        $1 = 0,\n        $10 = 0,\n        $11 = 0,\n        $12 = 0,\n        $13 = 0,\n        $14 = 0,\n        $15 = 0,\n        $16 = 0,\n        $17 = 0,\n        $18 = 0,\n        $19 = 0,\n        $2 = 0,\n        $20 = 0,\n        $21 = 0,\n        $3 = 0,\n        $4 = 0,\n        $5 = 0,\n        $6 = 0,\n        $7 = 0;\n    var $8 = 0,\n        $9 = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    $1 = $0 + 74 | 0;\n    $2 = HEAP8[$1 >> 0] | 0;\n    $3 = $2 << 24 >> 24;\n    $4 = $3 + 255 | 0;\n    $5 = $4 | $3;\n    $6 = $5 & 255;\n    HEAP8[$1 >> 0] = $6;\n    $7 = HEAP32[$0 >> 2] | 0;\n    $8 = $7 & 8;\n    $9 = ($8 | 0) == 0;\n\n    if ($9) {\n      $11 = $0 + 8 | 0;\n      HEAP32[$11 >> 2] = 0;\n      $12 = $0 + 4 | 0;\n      HEAP32[$12 >> 2] = 0;\n      $13 = $0 + 44 | 0;\n      $14 = HEAP32[$13 >> 2] | 0;\n      $15 = $0 + 28 | 0;\n      HEAP32[$15 >> 2] = $14;\n      $16 = $0 + 20 | 0;\n      HEAP32[$16 >> 2] = $14;\n      $17 = $14;\n      $18 = $0 + 48 | 0;\n      $19 = HEAP32[$18 >> 2] | 0;\n      $20 = $17 + $19 | 0;\n      $21 = $0 + 16 | 0;\n      HEAP32[$21 >> 2] = $20;\n      $$0 = 0;\n    } else {\n      $10 = $7 | 32;\n      HEAP32[$0 >> 2] = $10;\n      $$0 = -1;\n    }\n\n    return $$0 | 0;\n  }\n\n  function _strlen($0) {\n    $0 = $0 | 0;\n    var $$0 = 0,\n        $$014 = 0,\n        $$015$lcssa = 0,\n        $$01518 = 0,\n        $$1$lcssa = 0,\n        $$pn = 0,\n        $$pn29 = 0,\n        $$pre = 0,\n        $1 = 0,\n        $10 = 0,\n        $11 = 0,\n        $12 = 0,\n        $13 = 0,\n        $14 = 0,\n        $15 = 0,\n        $16 = 0,\n        $17 = 0,\n        $18 = 0,\n        $19 = 0,\n        $2 = 0;\n    var $20 = 0,\n        $21 = 0,\n        $22 = 0,\n        $3 = 0,\n        $4 = 0,\n        $5 = 0,\n        $6 = 0,\n        $7 = 0,\n        $8 = 0,\n        $9 = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    $1 = $0;\n    $2 = $1 & 3;\n    $3 = ($2 | 0) == 0;\n\n    L1: do {\n      if ($3) {\n        $$015$lcssa = $0;\n        label = 5;\n      } else {\n        $$01518 = $0;\n        $22 = $1;\n\n        while (1) {\n          $4 = HEAP8[$$01518 >> 0] | 0;\n          $5 = $4 << 24 >> 24 == 0;\n\n          if ($5) {\n            $$pn = $22;\n            break L1;\n          }\n\n          $6 = $$01518 + 1 | 0;\n          $7 = $6;\n          $8 = $7 & 3;\n          $9 = ($8 | 0) == 0;\n\n          if ($9) {\n            $$015$lcssa = $6;\n            label = 5;\n            break;\n          } else {\n            $$01518 = $6;\n            $22 = $7;\n          }\n        }\n      }\n    } while (0);\n\n    if ((label | 0) == 5) {\n      $$0 = $$015$lcssa;\n\n      while (1) {\n        $10 = HEAP32[$$0 >> 2] | 0;\n        $11 = $10 + -16843009 | 0;\n        $12 = $10 & -2139062144;\n        $13 = $12 ^ -2139062144;\n        $14 = $13 & $11;\n        $15 = ($14 | 0) == 0;\n        $16 = $$0 + 4 | 0;\n\n        if ($15) {\n          $$0 = $16;\n        } else {\n          break;\n        }\n      }\n\n      $17 = $10 & 255;\n      $18 = $17 << 24 >> 24 == 0;\n\n      if ($18) {\n        $$1$lcssa = $$0;\n      } else {\n        $$pn29 = $$0;\n\n        while (1) {\n          $19 = $$pn29 + 1 | 0;\n          $$pre = HEAP8[$19 >> 0] | 0;\n          $20 = $$pre << 24 >> 24 == 0;\n\n          if ($20) {\n            $$1$lcssa = $19;\n            break;\n          } else {\n            $$pn29 = $19;\n          }\n        }\n      }\n\n      $21 = $$1$lcssa;\n      $$pn = $21;\n    }\n\n    $$014 = $$pn - $1 | 0;\n    return $$014 | 0;\n  }\n\n  function _fputs($0, $1) {\n    $0 = $0 | 0;\n    $1 = $1 | 0;\n    var $2 = 0,\n        $3 = 0,\n        $4 = 0,\n        $5 = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    $2 = _strlen($0) | 0;\n    $3 = _fwrite($0, 1, $2, $1) | 0;\n    $4 = ($3 | 0) != ($2 | 0);\n    $5 = $4 << 31 >> 31;\n    return $5 | 0;\n  }\n\n  function _fwrite($0, $1, $2, $3) {\n    $0 = $0 | 0;\n    $1 = $1 | 0;\n    $2 = $2 | 0;\n    $3 = $3 | 0;\n    var $10 = 0,\n        $11 = 0,\n        $12 = 0,\n        $13 = 0,\n        $14 = 0,\n        $15 = 0,\n        $4 = 0,\n        $5 = 0,\n        $6 = 0,\n        $7 = 0,\n        $8 = 0,\n        $9 = 0,\n        $phitmp = 0,\n        $spec$select = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    $4 = Math_imul($2, $1) | 0;\n    $5 = ($1 | 0) == 0;\n    $spec$select = $5 ? 0 : $2;\n    $6 = $3 + 76 | 0;\n    $7 = HEAP32[$6 >> 2] | 0;\n    $8 = ($7 | 0) > -1;\n\n    if ($8) {\n      $10 = ___lockfile($3) | 0;\n      $phitmp = ($10 | 0) == 0;\n      $11 = ___fwritex($0, $4, $3) | 0;\n\n      if ($phitmp) {\n        $13 = $11;\n      } else {\n        ___unlockfile($3);\n\n        $13 = $11;\n      }\n    } else {\n      $9 = ___fwritex($0, $4, $3) | 0;\n      $13 = $9;\n    }\n\n    $12 = ($13 | 0) == ($4 | 0);\n\n    if ($12) {\n      $15 = $spec$select;\n    } else {\n      $14 = ($13 >>> 0) / ($1 >>> 0) & -1;\n      $15 = $14;\n    }\n\n    return $15 | 0;\n  }\n\n  function ___overflow($0, $1) {\n    $0 = $0 | 0;\n    $1 = $1 | 0;\n    var $$0 = 0,\n        $$pre = 0,\n        $10 = 0,\n        $11 = 0,\n        $12 = 0,\n        $13 = 0,\n        $14 = 0,\n        $15 = 0,\n        $16 = 0,\n        $17 = 0,\n        $18 = 0,\n        $19 = 0,\n        $2 = 0,\n        $20 = 0,\n        $21 = 0,\n        $22 = 0,\n        $23 = 0,\n        $24 = 0,\n        $3 = 0,\n        $4 = 0;\n    var $5 = 0,\n        $6 = 0,\n        $7 = 0,\n        $8 = 0,\n        $9 = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    STACKTOP = STACKTOP + 16 | 0;\n    if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);\n    $2 = sp;\n    $3 = $1 & 255;\n    HEAP8[$2 >> 0] = $3;\n    $4 = $0 + 16 | 0;\n    $5 = HEAP32[$4 >> 2] | 0;\n    $6 = ($5 | 0) == (0 | 0);\n\n    if ($6) {\n      $7 = ___towrite($0) | 0;\n      $8 = ($7 | 0) == 0;\n\n      if ($8) {\n        $$pre = HEAP32[$4 >> 2] | 0;\n        $12 = $$pre;\n        label = 4;\n      } else {\n        $$0 = -1;\n      }\n    } else {\n      $12 = $5;\n      label = 4;\n    }\n\n    do {\n      if ((label | 0) == 4) {\n        $9 = $0 + 20 | 0;\n        $10 = HEAP32[$9 >> 2] | 0;\n        $11 = $10 >>> 0 < $12 >>> 0;\n\n        if ($11) {\n          $13 = $1 & 255;\n          $14 = $0 + 75 | 0;\n          $15 = HEAP8[$14 >> 0] | 0;\n          $16 = $15 << 24 >> 24;\n          $17 = ($13 | 0) == ($16 | 0);\n\n          if (!$17) {\n            $18 = $10 + 1 | 0;\n            HEAP32[$9 >> 2] = $18;\n            HEAP8[$10 >> 0] = $3;\n            $$0 = $13;\n            break;\n          }\n        }\n\n        $19 = $0 + 36 | 0;\n        $20 = HEAP32[$19 >> 2] | 0;\n        $21 = FUNCTION_TABLE_iiii[$20 & 7]($0, $2, 1) | 0;\n        $22 = ($21 | 0) == 1;\n\n        if ($22) {\n          $23 = HEAP8[$2 >> 0] | 0;\n          $24 = $23 & 255;\n          $$0 = $24;\n        } else {\n          $$0 = -1;\n        }\n      }\n    } while (0);\n\n    STACKTOP = sp;\n    return $$0 | 0;\n  }\n\n  function ___ofl_lock() {\n    var label = 0,\n        sp = 0;\n    sp = STACKTOP;\n\n    ___lock(330100 | 0);\n\n    return 330108 | 0;\n  }\n\n  function ___ofl_unlock() {\n    var label = 0,\n        sp = 0;\n    sp = STACKTOP;\n\n    ___unlock(330100 | 0);\n\n    return;\n  }\n\n  function _fflush($0) {\n    $0 = $0 | 0;\n    var $$0 = 0,\n        $$023 = 0,\n        $$02325 = 0,\n        $$02327 = 0,\n        $$024$lcssa = 0,\n        $$02426 = 0,\n        $$1 = 0,\n        $1 = 0,\n        $10 = 0,\n        $11 = 0,\n        $12 = 0,\n        $13 = 0,\n        $14 = 0,\n        $15 = 0,\n        $16 = 0,\n        $17 = 0,\n        $18 = 0,\n        $19 = 0,\n        $2 = 0,\n        $20 = 0;\n    var $21 = 0,\n        $22 = 0,\n        $23 = 0,\n        $24 = 0,\n        $25 = 0,\n        $26 = 0,\n        $27 = 0,\n        $28 = 0,\n        $29 = 0,\n        $3 = 0,\n        $4 = 0,\n        $5 = 0,\n        $6 = 0,\n        $7 = 0,\n        $8 = 0,\n        $9 = 0,\n        $phitmp = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    $1 = ($0 | 0) == (0 | 0);\n\n    do {\n      if ($1) {\n        $8 = HEAP32[212] | 0;\n        $9 = ($8 | 0) == (0 | 0);\n\n        if ($9) {\n          $29 = 0;\n        } else {\n          $10 = HEAP32[212] | 0;\n          $11 = _fflush($10) | 0;\n          $29 = $11;\n        }\n\n        $12 = ___ofl_lock() | 0;\n        $$02325 = HEAP32[$12 >> 2] | 0;\n        $13 = ($$02325 | 0) == (0 | 0);\n\n        if ($13) {\n          $$024$lcssa = $29;\n        } else {\n          $$02327 = $$02325;\n          $$02426 = $29;\n\n          while (1) {\n            $14 = $$02327 + 76 | 0;\n            $15 = HEAP32[$14 >> 2] | 0;\n            $16 = ($15 | 0) > -1;\n\n            if ($16) {\n              $17 = ___lockfile($$02327) | 0;\n              $26 = $17;\n            } else {\n              $26 = 0;\n            }\n\n            $18 = $$02327 + 20 | 0;\n            $19 = HEAP32[$18 >> 2] | 0;\n            $20 = $$02327 + 28 | 0;\n            $21 = HEAP32[$20 >> 2] | 0;\n            $22 = $19 >>> 0 > $21 >>> 0;\n\n            if ($22) {\n              $23 = ___fflush_unlocked($$02327) | 0;\n              $24 = $23 | $$02426;\n              $$1 = $24;\n            } else {\n              $$1 = $$02426;\n            }\n\n            $25 = ($26 | 0) == 0;\n\n            if (!$25) {\n              ___unlockfile($$02327);\n            }\n\n            $27 = $$02327 + 56 | 0;\n            $$023 = HEAP32[$27 >> 2] | 0;\n            $28 = ($$023 | 0) == (0 | 0);\n\n            if ($28) {\n              $$024$lcssa = $$1;\n              break;\n            } else {\n              $$02327 = $$023;\n              $$02426 = $$1;\n            }\n          }\n        }\n\n        ___ofl_unlock();\n\n        $$0 = $$024$lcssa;\n      } else {\n        $2 = $0 + 76 | 0;\n        $3 = HEAP32[$2 >> 2] | 0;\n        $4 = ($3 | 0) > -1;\n\n        if (!$4) {\n          $5 = ___fflush_unlocked($0) | 0;\n          $$0 = $5;\n          break;\n        }\n\n        $6 = ___lockfile($0) | 0;\n        $phitmp = ($6 | 0) == 0;\n        $7 = ___fflush_unlocked($0) | 0;\n\n        if ($phitmp) {\n          $$0 = $7;\n        } else {\n          ___unlockfile($0);\n\n          $$0 = $7;\n        }\n      }\n    } while (0);\n\n    return $$0 | 0;\n  }\n\n  function ___fflush_unlocked($0) {\n    $0 = $0 | 0;\n    var $$0 = 0,\n        $1 = 0,\n        $10 = 0,\n        $11 = 0,\n        $12 = 0,\n        $13 = 0,\n        $14 = 0,\n        $15 = 0,\n        $16 = 0,\n        $17 = 0,\n        $18 = 0,\n        $19 = 0,\n        $2 = 0,\n        $20 = 0,\n        $3 = 0,\n        $4 = 0,\n        $5 = 0,\n        $6 = 0,\n        $7 = 0,\n        $8 = 0;\n    var $9 = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    $1 = $0 + 20 | 0;\n    $2 = HEAP32[$1 >> 2] | 0;\n    $3 = $0 + 28 | 0;\n    $4 = HEAP32[$3 >> 2] | 0;\n    $5 = $2 >>> 0 > $4 >>> 0;\n\n    if ($5) {\n      $6 = $0 + 36 | 0;\n      $7 = HEAP32[$6 >> 2] | 0;\n      FUNCTION_TABLE_iiii[$7 & 7]($0, 0, 0) | 0;\n      $8 = HEAP32[$1 >> 2] | 0;\n      $9 = ($8 | 0) == (0 | 0);\n\n      if ($9) {\n        $$0 = -1;\n      } else {\n        label = 3;\n      }\n    } else {\n      label = 3;\n    }\n\n    if ((label | 0) == 3) {\n      $10 = $0 + 4 | 0;\n      $11 = HEAP32[$10 >> 2] | 0;\n      $12 = $0 + 8 | 0;\n      $13 = HEAP32[$12 >> 2] | 0;\n      $14 = $11 >>> 0 < $13 >>> 0;\n\n      if ($14) {\n        $15 = $11;\n        $16 = $13;\n        $17 = $15 - $16 | 0;\n        $18 = $0 + 40 | 0;\n        $19 = HEAP32[$18 >> 2] | 0;\n        FUNCTION_TABLE_iiii[$19 & 7]($0, $17, 1) | 0;\n      }\n\n      $20 = $0 + 16 | 0;\n      HEAP32[$20 >> 2] = 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$1 >> 2] = 0;\n      HEAP32[$12 >> 2] = 0;\n      HEAP32[$10 >> 2] = 0;\n      $$0 = 0;\n    }\n\n    return $$0 | 0;\n  }\n\n  function _puts($0) {\n    $0 = $0 | 0;\n    var $$lobit = 0,\n        $1 = 0,\n        $10 = 0,\n        $11 = 0,\n        $12 = 0,\n        $13 = 0,\n        $14 = 0,\n        $15 = 0,\n        $16 = 0,\n        $17 = 0,\n        $18 = 0,\n        $19 = 0,\n        $2 = 0,\n        $20 = 0,\n        $3 = 0,\n        $4 = 0,\n        $5 = 0,\n        $6 = 0,\n        $7 = 0,\n        $8 = 0;\n    var $9 = 0,\n        label = 0,\n        sp = 0;\n    sp = STACKTOP;\n    $1 = HEAP32[180] | 0;\n    $2 = $1 + 76 | 0;\n    $3 = HEAP32[$2 >> 2] | 0;\n    $4 = ($3 | 0) > -1;\n\n    if ($4) {\n      $5 = ___lockfile($1) | 0;\n      $19 = $5;\n    } else {\n      $19 = 0;\n    }\n\n    $6 = _fputs($0, $1) | 0;\n    $7 = ($6 | 0) < 0;\n\n    do {\n      if ($7) {\n        $20 = -1;\n      } else {\n        $8 = $1 + 75 | 0;\n        $9 = HEAP8[$8 >> 0] | 0;\n        $10 = $9 << 24 >> 24 == 10;\n\n        if (!$10) {\n          $11 = $1 + 20 | 0;\n          $12 = HEAP32[$11 >> 2] | 0;\n          $13 = $1 + 16 | 0;\n          $14 = HEAP32[$13 >> 2] | 0;\n          $15 = $12 >>> 0 < $14 >>> 0;\n\n          if ($15) {\n            $16 = $12 + 1 | 0;\n            HEAP32[$11 >> 2] = $16;\n            HEAP8[$12 >> 0] = 10;\n            $20 = 0;\n            break;\n          }\n        }\n\n        $17 = ___overflow($1, 10) | 0;\n        $$lobit = $17 >> 31;\n        $20 = $$lobit;\n      }\n    } while (0);\n\n    $18 = ($19 | 0) == 0;\n\n    if (!$18) {\n      ___unlockfile($1);\n    }\n\n    return $20 | 0;\n  }\n\n  function runPostSets() {}\n\n  function _llvm_round_f64(d) {\n    d = +d;\n    return d >= +0 ? +Math_floor(d + +0.5) : +Math_ceil(d - +0.5);\n  }\n\n  function _memcpy(dest, src, num) {\n    dest = dest | 0;\n    src = src | 0;\n    num = num | 0;\n    var ret = 0;\n    var aligned_dest_end = 0;\n    var block_aligned_dest_end = 0;\n    var dest_end = 0; // Test against a benchmarked cutoff limit for when HEAPU8.set() becomes faster to use.\n\n    if ((num | 0) >= 8192) {\n      return _emscripten_memcpy_big(dest | 0, src | 0, num | 0) | 0;\n    }\n\n    ret = dest | 0;\n    dest_end = dest + num | 0;\n\n    if ((dest & 3) == (src & 3)) {\n      // The initial unaligned < 4-byte front.\n      while (dest & 3) {\n        if ((num | 0) == 0) return ret | 0;\n        HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;\n        dest = dest + 1 | 0;\n        src = src + 1 | 0;\n        num = num - 1 | 0;\n      }\n\n      aligned_dest_end = dest_end & -4 | 0;\n      block_aligned_dest_end = aligned_dest_end - 64 | 0;\n\n      while ((dest | 0) <= (block_aligned_dest_end | 0)) {\n        HEAP32[dest >> 2] = HEAP32[src >> 2] | 0;\n        HEAP32[dest + 4 >> 2] = HEAP32[src + 4 >> 2] | 0;\n        HEAP32[dest + 8 >> 2] = HEAP32[src + 8 >> 2] | 0;\n        HEAP32[dest + 12 >> 2] = HEAP32[src + 12 >> 2] | 0;\n        HEAP32[dest + 16 >> 2] = HEAP32[src + 16 >> 2] | 0;\n        HEAP32[dest + 20 >> 2] = HEAP32[src + 20 >> 2] | 0;\n        HEAP32[dest + 24 >> 2] = HEAP32[src + 24 >> 2] | 0;\n        HEAP32[dest + 28 >> 2] = HEAP32[src + 28 >> 2] | 0;\n        HEAP32[dest + 32 >> 2] = HEAP32[src + 32 >> 2] | 0;\n        HEAP32[dest + 36 >> 2] = HEAP32[src + 36 >> 2] | 0;\n        HEAP32[dest + 40 >> 2] = HEAP32[src + 40 >> 2] | 0;\n        HEAP32[dest + 44 >> 2] = HEAP32[src + 44 >> 2] | 0;\n        HEAP32[dest + 48 >> 2] = HEAP32[src + 48 >> 2] | 0;\n        HEAP32[dest + 52 >> 2] = HEAP32[src + 52 >> 2] | 0;\n        HEAP32[dest + 56 >> 2] = HEAP32[src + 56 >> 2] | 0;\n        HEAP32[dest + 60 >> 2] = HEAP32[src + 60 >> 2] | 0;\n        dest = dest + 64 | 0;\n        src = src + 64 | 0;\n      }\n\n      while ((dest | 0) < (aligned_dest_end | 0)) {\n        HEAP32[dest >> 2] = HEAP32[src >> 2] | 0;\n        dest = dest + 4 | 0;\n        src = src + 4 | 0;\n      }\n    } else {\n      // In the unaligned copy case, unroll a bit as well.\n      aligned_dest_end = dest_end - 4 | 0;\n\n      while ((dest | 0) < (aligned_dest_end | 0)) {\n        HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;\n        HEAP8[dest + 1 >> 0] = HEAP8[src + 1 >> 0] | 0;\n        HEAP8[dest + 2 >> 0] = HEAP8[src + 2 >> 0] | 0;\n        HEAP8[dest + 3 >> 0] = HEAP8[src + 3 >> 0] | 0;\n        dest = dest + 4 | 0;\n        src = src + 4 | 0;\n      }\n    } // The remaining unaligned < 4 byte tail.\n\n\n    while ((dest | 0) < (dest_end | 0)) {\n      HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;\n      dest = dest + 1 | 0;\n      src = src + 1 | 0;\n    }\n\n    return ret | 0;\n  }\n\n  function _memset(ptr, value, num) {\n    ptr = ptr | 0;\n    value = value | 0;\n    num = num | 0;\n    var end = 0,\n        aligned_end = 0,\n        block_aligned_end = 0,\n        value4 = 0;\n    end = ptr + num | 0;\n    value = value & 0xff;\n\n    if ((num | 0) >= 67\n    /* 64 bytes for an unrolled loop + 3 bytes for unaligned head*/\n    ) {\n        while ((ptr & 3) != 0) {\n          HEAP8[ptr >> 0] = value;\n          ptr = ptr + 1 | 0;\n        }\n\n        aligned_end = end & -4 | 0;\n        block_aligned_end = aligned_end - 64 | 0;\n        value4 = value | value << 8 | value << 16 | value << 24;\n\n        while ((ptr | 0) <= (block_aligned_end | 0)) {\n          HEAP32[ptr >> 2] = value4;\n          HEAP32[ptr + 4 >> 2] = value4;\n          HEAP32[ptr + 8 >> 2] = value4;\n          HEAP32[ptr + 12 >> 2] = value4;\n          HEAP32[ptr + 16 >> 2] = value4;\n          HEAP32[ptr + 20 >> 2] = value4;\n          HEAP32[ptr + 24 >> 2] = value4;\n          HEAP32[ptr + 28 >> 2] = value4;\n          HEAP32[ptr + 32 >> 2] = value4;\n          HEAP32[ptr + 36 >> 2] = value4;\n          HEAP32[ptr + 40 >> 2] = value4;\n          HEAP32[ptr + 44 >> 2] = value4;\n          HEAP32[ptr + 48 >> 2] = value4;\n          HEAP32[ptr + 52 >> 2] = value4;\n          HEAP32[ptr + 56 >> 2] = value4;\n          HEAP32[ptr + 60 >> 2] = value4;\n          ptr = ptr + 64 | 0;\n        }\n\n        while ((ptr | 0) < (aligned_end | 0)) {\n          HEAP32[ptr >> 2] = value4;\n          ptr = ptr + 4 | 0;\n        }\n      } // The remaining bytes.\n\n\n    while ((ptr | 0) < (end | 0)) {\n      HEAP8[ptr >> 0] = value;\n      ptr = ptr + 1 | 0;\n    }\n\n    return end - num | 0;\n  }\n\n  function _sbrk(increment) {\n    increment = increment | 0;\n    var oldDynamicTop = 0;\n    var oldDynamicTopOnChange = 0;\n    var newDynamicTop = 0;\n    var totalMemory = 0;\n    oldDynamicTop = HEAP32[DYNAMICTOP_PTR >> 2] | 0;\n    newDynamicTop = oldDynamicTop + increment | 0;\n\n    if ((increment | 0) > 0 & (newDynamicTop | 0) < (oldDynamicTop | 0) | // Detect and fail if we would wrap around signed 32-bit int.\n    (newDynamicTop | 0) < 0) {\n      // Also underflow, sbrk() should be able to be used to subtract.\n      abortOnCannotGrowMemory() | 0;\n\n      ___setErrNo(12);\n\n      return -1;\n    }\n\n    HEAP32[DYNAMICTOP_PTR >> 2] = newDynamicTop;\n    totalMemory = getTotalMemory() | 0;\n\n    if ((newDynamicTop | 0) > (totalMemory | 0)) {\n      if ((enlargeMemory() | 0) == 0) {\n        HEAP32[DYNAMICTOP_PTR >> 2] = oldDynamicTop;\n\n        ___setErrNo(12);\n\n        return -1;\n      }\n    }\n\n    return oldDynamicTop | 0;\n  }\n\n  function dynCall_ii(index, a1) {\n    index = index | 0;\n    a1 = a1 | 0;\n    return FUNCTION_TABLE_ii[index & 1](a1 | 0) | 0;\n  }\n\n  function dynCall_iiii(index, a1, a2, a3) {\n    index = index | 0;\n    a1 = a1 | 0;\n    a2 = a2 | 0;\n    a3 = a3 | 0;\n    return FUNCTION_TABLE_iiii[index & 7](a1 | 0, a2 | 0, a3 | 0) | 0;\n  }\n\n  function dynCall_viiiii(index, a1, a2, a3, a4, a5) {\n    index = index | 0;\n    a1 = a1 | 0;\n    a2 = a2 | 0;\n    a3 = a3 | 0;\n    a4 = a4 | 0;\n    a5 = a5 | 0;\n    FUNCTION_TABLE_viiiii[index & 7](a1 | 0, a2 | 0, a3 | 0, a4 | 0, a5 | 0);\n  }\n\n  function b0(p0) {\n    p0 = p0 | 0;\n    nullFunc_ii(0);\n    return 0;\n  }\n\n  function b1(p0, p1, p2) {\n    p0 = p0 | 0;\n    p1 = p1 | 0;\n    p2 = p2 | 0;\n    nullFunc_iiii(1);\n    return 0;\n  }\n\n  function b2(p0, p1, p2, p3, p4) {\n    p0 = p0 | 0;\n    p1 = p1 | 0;\n    p2 = p2 | 0;\n    p3 = p3 | 0;\n    p4 = p4 | 0;\n    nullFunc_viiiii(2);\n  } // EMSCRIPTEN_END_FUNCS\n\n\n  var FUNCTION_TABLE_ii = [b0, ___stdio_close];\n  var FUNCTION_TABLE_iiii = [b1, b1, ___stdout_write, ___stdio_seek, b1, ___stdio_write, b1, b1];\n  var FUNCTION_TABLE_viiiii = [b2, b2, b2, b2, _map_set_func, b2, b2, b2];\n  return {\n    ___errno_location: ___errno_location,\n    _delete_chunk: _delete_chunk,\n    _fflush: _fflush,\n    _find_chunk: _find_chunk,\n    _free: _free,\n    _gen_chunk: _gen_chunk,\n    _get_unused_chunk_mem_location: _get_unused_chunk_mem_location,\n    _init_chunk: _init_chunk,\n    _llvm_round_f64: _llvm_round_f64,\n    _malloc: _malloc,\n    _memcpy: _memcpy,\n    _memset: _memset,\n    _sbrk: _sbrk,\n    dynCall_ii: dynCall_ii,\n    dynCall_iiii: dynCall_iiii,\n    dynCall_viiiii: dynCall_viiiii,\n    establishStackSpace: establishStackSpace,\n    getTempRet0: getTempRet0,\n    runPostSets: runPostSets,\n    setTempRet0: setTempRet0,\n    setThrew: setThrew,\n    stackAlloc: stackAlloc,\n    stackRestore: stackRestore,\n    stackSave: stackSave\n  };\n}( // EMSCRIPTEN_END_ASM\nModule.asmGlobalArg, Module.asmLibraryArg, buffer);\n\nvar real____errno_location = asm[\"___errno_location\"];\n\nasm[\"___errno_location\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real____errno_location.apply(null, arguments);\n};\n\nvar real__delete_chunk = asm[\"_delete_chunk\"];\n\nasm[\"_delete_chunk\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__delete_chunk.apply(null, arguments);\n};\n\nvar real__fflush = asm[\"_fflush\"];\n\nasm[\"_fflush\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__fflush.apply(null, arguments);\n};\n\nvar real__find_chunk = asm[\"_find_chunk\"];\n\nasm[\"_find_chunk\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__find_chunk.apply(null, arguments);\n};\n\nvar real__free = asm[\"_free\"];\n\nasm[\"_free\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__free.apply(null, arguments);\n};\n\nvar real__gen_chunk = asm[\"_gen_chunk\"];\n\nasm[\"_gen_chunk\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gen_chunk.apply(null, arguments);\n};\n\nvar real__get_unused_chunk_mem_location = asm[\"_get_unused_chunk_mem_location\"];\n\nasm[\"_get_unused_chunk_mem_location\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__get_unused_chunk_mem_location.apply(null, arguments);\n};\n\nvar real__init_chunk = asm[\"_init_chunk\"];\n\nasm[\"_init_chunk\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__init_chunk.apply(null, arguments);\n};\n\nvar real__llvm_round_f64 = asm[\"_llvm_round_f64\"];\n\nasm[\"_llvm_round_f64\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__llvm_round_f64.apply(null, arguments);\n};\n\nvar real__malloc = asm[\"_malloc\"];\n\nasm[\"_malloc\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__malloc.apply(null, arguments);\n};\n\nvar real__sbrk = asm[\"_sbrk\"];\n\nasm[\"_sbrk\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__sbrk.apply(null, arguments);\n};\n\nvar real_establishStackSpace = asm[\"establishStackSpace\"];\n\nasm[\"establishStackSpace\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_establishStackSpace.apply(null, arguments);\n};\n\nvar real_getTempRet0 = asm[\"getTempRet0\"];\n\nasm[\"getTempRet0\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_getTempRet0.apply(null, arguments);\n};\n\nvar real_setTempRet0 = asm[\"setTempRet0\"];\n\nasm[\"setTempRet0\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_setTempRet0.apply(null, arguments);\n};\n\nvar real_setThrew = asm[\"setThrew\"];\n\nasm[\"setThrew\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_setThrew.apply(null, arguments);\n};\n\nvar real_stackAlloc = asm[\"stackAlloc\"];\n\nasm[\"stackAlloc\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_stackAlloc.apply(null, arguments);\n};\n\nvar real_stackRestore = asm[\"stackRestore\"];\n\nasm[\"stackRestore\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_stackRestore.apply(null, arguments);\n};\n\nvar real_stackSave = asm[\"stackSave\"];\n\nasm[\"stackSave\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_stackSave.apply(null, arguments);\n};\n\nvar ___errno_location = Module[\"___errno_location\"] = asm[\"___errno_location\"];\n\nvar _delete_chunk = Module[\"_delete_chunk\"] = asm[\"_delete_chunk\"];\n\nvar _fflush = Module[\"_fflush\"] = asm[\"_fflush\"];\n\nvar _find_chunk = Module[\"_find_chunk\"] = asm[\"_find_chunk\"];\n\nvar _free = Module[\"_free\"] = asm[\"_free\"];\n\nvar _gen_chunk = Module[\"_gen_chunk\"] = asm[\"_gen_chunk\"];\n\nvar _get_unused_chunk_mem_location = Module[\"_get_unused_chunk_mem_location\"] = asm[\"_get_unused_chunk_mem_location\"];\n\nvar _init_chunk = Module[\"_init_chunk\"] = asm[\"_init_chunk\"];\n\nvar _llvm_round_f64 = Module[\"_llvm_round_f64\"] = asm[\"_llvm_round_f64\"];\n\nvar _malloc = Module[\"_malloc\"] = asm[\"_malloc\"];\n\nvar _memcpy = Module[\"_memcpy\"] = asm[\"_memcpy\"];\n\nvar _memset = Module[\"_memset\"] = asm[\"_memset\"];\n\nvar _sbrk = Module[\"_sbrk\"] = asm[\"_sbrk\"];\n\nvar establishStackSpace = Module[\"establishStackSpace\"] = asm[\"establishStackSpace\"];\nvar getTempRet0 = Module[\"getTempRet0\"] = asm[\"getTempRet0\"];\nvar runPostSets = Module[\"runPostSets\"] = asm[\"runPostSets\"];\nvar setTempRet0 = Module[\"setTempRet0\"] = asm[\"setTempRet0\"];\nvar setThrew = Module[\"setThrew\"] = asm[\"setThrew\"];\nvar stackAlloc = Module[\"stackAlloc\"] = asm[\"stackAlloc\"];\nvar stackRestore = Module[\"stackRestore\"] = asm[\"stackRestore\"];\nvar stackSave = Module[\"stackSave\"] = asm[\"stackSave\"];\nvar dynCall_ii = Module[\"dynCall_ii\"] = asm[\"dynCall_ii\"];\nvar dynCall_iiii = Module[\"dynCall_iiii\"] = asm[\"dynCall_iiii\"];\nvar dynCall_viiiii = Module[\"dynCall_viiiii\"] = asm[\"dynCall_viiiii\"];\n; // === Auto-generated postamble setup entry stuff ===\n\nModule['asm'] = asm;\nif (!Module[\"intArrayFromString\"]) Module[\"intArrayFromString\"] = function () {\n  abort(\"'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"intArrayToString\"]) Module[\"intArrayToString\"] = function () {\n  abort(\"'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nModule[\"ccall\"] = ccall;\nModule[\"cwrap\"] = cwrap;\nModule[\"setValue\"] = setValue;\nModule[\"getValue\"] = getValue;\nif (!Module[\"allocate\"]) Module[\"allocate\"] = function () {\n  abort(\"'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"getMemory\"]) Module[\"getMemory\"] = function () {\n  abort(\"'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n};\nif (!Module[\"Pointer_stringify\"]) Module[\"Pointer_stringify\"] = function () {\n  abort(\"'Pointer_stringify' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"AsciiToString\"]) Module[\"AsciiToString\"] = function () {\n  abort(\"'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"stringToAscii\"]) Module[\"stringToAscii\"] = function () {\n  abort(\"'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"UTF8ArrayToString\"]) Module[\"UTF8ArrayToString\"] = function () {\n  abort(\"'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"UTF8ToString\"]) Module[\"UTF8ToString\"] = function () {\n  abort(\"'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"stringToUTF8Array\"]) Module[\"stringToUTF8Array\"] = function () {\n  abort(\"'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"stringToUTF8\"]) Module[\"stringToUTF8\"] = function () {\n  abort(\"'stringToUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"lengthBytesUTF8\"]) Module[\"lengthBytesUTF8\"] = function () {\n  abort(\"'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"UTF16ToString\"]) Module[\"UTF16ToString\"] = function () {\n  abort(\"'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"stringToUTF16\"]) Module[\"stringToUTF16\"] = function () {\n  abort(\"'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"lengthBytesUTF16\"]) Module[\"lengthBytesUTF16\"] = function () {\n  abort(\"'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"UTF32ToString\"]) Module[\"UTF32ToString\"] = function () {\n  abort(\"'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"stringToUTF32\"]) Module[\"stringToUTF32\"] = function () {\n  abort(\"'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"lengthBytesUTF32\"]) Module[\"lengthBytesUTF32\"] = function () {\n  abort(\"'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"allocateUTF8\"]) Module[\"allocateUTF8\"] = function () {\n  abort(\"'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"stackTrace\"]) Module[\"stackTrace\"] = function () {\n  abort(\"'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"addOnPreRun\"]) Module[\"addOnPreRun\"] = function () {\n  abort(\"'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"addOnInit\"]) Module[\"addOnInit\"] = function () {\n  abort(\"'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"addOnPreMain\"]) Module[\"addOnPreMain\"] = function () {\n  abort(\"'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"addOnExit\"]) Module[\"addOnExit\"] = function () {\n  abort(\"'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"addOnPostRun\"]) Module[\"addOnPostRun\"] = function () {\n  abort(\"'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"writeStringToMemory\"]) Module[\"writeStringToMemory\"] = function () {\n  abort(\"'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"writeArrayToMemory\"]) Module[\"writeArrayToMemory\"] = function () {\n  abort(\"'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"writeAsciiToMemory\"]) Module[\"writeAsciiToMemory\"] = function () {\n  abort(\"'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"addRunDependency\"]) Module[\"addRunDependency\"] = function () {\n  abort(\"'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n};\nif (!Module[\"removeRunDependency\"]) Module[\"removeRunDependency\"] = function () {\n  abort(\"'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n};\nif (!Module[\"ENV\"]) Module[\"ENV\"] = function () {\n  abort(\"'ENV' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"FS\"]) Module[\"FS\"] = function () {\n  abort(\"'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"FS_createFolder\"]) Module[\"FS_createFolder\"] = function () {\n  abort(\"'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n};\nif (!Module[\"FS_createPath\"]) Module[\"FS_createPath\"] = function () {\n  abort(\"'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n};\nif (!Module[\"FS_createDataFile\"]) Module[\"FS_createDataFile\"] = function () {\n  abort(\"'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n};\nif (!Module[\"FS_createPreloadedFile\"]) Module[\"FS_createPreloadedFile\"] = function () {\n  abort(\"'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n};\nif (!Module[\"FS_createLazyFile\"]) Module[\"FS_createLazyFile\"] = function () {\n  abort(\"'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n};\nif (!Module[\"FS_createLink\"]) Module[\"FS_createLink\"] = function () {\n  abort(\"'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n};\nif (!Module[\"FS_createDevice\"]) Module[\"FS_createDevice\"] = function () {\n  abort(\"'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n};\nif (!Module[\"FS_unlink\"]) Module[\"FS_unlink\"] = function () {\n  abort(\"'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n};\nif (!Module[\"GL\"]) Module[\"GL\"] = function () {\n  abort(\"'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"staticAlloc\"]) Module[\"staticAlloc\"] = function () {\n  abort(\"'staticAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"dynamicAlloc\"]) Module[\"dynamicAlloc\"] = function () {\n  abort(\"'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"warnOnce\"]) Module[\"warnOnce\"] = function () {\n  abort(\"'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"loadDynamicLibrary\"]) Module[\"loadDynamicLibrary\"] = function () {\n  abort(\"'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"loadWebAssemblyModule\"]) Module[\"loadWebAssemblyModule\"] = function () {\n  abort(\"'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"getLEB\"]) Module[\"getLEB\"] = function () {\n  abort(\"'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"getFunctionTables\"]) Module[\"getFunctionTables\"] = function () {\n  abort(\"'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"alignFunctionTables\"]) Module[\"alignFunctionTables\"] = function () {\n  abort(\"'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"registerFunctions\"]) Module[\"registerFunctions\"] = function () {\n  abort(\"'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"addFunction\"]) Module[\"addFunction\"] = function () {\n  abort(\"'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"removeFunction\"]) Module[\"removeFunction\"] = function () {\n  abort(\"'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"getFuncWrapper\"]) Module[\"getFuncWrapper\"] = function () {\n  abort(\"'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"prettyPrint\"]) Module[\"prettyPrint\"] = function () {\n  abort(\"'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"makeBigInt\"]) Module[\"makeBigInt\"] = function () {\n  abort(\"'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"dynCall\"]) Module[\"dynCall\"] = function () {\n  abort(\"'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"getCompilerSetting\"]) Module[\"getCompilerSetting\"] = function () {\n  abort(\"'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"stackSave\"]) Module[\"stackSave\"] = function () {\n  abort(\"'stackSave' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"stackRestore\"]) Module[\"stackRestore\"] = function () {\n  abort(\"'stackRestore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"stackAlloc\"]) Module[\"stackAlloc\"] = function () {\n  abort(\"'stackAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"establishStackSpace\"]) Module[\"establishStackSpace\"] = function () {\n  abort(\"'establishStackSpace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"print\"]) Module[\"print\"] = function () {\n  abort(\"'print' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"printErr\"]) Module[\"printErr\"] = function () {\n  abort(\"'printErr' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"intArrayFromBase64\"]) Module[\"intArrayFromBase64\"] = function () {\n  abort(\"'intArrayFromBase64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"tryParseAsDataURI\"]) Module[\"tryParseAsDataURI\"] = function () {\n  abort(\"'tryParseAsDataURI' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!Module[\"ALLOC_NORMAL\"]) Object.defineProperty(Module, \"ALLOC_NORMAL\", {\n  get: function () {\n    abort(\"'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  }\n});\nif (!Module[\"ALLOC_STACK\"]) Object.defineProperty(Module, \"ALLOC_STACK\", {\n  get: function () {\n    abort(\"'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  }\n});\nif (!Module[\"ALLOC_STATIC\"]) Object.defineProperty(Module, \"ALLOC_STATIC\", {\n  get: function () {\n    abort(\"'ALLOC_STATIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  }\n});\nif (!Module[\"ALLOC_DYNAMIC\"]) Object.defineProperty(Module, \"ALLOC_DYNAMIC\", {\n  get: function () {\n    abort(\"'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  }\n});\nif (!Module[\"ALLOC_NONE\"]) Object.defineProperty(Module, \"ALLOC_NONE\", {\n  get: function () {\n    abort(\"'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  }\n});\n\nif (memoryInitializer) {\n  if (!isDataURI(memoryInitializer)) {\n    memoryInitializer = locateFile(memoryInitializer);\n  }\n\n  if (ENVIRONMENT_IS_NODE || ENVIRONMENT_IS_SHELL) {\n    var data = Module['readBinary'](memoryInitializer);\n    HEAPU8.set(data, GLOBAL_BASE);\n  } else {\n    addRunDependency('memory initializer');\n\n    var applyMemoryInitializer = function (data) {\n      if (data.byteLength) data = new Uint8Array(data);\n\n      for (var i = 0; i < data.length; i++) {\n        assert(HEAPU8[GLOBAL_BASE + i] === 0, \"area for memory initializer should not have been touched before it's loaded\");\n      }\n\n      HEAPU8.set(data, GLOBAL_BASE); // Delete the typed array that contains the large blob of the memory initializer request response so that\n      // we won't keep unnecessary memory lying around. However, keep the XHR object itself alive so that e.g.\n      // its .status field can still be accessed later.\n\n      if (Module['memoryInitializerRequest']) delete Module['memoryInitializerRequest'].response;\n      removeRunDependency('memory initializer');\n    };\n\n    function doBrowserLoad() {\n      Module['readAsync'](memoryInitializer, applyMemoryInitializer, function () {\n        throw 'could not load memory initializer ' + memoryInitializer;\n      });\n    }\n\n    var memoryInitializerBytes = tryParseAsDataURI(memoryInitializer);\n\n    if (memoryInitializerBytes) {\n      applyMemoryInitializer(memoryInitializerBytes.buffer);\n    } else if (Module['memoryInitializerRequest']) {\n      // a network request has already been created, just use that\n      function useRequest() {\n        var request = Module['memoryInitializerRequest'];\n        var response = request.response;\n\n        if (request.status !== 200 && request.status !== 0) {\n          var data = tryParseAsDataURI(Module['memoryInitializerRequestURL']);\n\n          if (data) {\n            response = data.buffer;\n          } else {\n            // If you see this warning, the issue may be that you are using locateFile and defining it in JS. That\n            // means that the HTML file doesn't know about it, and when it tries to create the mem init request early, does it to the wrong place.\n            // Look in your browser's devtools network console to see what's going on.\n            console.warn('a problem seems to have happened with Module.memoryInitializerRequest, status: ' + request.status + ', retrying ' + memoryInitializer);\n            doBrowserLoad();\n            return;\n          }\n        }\n\n        applyMemoryInitializer(response);\n      }\n\n      if (Module['memoryInitializerRequest'].response) {\n        setTimeout(useRequest, 0); // it's already here; but, apply it asynchronously\n      } else {\n        Module['memoryInitializerRequest'].addEventListener('load', useRequest); // wait for it\n      }\n    } else {\n      // fetch it from the network ourselves\n      doBrowserLoad();\n    }\n  }\n}\n/**\r\n * @constructor\r\n * @extends {Error}\r\n * @this {ExitStatus}\r\n */\n\n\nfunction ExitStatus(status) {\n  this.name = \"ExitStatus\";\n  this.message = \"Program terminated with exit(\" + status + \")\";\n  this.status = status;\n}\n\n;\nExitStatus.prototype = new Error();\nExitStatus.prototype.constructor = ExitStatus;\nvar initialStackTop;\nvar calledMain = false;\n\ndependenciesFulfilled = function runCaller() {\n  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n  if (!Module['calledRun']) run();\n  if (!Module['calledRun']) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n};\n/** @type {function(Array=)} */\n\n\nfunction run(args) {\n  args = args || Module['arguments'];\n\n  if (runDependencies > 0) {\n    return;\n  }\n\n  writeStackCookie();\n  preRun();\n  if (runDependencies > 0) return; // a preRun added a dependency, run will be called later\n\n  if (Module['calledRun']) return; // run may have just been called through dependencies being fulfilled just in this very frame\n\n  function doRun() {\n    if (Module['calledRun']) return; // run may have just been called while the async setStatus time below was happening\n\n    Module['calledRun'] = true;\n    if (ABORT) return;\n    ensureInitRuntime();\n    preMain();\n    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\n    assert(!Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]');\n    postRun();\n  }\n\n  if (Module['setStatus']) {\n    Module['setStatus']('Running...');\n    setTimeout(function () {\n      setTimeout(function () {\n        Module['setStatus']('');\n      }, 1);\n      doRun();\n    }, 1);\n  } else {\n    doRun();\n  }\n\n  checkStackCookie();\n}\n\nModule['run'] = run;\n\nfunction checkUnflushedContent() {\n  // Compiler settings do not allow exiting the runtime, so flushing\n  // the streams is not possible. but in ASSERTIONS mode we check\n  // if there was something to flush, and if so tell the user they\n  // should request that the runtime be exitable.\n  // Normally we would not even include flush() at all, but in ASSERTIONS\n  // builds we do so just for this check, and here we see if there is any\n  // content to flush, that is, we check if there would have been\n  // something a non-ASSERTIONS build would have not seen.\n  // How we flush the streams depends on whether we are in NO_FILESYSTEM\n  // mode (which has its own special function for this; otherwise, all\n  // the code is inside libc)\n  var print = out;\n  var printErr = err;\n  var has = false;\n\n  out = err = function (x) {\n    has = true;\n  };\n\n  try {\n    // it doesn't matter if it fails\n    var flush = flush_NO_FILESYSTEM;\n    if (flush) flush(0);\n  } catch (e) {}\n\n  out = print;\n  err = printErr;\n\n  if (has) {\n    warnOnce('stdio streams had content in them that was not flushed. you should set NO_EXIT_RUNTIME to 0 (see the FAQ), or make sure to emit a newline when you printf etc.');\n  }\n}\n\nfunction exit(status, implicit) {\n  checkUnflushedContent(); // if this is just main exit-ing implicitly, and the status is 0, then we\n  // don't need to do anything here and can just leave. if the status is\n  // non-zero, though, then we need to report it.\n  // (we may have warned about this earlier, if a situation justifies doing so)\n\n  if (implicit && Module['noExitRuntime'] && status === 0) {\n    return;\n  }\n\n  if (Module['noExitRuntime']) {\n    // if exit() was called, we may warn the user if the runtime isn't actually being shut down\n    if (!implicit) {\n      err('exit(' + status + ') called, but NO_EXIT_RUNTIME is set, so halting execution but not exiting the runtime or preventing further async execution (build with NO_EXIT_RUNTIME=0, if you want a true shutdown)');\n    }\n  } else {\n    ABORT = true;\n    EXITSTATUS = status;\n    STACKTOP = initialStackTop;\n    exitRuntime();\n    if (Module['onExit']) Module['onExit'](status);\n  }\n\n  Module['quit'](status, new ExitStatus(status));\n}\n\nvar abortDecorators = [];\n\nfunction abort(what) {\n  if (Module['onAbort']) {\n    Module['onAbort'](what);\n  }\n\n  if (what !== undefined) {\n    out(what);\n    err(what);\n    what = JSON.stringify(what);\n  } else {\n    what = '';\n  }\n\n  ABORT = true;\n  EXITSTATUS = 1;\n  var extra = '';\n  var output = 'abort(' + what + ') at ' + stackTrace() + extra;\n\n  if (abortDecorators) {\n    abortDecorators.forEach(function (decorator) {\n      output = decorator(output, what);\n    });\n  }\n\n  throw output;\n}\n\nModule['abort'] = abort; // {{PRE_RUN_ADDITIONS}}\n\nif (Module['preInit']) {\n  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\n\n  while (Module['preInit'].length > 0) {\n    Module['preInit'].pop()();\n  }\n}\n\nModule[\"noExitRuntime\"] = true;\nrun(); // {{POST_RUN_ADDITIONS}}\n// {{MODULE_ADDITIONS}}\n/* WEBPACK VAR INJECTION */}.call(this, \"/\"))\n\n//# sourceURL=webpack:///../cmake-build-debug/craft_gen.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/index.js":
/*!***************************************!*\
  !*** ./node_modules/aabb-3d/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = AABB\r\n\r\nvar vec3 = __webpack_require__(/*! gl-vec3 */ \"./node_modules/gl-vec3/index.js\")\r\n\r\nfunction AABB(pos, vec) {\r\n\r\n  if(!(this instanceof AABB)) {\r\n    return new AABB(pos, vec)\r\n  }\r\n\r\n  var pos2 = vec3.create()\r\n  vec3.add(pos2, pos, vec)\r\n \r\n  this.base = vec3.min(vec3.create(), pos, pos2)\r\n  this.vec = vec3.clone(vec)\r\n  this.max = vec3.max(vec3.create(), pos, pos2)\r\n\r\n  this.mag = vec3.length(this.vec)\r\n\r\n}\r\n\r\nvar cons = AABB\r\n  , proto = cons.prototype\r\n\r\nproto.width = function() {\r\n  return this.vec[0]\r\n}\r\n\r\nproto.height = function() {\r\n  return this.vec[1]\r\n}\r\n\r\nproto.depth = function() {\r\n  return this.vec[2]\r\n}\r\n\r\nproto.x0 = function() {\r\n  return this.base[0]\r\n}\r\n\r\nproto.y0 = function() {\r\n  return this.base[1]\r\n}\r\n\r\nproto.z0 = function() {\r\n  return this.base[2]\r\n}\r\n\r\nproto.x1 = function() {\r\n  return this.max[0]\r\n}\r\n\r\nproto.y1 = function() {\r\n  return this.max[1]\r\n}\r\n\r\nproto.z1 = function() {\r\n  return this.max[2]\r\n}\r\n\r\nproto.translate = function(by) {\r\n  vec3.add(this.max, this.max, by)\r\n  vec3.add(this.base, this.base, by)\r\n  return this\r\n}\r\n\r\nproto.setPosition = function(pos) {\r\n  vec3.add(this.max, pos, this.vec)\r\n  vec3.copy(this.base, pos)\r\n  return this\r\n}\r\n\r\nproto.expand = function(aabb) {\r\n  var max = vec3.create()\r\n    , min = vec3.create()\r\n\r\n  vec3.max(max, aabb.max, this.max)\r\n  vec3.min(min, aabb.base, this.base)\r\n  vec3.subtract(max, max, min)\r\n\r\n  return new AABB(min, max)\r\n}\r\n\r\nproto.intersects = function(aabb) {\r\n  if(aabb.base[0] > this.max[0]) return false\r\n  if(aabb.base[1] > this.max[1]) return false\r\n  if(aabb.base[2] > this.max[2]) return false\r\n  if(aabb.max[0] < this.base[0]) return false\r\n  if(aabb.max[1] < this.base[1]) return false\r\n  if(aabb.max[2] < this.base[2]) return false\r\n\r\n  return true\r\n}\r\n\r\nproto.touches = function(aabb) {\r\n\r\n  var intersection = this.union(aabb);\r\n\r\n  return (intersection !== null) &&\r\n         ((intersection.width() == 0) ||\r\n         (intersection.height() == 0) || \r\n         (intersection.depth() == 0))\r\n\r\n}\r\n\r\nproto.union = function(aabb) {\r\n  if(!this.intersects(aabb)) return null\r\n\r\n  var base_x = Math.max(aabb.base[0], this.base[0])\r\n    , base_y = Math.max(aabb.base[1], this.base[1])\r\n    , base_z = Math.max(aabb.base[2], this.base[2])\r\n    , max_x = Math.min(aabb.max[0], this.max[0])\r\n    , max_y = Math.min(aabb.max[1], this.max[1])\r\n    , max_z = Math.min(aabb.max[2], this.max[2])\r\n\r\n  return new AABB([base_x, base_y, base_z], [max_x - base_x, max_y - base_y, max_z - base_z])\r\n}\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/index.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/add.js":
/*!*************************************!*\
  !*** ./node_modules/gl-vec3/add.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = add;\n\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction add(out, a, b) {\n    out[0] = a[0] + b[0]\n    out[1] = a[1] + b[1]\n    out[2] = a[2] + b[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/add.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/angle.js":
/*!***************************************!*\
  !*** ./node_modules/gl-vec3/angle.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = angle\n\nvar fromValues = __webpack_require__(/*! ./fromValues */ \"./node_modules/gl-vec3/fromValues.js\")\nvar normalize = __webpack_require__(/*! ./normalize */ \"./node_modules/gl-vec3/normalize.js\")\nvar dot = __webpack_require__(/*! ./dot */ \"./node_modules/gl-vec3/dot.js\")\n\n/**\n * Get the angle between two 3D vectors\n * @param {vec3} a The first operand\n * @param {vec3} b The second operand\n * @returns {Number} The angle in radians\n */\nfunction angle(a, b) {\n    var tempA = fromValues(a[0], a[1], a[2])\n    var tempB = fromValues(b[0], b[1], b[2])\n \n    normalize(tempA, tempA)\n    normalize(tempB, tempB)\n \n    var cosine = dot(tempA, tempB)\n\n    if(cosine > 1.0){\n        return 0\n    } else {\n        return Math.acos(cosine)\n    }     \n}\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/angle.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/ceil.js":
/*!**************************************!*\
  !*** ./node_modules/gl-vec3/ceil.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = ceil\n\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to ceil\n * @returns {vec3} out\n */\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0])\n  out[1] = Math.ceil(a[1])\n  out[2] = Math.ceil(a[2])\n  return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/ceil.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/clone.js":
/*!***************************************!*\
  !*** ./node_modules/gl-vec3/clone.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = clone;\n\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {vec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\nfunction clone(a) {\n    var out = new Float32Array(3)\n    out[0] = a[0]\n    out[1] = a[1]\n    out[2] = a[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/clone.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/copy.js":
/*!**************************************!*\
  !*** ./node_modules/gl-vec3/copy.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = copy;\n\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the source vector\n * @returns {vec3} out\n */\nfunction copy(out, a) {\n    out[0] = a[0]\n    out[1] = a[1]\n    out[2] = a[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/copy.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/create.js":
/*!****************************************!*\
  !*** ./node_modules/gl-vec3/create.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = create;\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\nfunction create() {\n    var out = new Float32Array(3)\n    out[0] = 0\n    out[1] = 0\n    out[2] = 0\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/create.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/cross.js":
/*!***************************************!*\
  !*** ./node_modules/gl-vec3/cross.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = cross;\n\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction cross(out, a, b) {\n    var ax = a[0], ay = a[1], az = a[2],\n        bx = b[0], by = b[1], bz = b[2]\n\n    out[0] = ay * bz - az * by\n    out[1] = az * bx - ax * bz\n    out[2] = ax * by - ay * bx\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/cross.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/dist.js":
/*!**************************************!*\
  !*** ./node_modules/gl-vec3/dist.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./distance */ \"./node_modules/gl-vec3/distance.js\")\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/dist.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/distance.js":
/*!******************************************!*\
  !*** ./node_modules/gl-vec3/distance.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = distance;\n\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} distance between a and b\n */\nfunction distance(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1],\n        z = b[2] - a[2]\n    return Math.sqrt(x*x + y*y + z*z)\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/distance.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/div.js":
/*!*************************************!*\
  !*** ./node_modules/gl-vec3/div.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./divide */ \"./node_modules/gl-vec3/divide.js\")\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/div.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/divide.js":
/*!****************************************!*\
  !*** ./node_modules/gl-vec3/divide.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = divide;\n\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction divide(out, a, b) {\n    out[0] = a[0] / b[0]\n    out[1] = a[1] / b[1]\n    out[2] = a[2] / b[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/divide.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/dot.js":
/*!*************************************!*\
  !*** ./node_modules/gl-vec3/dot.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = dot;\n\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} dot product of a and b\n */\nfunction dot(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/dot.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/epsilon.js":
/*!*****************************************!*\
  !*** ./node_modules/gl-vec3/epsilon.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = 0.000001\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/epsilon.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/equals.js":
/*!****************************************!*\
  !*** ./node_modules/gl-vec3/equals.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = equals\n\nvar EPSILON = __webpack_require__(/*! ./epsilon */ \"./node_modules/gl-vec3/epsilon.js\")\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction equals(a, b) {\n  var a0 = a[0]\n  var a1 = a[1]\n  var a2 = a[2]\n  var b0 = b[0]\n  var b1 = b[1]\n  var b2 = b[2]\n  return (Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n          Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n          Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)))\n}\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/equals.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/exactEquals.js":
/*!*********************************************!*\
  !*** ./node_modules/gl-vec3/exactEquals.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = exactEquals\n\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2]\n}\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/exactEquals.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/floor.js":
/*!***************************************!*\
  !*** ./node_modules/gl-vec3/floor.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = floor\n\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to floor\n * @returns {vec3} out\n */\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0])\n  out[1] = Math.floor(a[1])\n  out[2] = Math.floor(a[2])\n  return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/floor.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/forEach.js":
/*!*****************************************!*\
  !*** ./node_modules/gl-vec3/forEach.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = forEach;\n\nvar vec = __webpack_require__(/*! ./create */ \"./node_modules/gl-vec3/create.js\")()\n\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nfunction forEach(a, stride, offset, count, fn, arg) {\n        var i, l\n        if(!stride) {\n            stride = 3\n        }\n\n        if(!offset) {\n            offset = 0\n        }\n        \n        if(count) {\n            l = Math.min((count * stride) + offset, a.length)\n        } else {\n            l = a.length\n        }\n\n        for(i = offset; i < l; i += stride) {\n            vec[0] = a[i] \n            vec[1] = a[i+1] \n            vec[2] = a[i+2]\n            fn(vec, vec, arg)\n            a[i] = vec[0] \n            a[i+1] = vec[1] \n            a[i+2] = vec[2]\n        }\n        \n        return a\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/forEach.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/fromValues.js":
/*!********************************************!*\
  !*** ./node_modules/gl-vec3/fromValues.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = fromValues;\n\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\nfunction fromValues(x, y, z) {\n    var out = new Float32Array(3)\n    out[0] = x\n    out[1] = y\n    out[2] = z\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/fromValues.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/index.js":
/*!***************************************!*\
  !*** ./node_modules/gl-vec3/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = {\n  EPSILON: __webpack_require__(/*! ./epsilon */ \"./node_modules/gl-vec3/epsilon.js\")\n  , create: __webpack_require__(/*! ./create */ \"./node_modules/gl-vec3/create.js\")\n  , clone: __webpack_require__(/*! ./clone */ \"./node_modules/gl-vec3/clone.js\")\n  , angle: __webpack_require__(/*! ./angle */ \"./node_modules/gl-vec3/angle.js\")\n  , fromValues: __webpack_require__(/*! ./fromValues */ \"./node_modules/gl-vec3/fromValues.js\")\n  , copy: __webpack_require__(/*! ./copy */ \"./node_modules/gl-vec3/copy.js\")\n  , set: __webpack_require__(/*! ./set */ \"./node_modules/gl-vec3/set.js\")\n  , equals: __webpack_require__(/*! ./equals */ \"./node_modules/gl-vec3/equals.js\")\n  , exactEquals: __webpack_require__(/*! ./exactEquals */ \"./node_modules/gl-vec3/exactEquals.js\")\n  , add: __webpack_require__(/*! ./add */ \"./node_modules/gl-vec3/add.js\")\n  , subtract: __webpack_require__(/*! ./subtract */ \"./node_modules/gl-vec3/subtract.js\")\n  , sub: __webpack_require__(/*! ./sub */ \"./node_modules/gl-vec3/sub.js\")\n  , multiply: __webpack_require__(/*! ./multiply */ \"./node_modules/gl-vec3/multiply.js\")\n  , mul: __webpack_require__(/*! ./mul */ \"./node_modules/gl-vec3/mul.js\")\n  , divide: __webpack_require__(/*! ./divide */ \"./node_modules/gl-vec3/divide.js\")\n  , div: __webpack_require__(/*! ./div */ \"./node_modules/gl-vec3/div.js\")\n  , min: __webpack_require__(/*! ./min */ \"./node_modules/gl-vec3/min.js\")\n  , max: __webpack_require__(/*! ./max */ \"./node_modules/gl-vec3/max.js\")\n  , floor: __webpack_require__(/*! ./floor */ \"./node_modules/gl-vec3/floor.js\")\n  , ceil: __webpack_require__(/*! ./ceil */ \"./node_modules/gl-vec3/ceil.js\")\n  , round: __webpack_require__(/*! ./round */ \"./node_modules/gl-vec3/round.js\")\n  , scale: __webpack_require__(/*! ./scale */ \"./node_modules/gl-vec3/scale.js\")\n  , scaleAndAdd: __webpack_require__(/*! ./scaleAndAdd */ \"./node_modules/gl-vec3/scaleAndAdd.js\")\n  , distance: __webpack_require__(/*! ./distance */ \"./node_modules/gl-vec3/distance.js\")\n  , dist: __webpack_require__(/*! ./dist */ \"./node_modules/gl-vec3/dist.js\")\n  , squaredDistance: __webpack_require__(/*! ./squaredDistance */ \"./node_modules/gl-vec3/squaredDistance.js\")\n  , sqrDist: __webpack_require__(/*! ./sqrDist */ \"./node_modules/gl-vec3/sqrDist.js\")\n  , length: __webpack_require__(/*! ./length */ \"./node_modules/gl-vec3/length.js\")\n  , len: __webpack_require__(/*! ./len */ \"./node_modules/gl-vec3/len.js\")\n  , squaredLength: __webpack_require__(/*! ./squaredLength */ \"./node_modules/gl-vec3/squaredLength.js\")\n  , sqrLen: __webpack_require__(/*! ./sqrLen */ \"./node_modules/gl-vec3/sqrLen.js\")\n  , negate: __webpack_require__(/*! ./negate */ \"./node_modules/gl-vec3/negate.js\")\n  , inverse: __webpack_require__(/*! ./inverse */ \"./node_modules/gl-vec3/inverse.js\")\n  , normalize: __webpack_require__(/*! ./normalize */ \"./node_modules/gl-vec3/normalize.js\")\n  , dot: __webpack_require__(/*! ./dot */ \"./node_modules/gl-vec3/dot.js\")\n  , cross: __webpack_require__(/*! ./cross */ \"./node_modules/gl-vec3/cross.js\")\n  , lerp: __webpack_require__(/*! ./lerp */ \"./node_modules/gl-vec3/lerp.js\")\n  , random: __webpack_require__(/*! ./random */ \"./node_modules/gl-vec3/random.js\")\n  , transformMat4: __webpack_require__(/*! ./transformMat4 */ \"./node_modules/gl-vec3/transformMat4.js\")\n  , transformMat3: __webpack_require__(/*! ./transformMat3 */ \"./node_modules/gl-vec3/transformMat3.js\")\n  , transformQuat: __webpack_require__(/*! ./transformQuat */ \"./node_modules/gl-vec3/transformQuat.js\")\n  , rotateX: __webpack_require__(/*! ./rotateX */ \"./node_modules/gl-vec3/rotateX.js\")\n  , rotateY: __webpack_require__(/*! ./rotateY */ \"./node_modules/gl-vec3/rotateY.js\")\n  , rotateZ: __webpack_require__(/*! ./rotateZ */ \"./node_modules/gl-vec3/rotateZ.js\")\n  , forEach: __webpack_require__(/*! ./forEach */ \"./node_modules/gl-vec3/forEach.js\")\n}\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/index.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/inverse.js":
/*!*****************************************!*\
  !*** ./node_modules/gl-vec3/inverse.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = inverse;\n\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to invert\n * @returns {vec3} out\n */\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0]\n  out[1] = 1.0 / a[1]\n  out[2] = 1.0 / a[2]\n  return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/inverse.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/len.js":
/*!*************************************!*\
  !*** ./node_modules/gl-vec3/len.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./length */ \"./node_modules/gl-vec3/length.js\")\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/len.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/length.js":
/*!****************************************!*\
  !*** ./node_modules/gl-vec3/length.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = length;\n\n/**\n * Calculates the length of a vec3\n *\n * @param {vec3} a vector to calculate length of\n * @returns {Number} length of a\n */\nfunction length(a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2]\n    return Math.sqrt(x*x + y*y + z*z)\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/length.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/lerp.js":
/*!**************************************!*\
  !*** ./node_modules/gl-vec3/lerp.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = lerp;\n\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec3} out\n */\nfunction lerp(out, a, b, t) {\n    var ax = a[0],\n        ay = a[1],\n        az = a[2]\n    out[0] = ax + t * (b[0] - ax)\n    out[1] = ay + t * (b[1] - ay)\n    out[2] = az + t * (b[2] - az)\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/lerp.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/max.js":
/*!*************************************!*\
  !*** ./node_modules/gl-vec3/max.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = max;\n\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction max(out, a, b) {\n    out[0] = Math.max(a[0], b[0])\n    out[1] = Math.max(a[1], b[1])\n    out[2] = Math.max(a[2], b[2])\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/max.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/min.js":
/*!*************************************!*\
  !*** ./node_modules/gl-vec3/min.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = min;\n\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction min(out, a, b) {\n    out[0] = Math.min(a[0], b[0])\n    out[1] = Math.min(a[1], b[1])\n    out[2] = Math.min(a[2], b[2])\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/min.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/mul.js":
/*!*************************************!*\
  !*** ./node_modules/gl-vec3/mul.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./multiply */ \"./node_modules/gl-vec3/multiply.js\")\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/mul.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/multiply.js":
/*!******************************************!*\
  !*** ./node_modules/gl-vec3/multiply.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = multiply;\n\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction multiply(out, a, b) {\n    out[0] = a[0] * b[0]\n    out[1] = a[1] * b[1]\n    out[2] = a[2] * b[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/multiply.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/negate.js":
/*!****************************************!*\
  !*** ./node_modules/gl-vec3/negate.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = negate;\n\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to negate\n * @returns {vec3} out\n */\nfunction negate(out, a) {\n    out[0] = -a[0]\n    out[1] = -a[1]\n    out[2] = -a[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/negate.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/normalize.js":
/*!*******************************************!*\
  !*** ./node_modules/gl-vec3/normalize.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = normalize;\n\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to normalize\n * @returns {vec3} out\n */\nfunction normalize(out, a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2]\n    var len = x*x + y*y + z*z\n    if (len > 0) {\n        //TODO: evaluate use of glm_invsqrt here?\n        len = 1 / Math.sqrt(len)\n        out[0] = a[0] * len\n        out[1] = a[1] * len\n        out[2] = a[2] * len\n    }\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/normalize.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/random.js":
/*!****************************************!*\
  !*** ./node_modules/gl-vec3/random.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = random;\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\nfunction random(out, scale) {\n    scale = scale || 1.0\n\n    var r = Math.random() * 2.0 * Math.PI\n    var z = (Math.random() * 2.0) - 1.0\n    var zScale = Math.sqrt(1.0-z*z) * scale\n\n    out[0] = Math.cos(r) * zScale\n    out[1] = Math.sin(r) * zScale\n    out[2] = z * scale\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/random.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/rotateX.js":
/*!*****************************************!*\
  !*** ./node_modules/gl-vec3/rotateX.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = rotateX;\n\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateX(out, a, b, c){\n    var by = b[1]\n    var bz = b[2]\n\n    // Translate point to the origin\n    var py = a[1] - by\n    var pz = a[2] - bz\n\n    var sc = Math.sin(c)\n    var cc = Math.cos(c)\n\n    // perform rotation and translate to correct position\n    out[0] = a[0]\n    out[1] = by + py * cc - pz * sc\n    out[2] = bz + py * sc + pz * cc\n\n    return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/rotateX.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/rotateY.js":
/*!*****************************************!*\
  !*** ./node_modules/gl-vec3/rotateY.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = rotateY;\n\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateY(out, a, b, c){\n    var bx = b[0]\n    var bz = b[2]\n\n    // translate point to the origin\n    var px = a[0] - bx\n    var pz = a[2] - bz\n    \n    var sc = Math.sin(c)\n    var cc = Math.cos(c)\n  \n    // perform rotation and translate to correct position\n    out[0] = bx + pz * sc + px * cc\n    out[1] = a[1]\n    out[2] = bz + pz * cc - px * sc\n  \n    return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/rotateY.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/rotateZ.js":
/*!*****************************************!*\
  !*** ./node_modules/gl-vec3/rotateZ.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = rotateZ;\n\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateZ(out, a, b, c){\n    var bx = b[0]\n    var by = b[1]\n\n    //Translate point to the origin\n    var px = a[0] - bx\n    var py = a[1] - by\n  \n    var sc = Math.sin(c)\n    var cc = Math.cos(c)\n\n    // perform rotation and translate to correct position\n    out[0] = bx + px * cc - py * sc\n    out[1] = by + px * sc + py * cc\n    out[2] = a[2]\n  \n    return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/rotateZ.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/round.js":
/*!***************************************!*\
  !*** ./node_modules/gl-vec3/round.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = round\n\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to round\n * @returns {vec3} out\n */\nfunction round(out, a) {\n  out[0] = Math.round(a[0])\n  out[1] = Math.round(a[1])\n  out[2] = Math.round(a[2])\n  return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/round.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/scale.js":
/*!***************************************!*\
  !*** ./node_modules/gl-vec3/scale.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = scale;\n\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\nfunction scale(out, a, b) {\n    out[0] = a[0] * b\n    out[1] = a[1] * b\n    out[2] = a[2] * b\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/scale.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/scaleAndAdd.js":
/*!*********************************************!*\
  !*** ./node_modules/gl-vec3/scaleAndAdd.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = scaleAndAdd;\n\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\nfunction scaleAndAdd(out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale)\n    out[1] = a[1] + (b[1] * scale)\n    out[2] = a[2] + (b[2] * scale)\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/scaleAndAdd.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/set.js":
/*!*************************************!*\
  !*** ./node_modules/gl-vec3/set.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = set;\n\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\nfunction set(out, x, y, z) {\n    out[0] = x\n    out[1] = y\n    out[2] = z\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/set.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/sqrDist.js":
/*!*****************************************!*\
  !*** ./node_modules/gl-vec3/sqrDist.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./squaredDistance */ \"./node_modules/gl-vec3/squaredDistance.js\")\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/sqrDist.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/sqrLen.js":
/*!****************************************!*\
  !*** ./node_modules/gl-vec3/sqrLen.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./squaredLength */ \"./node_modules/gl-vec3/squaredLength.js\")\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/sqrLen.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/squaredDistance.js":
/*!*************************************************!*\
  !*** ./node_modules/gl-vec3/squaredDistance.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = squaredDistance;\n\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\nfunction squaredDistance(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1],\n        z = b[2] - a[2]\n    return x*x + y*y + z*z\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/squaredDistance.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/squaredLength.js":
/*!***********************************************!*\
  !*** ./node_modules/gl-vec3/squaredLength.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = squaredLength;\n\n/**\n * Calculates the squared length of a vec3\n *\n * @param {vec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nfunction squaredLength(a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2]\n    return x*x + y*y + z*z\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/squaredLength.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/sub.js":
/*!*************************************!*\
  !*** ./node_modules/gl-vec3/sub.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./subtract */ \"./node_modules/gl-vec3/subtract.js\")\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/sub.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/subtract.js":
/*!******************************************!*\
  !*** ./node_modules/gl-vec3/subtract.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = subtract;\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction subtract(out, a, b) {\n    out[0] = a[0] - b[0]\n    out[1] = a[1] - b[1]\n    out[2] = a[2] - b[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/subtract.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/transformMat3.js":
/*!***********************************************!*\
  !*** ./node_modules/gl-vec3/transformMat3.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = transformMat3;\n\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\nfunction transformMat3(out, a, m) {\n    var x = a[0], y = a[1], z = a[2]\n    out[0] = x * m[0] + y * m[3] + z * m[6]\n    out[1] = x * m[1] + y * m[4] + z * m[7]\n    out[2] = x * m[2] + y * m[5] + z * m[8]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/transformMat3.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/transformMat4.js":
/*!***********************************************!*\
  !*** ./node_modules/gl-vec3/transformMat4.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = transformMat4;\n\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec3} out\n */\nfunction transformMat4(out, a, m) {\n    var x = a[0], y = a[1], z = a[2],\n        w = m[3] * x + m[7] * y + m[11] * z + m[15]\n    w = w || 1.0\n    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w\n    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w\n    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/transformMat4.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/transformQuat.js":
/*!***********************************************!*\
  !*** ./node_modules/gl-vec3/transformQuat.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = transformQuat;\n\n/**\n * Transforms the vec3 with a quat\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {quat} q quaternion to transform with\n * @returns {vec3} out\n */\nfunction transformQuat(out, a, q) {\n    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations\n\n    var x = a[0], y = a[1], z = a[2],\n        qx = q[0], qy = q[1], qz = q[2], qw = q[3],\n\n        // calculate quat * vec\n        ix = qw * x + qy * z - qz * y,\n        iy = qw * y + qz * x - qx * z,\n        iz = qw * z + qx * y - qy * x,\n        iw = -qx * x - qy * y - qz * z\n\n    // calculate result * inverse quat\n    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy\n    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz\n    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/transformQuat.js?");

/***/ }),

/***/ "./node_modules/voxel-aabb-sweep/index.js":
/*!************************************************!*\
  !*** ./node_modules/voxel-aabb-sweep/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n// reused array instances\n\nvar tr_arr = []\nvar ldi_arr = []\nvar tri_arr = []\nvar step_arr = []\nvar tDelta_arr = []\nvar tNext_arr = []\nvar vec_arr = []\nvar normed_arr = []\nvar base_arr = []\nvar max_arr = []\nvar left_arr = []\nvar result_arr = []\n\n\n\n// core implementation:\n\nfunction sweep_impl(getVoxel, callback, vec, base, max, epsilon) {\n\n    // consider algo as a raycast along the AABB's leading corner\n    // as raycast enters each new voxel, iterate in 2D over the AABB's \n    // leading face in that axis looking for collisions\n    // \n    // original raycast implementation: https://github.com/andyhall/fast-voxel-raycast\n    // original raycast paper: http://www.cse.chalmers.se/edu/year/2010/course/TDA361/grid.pdf\n\n    var tr = tr_arr\n    var ldi = ldi_arr\n    var tri = tri_arr\n    var step = step_arr\n    var tDelta = tDelta_arr\n    var tNext = tNext_arr\n    var normed = normed_arr\n\n    var floor = Math.floor\n    var cumulative_t = 0.0\n    var t = 0.0\n    var max_t = 0.0\n    var axis = 0\n    var i = 0\n\n\n    // init for the current sweep vector and take first step\n    initSweep()\n    if (max_t === 0) return 0\n\n    axis = stepForward()\n\n    // loop along raycast vector\n    while (t <= max_t) {\n\n        // sweeps over leading face of AABB\n        if (checkCollision(axis)) {\n            // calls the callback and decides whether to continue\n            var done = handleCollision()\n            if (done) return cumulative_t\n        }\n\n        axis = stepForward()\n    }\n\n    // reached the end of the vector unobstructed, finish and exit\n    cumulative_t += max_t\n    for (i = 0; i < 3; i++) {\n        base[i] += vec[i]\n        max[i] += vec[i]\n    }\n    return cumulative_t\n\n\n\n\n\n    // low-level implementations of each step:\n    function initSweep() {\n\n        // parametrization t along raycast\n        t = 0.0\n        max_t = Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2])\n        if (max_t === 0) return\n        for (var i = 0; i < 3; i++) {\n            var dir = (vec[i] >= 0)\n            step[i] = dir ? 1 : -1\n            // trailing / trailing edge coords\n            var lead = dir ? max[i] : base[i]\n            tr[i] = dir ? base[i] : max[i]\n            // int values of lead/trail edges\n            ldi[i] = leadEdgeToInt(lead, step[i])\n            tri[i] = trailEdgeToInt(tr[i], step[i])\n            // normed vector\n            normed[i] = vec[i] / max_t\n            // distance along t required to move one voxel in each axis\n            tDelta[i] = Math.abs(1 / normed[i])\n            // location of nearest voxel boundary, in units of t \n            var dist = dir ? (ldi[i] + 1 - lead) : (lead - ldi[i])\n            tNext[i] = (tDelta[i] < Infinity) ? tDelta[i] * dist : Infinity\n        }\n\n    }\n\n\n    // check for collisions - iterate over the leading face on the advancing axis\n\n    function checkCollision(i_axis) {\n        var stepx = step[0]\n        var x0 = (i_axis === 0) ? ldi[0] : tri[0]\n        var x1 = ldi[0] + stepx\n\n        var stepy = step[1]\n        var y0 = (i_axis === 1) ? ldi[1] : tri[1]\n        var y1 = ldi[1] + stepy\n\n        var stepz = step[2]\n        var z0 = (i_axis === 2) ? ldi[2] : tri[2]\n        var z1 = ldi[2] + stepz\n\n        // var j_axis = (i_axis + 1) % 3\n        // var k_axis = (i_axis + 2) % 3\n        // var s = ['x', 'y', 'z'][i_axis]\n        // var js = ['x', 'y', 'z'][j_axis]\n        // var ks = ['x', 'y', 'z'][k_axis]\n        // var i0 = [x0, y0, z0][i_axis]\n        // var j0 = [x0, y0, z0][j_axis]\n        // var k0 = [x0, y0, z0][k_axis]\n        // var i1 = [x1 - stepx, y1 - stepy, z1 - stepz][i_axis]\n        // var j1 = [x1 - stepx, y1 - stepy, z1 - stepz][j_axis]\n        // var k1 = [x1 - stepx, y1 - stepy, z1 - stepz][k_axis]\n        // console.log('=== step', s, 'to', i0, '   sweep', js, j0 + ',' + j1, '   ', ks, k0 + ',' + k1)\n\n        for (var x = x0; x != x1; x += stepx) {\n            for (var y = y0; y != y1; y += stepy) {\n                for (var z = z0; z != z1; z += stepz) {\n                    if (getVoxel(x, y, z)) return true\n                }\n            }\n        }\n        return false\n    }\n\n\n    // on collision - call the callback and return or set up for the next sweep\n\n    function handleCollision() {\n\n        // set up for callback\n        cumulative_t += t\n        var dir = step[axis]\n\n        // vector moved so far, and left to move\n        var done = t / max_t\n        var left = left_arr\n        for (i = 0; i < 3; i++) {\n            var dv = vec[i] * done\n            base[i] += dv\n            max[i] += dv\n            left[i] = vec[i] - dv\n        }\n\n        // set leading edge of stepped axis exactly to voxel boundary\n        // else we'll sometimes rounding error beyond it\n        if (dir > 0) {\n            max[axis] = Math.round(max[axis])\n        } else {\n            base[axis] = Math.round(base[axis])\n        }\n        \n        // call back to let client update the \"left to go\" vector\n        var res = callback(cumulative_t, axis, dir, left)\n\n        // bail out out on truthy response\n        if (res) return true\n\n        // init for new sweep along vec\n        for (i = 0; i < 3; i++) vec[i] = left[i]\n        initSweep()\n        if (max_t === 0) return true // no vector left\n\n        return false\n    }\n\n\n    // advance to next voxel boundary, and return which axis was stepped\n\n    function stepForward() {\n        var axis = (tNext[0] < tNext[1]) ?\n            ((tNext[0] < tNext[2]) ? 0 : 2) :\n            ((tNext[1] < tNext[2]) ? 1 : 2)\n        var dt = tNext[axis] - t\n        t = tNext[axis]\n        ldi[axis] += step[axis]\n        tNext[axis] += tDelta[axis]\n        for (i = 0; i < 3; i++) {\n            tr[i] += dt * normed[i]\n            tri[i] = trailEdgeToInt(tr[i], step[i])\n        }\n\n        return axis\n    }\n\n\n\n    function leadEdgeToInt(coord, step) {\n        return floor(coord - step * epsilon)\n    }\n    function trailEdgeToInt(coord, step) {\n        return floor(coord + step * epsilon)\n    }\n\n}\n\n\n\n\n\n// conform inputs\n\nfunction sweep(getVoxel, box, dir, callback, noTranslate, epsilon) {\n\n    var vec = vec_arr\n    var base = base_arr\n    var max = max_arr\n    var result = result_arr\n\n    // init parameter float arrays\n    for (var i = 0; i < 3; i++) {\n        vec[i] = +dir[i]\n        max[i] = +box.max[i]\n        base[i] = +box.base[i]\n    }\n\n    if (!epsilon) epsilon = 1e-10\n\n    // run sweep implementation\n    var dist = sweep_impl(getVoxel, callback, vec, base, max, epsilon)\n\n    // translate box by distance needed to updated base value\n    if (!noTranslate) {\n        for (i = 0; i < 3; i++) {\n            result[i] = (dir[i] > 0) ? max[i] - box.max[i] : base[i] - box.base[i]\n        }\n        box.translate(result)\n    }\n\n    // return value is total distance moved (not necessarily magnitude of [end]-[start])\n    return dist\n}\n\nmodule.exports = sweep\n\n\n\n//# sourceURL=webpack:///./node_modules/voxel-aabb-sweep/index.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/src/index.js":
/*!********************************************************!*\
  !*** ./node_modules/voxel-physics-engine/src/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar aabb = __webpack_require__(/*! aabb-3d */ \"./node_modules/aabb-3d/index.js\")\nvar vec3 = __webpack_require__(/*! gl-vec3 */ \"./node_modules/gl-vec3/index.js\")\nvar sweep = __webpack_require__(/*! voxel-aabb-sweep */ \"./node_modules/voxel-aabb-sweep/index.js\")\nvar RigidBody = __webpack_require__(/*! ./rigidBody */ \"./node_modules/voxel-physics-engine/src/rigidBody.js\")\n\n\nvar DEBUG = 0\n\n\nmodule.exports = function (opts, testSolid, testFluid) {\n    return new Physics(opts, testSolid, testFluid)\n}\n\nvar defaults = {\n    gravity: [0, -10, 0],\n    minBounceImpulse: .5, // lowest collision impulse that bounces\n    airDrag: 0.1,\n    fluidDrag: 0.4,\n    fluidDensity: 2.0,\n}\n\n\n/* \n *    CONSTRUCTOR - represents a world of rigid bodies.\n * \n *  Takes testSolid(x,y,z) function to query block solidity\n *  Takes testFluid(x,y,z) function to query if a block is a fluid\n*/\nfunction Physics(opts, testSolid, testFluid) {\n    opts = Object.assign({}, defaults, opts)\n\n    this.gravity = opts.gravity\n    this.airDrag = opts.airDrag\n    this.fluidDensity = opts.fluidDensity\n    this.fluidDrag = opts.fluidDrag\n    this.minBounceImpulse = opts.minBounceImpulse\n    this.bodies = []\n\n    // collision function - TODO: abstract this into a setter?\n    this.testSolid = testSolid\n    this.testFluid = testFluid\n}\n\n\n/*\n *    ADDING AND REMOVING RIGID BODIES\n*/\n\nPhysics.prototype.addBody = function (_aabb, mass, friction,\n    restitution, gravMult, onCollide) {\n    _aabb = _aabb || new aabb([0, 0, 0], [1, 1, 1])\n    if (typeof mass == 'undefined') mass = 1\n    if (typeof friction == 'undefined') friction = 1\n    if (typeof restitution == 'undefined') restitution = 0\n    if (typeof gravMult == 'undefined') gravMult = 1\n    var b = new RigidBody(_aabb, mass, friction, restitution, gravMult, onCollide)\n    this.bodies.push(b)\n    return b\n}\n\nPhysics.prototype.removeBody = function (b) {\n    var i = this.bodies.indexOf(b)\n    if (i < 0) return undefined\n    this.bodies.splice(i, 1)\n    b.aabb = b.onCollide = null\n}\n\n\n\n\n/*\n *    PHYSICS AND COLLISIONS\n*/\n\nvar a = vec3.create()\nvar dv = vec3.create()\nvar dx = vec3.create()\nvar impacts = vec3.create()\nvar oldResting = vec3.create()\n\n\n/*\n *    TICK HANDLER\n*/\nPhysics.prototype.tick = function (dt) {\n    // convert dt to seconds\n    dt = dt / 1000\n    var noGravity = equals(0, vec3.squaredLength(this.gravity))\n\n    this.bodies.forEach(b => iterateBody(this, b, dt, noGravity))\n}\n\n\n\n/*\n *    PER-BODY MAIN PHYSICS ROUTINE\n*/\n\nfunction iterateBody(self, b, dt, noGravity) {\n    vec3.copy(oldResting, b.resting)\n\n    // treat bodies with <= mass as static\n    if (b.mass <= 0) {\n        vec3.set(b.velocity, 0, 0, 0)\n        vec3.set(b._forces, 0, 0, 0)\n        vec3.set(b._impulses, 0, 0, 0)\n        return\n    }\n\n    // skip bodies if static or no velocity/forces/impulses\n    var localNoGrav = noGravity || (b.gravityMultiplier === 0)\n    if (bodyAsleep(self, b, dt, localNoGrav)) return\n    b._sleepFrameCount--\n\n    // check if under water, if so apply buoyancy and drag forces\n    applyFluidForces(self, b)\n\n    // debug hooks\n    sanityCheck(b._forces)\n    sanityCheck(b._impulses)\n    sanityCheck(b.velocity)\n    sanityCheck(b.resting)\n\n    // semi-implicit Euler integration\n\n    // a = f/m + gravity*gravityMultiplier\n    vec3.scale(a, b._forces, 1 / b.mass)\n    vec3.scaleAndAdd(a, a, self.gravity, b.gravityMultiplier)\n\n    // dv = i/m + a*dt\n    // v1 = v0 + dv\n    vec3.scale(dv, b._impulses, 1 / b.mass)\n    vec3.scaleAndAdd(dv, dv, a, dt)\n    vec3.add(b.velocity, b.velocity, dv)\n\n    // apply friction based on change in velocity this frame\n    if (b.friction) {\n        applyFrictionByAxis(0, b, dv)\n        applyFrictionByAxis(1, b, dv)\n        applyFrictionByAxis(2, b, dv)\n    }\n\n    // linear air or fluid friction - effectively v *= drag\n    // body settings override global settings\n    var drag = (b.airDrag >= 0) ? b.airDrag : self.airDrag\n    if (b.inFluid) {\n        drag = (b.fluidDrag >= 0) ? b.fluidDrag : self.fluidDrag\n        drag *= 1 - (1 - b.ratioInFluid) ** 2\n    }\n    var mult = Math.max(1 - drag * dt / b.mass, 0)\n    vec3.scale(b.velocity, b.velocity, mult)\n\n    // x1-x0 = v1*dt\n    vec3.scale(dx, b.velocity, dt)\n\n    // clear forces and impulses for next timestep\n    vec3.set(b._forces, 0, 0, 0)\n    vec3.set(b._impulses, 0, 0, 0)\n\n    // cache old position for use in autostepping\n    if (b.autoStep) {\n        cloneAABB(tmpBox, b.aabb)\n    }\n\n    // sweeps aabb along dx and accounts for collisions\n    processCollisions(self, b.aabb, dx, b.resting)\n\n    // if autostep, and on ground, run collisions again with stepped up aabb\n    if (b.autoStep) {\n        tryAutoStepping(self, b, tmpBox, dx)\n    }\n\n    // Collision impacts. b.resting shows which axes had collisions:\n    for (var i = 0; i < 3; ++i) {\n        impacts[i] = 0\n        if (b.resting[i]) {\n            // count impact only if wasn't collided last frame\n            if (!oldResting[i]) impacts[i] = -b.velocity[i]\n            b.velocity[i] = 0\n        }\n    }\n    var mag = vec3.length(impacts)\n    if (mag > .001) { // epsilon\n        // bounce if over minBounceImpulse\n        if (mag > self.minBounceImpulse && b.restitution) {\n            vec3.scale(impacts, impacts, b.restitution * b.mass)\n            b.applyImpulse(impacts)\n        }\n        // send collision event regardless\n        if (b.onCollide) b.onCollide(impacts)\n    }\n\n\n    // sleep check\n    var vsq = vec3.squaredLength(b.velocity)\n    if (vsq > 1e-5) b._markActive()\n}\n\n\n\n\n\n\n\n\n/*\n *    FLUIDS\n*/\n\nfunction applyFluidForces(self, body) {\n    // First pass at handling fluids. Assumes fluids are settled\n    //   thus, only check at corner of body, and only from bottom up\n    var box = body.aabb\n    var cx = Math.floor(box.base[0])\n    var cz = Math.floor(box.base[2])\n    var y0 = Math.floor(box.base[1])\n    var y1 = Math.floor(box.max[1])\n\n    if (!self.testFluid(cx, y0, cz)) {\n        body.inFluid = false\n        body.ratioInFluid = 0\n        return\n    }\n\n    // body is in a fluid - find out how much of body is submerged\n    var submerged = 1\n    var cy = y0 + 1\n    while (cy <= y1 && self.testFluid(cx, cy, cz)) {\n        submerged++\n        cy++\n    }\n    var fluidLevel = y0 + submerged\n    var heightInFluid = fluidLevel - box.base[1]\n    var ratioInFluid = heightInFluid / box.vec[1]\n    if (ratioInFluid > 1) ratioInFluid = 1\n    var vol = box.vec[0] * box.vec[1] * box.vec[2]\n    var displaced = vol * ratioInFluid\n    // bouyant force = -gravity * fluidDensity * volumeDisplaced\n    var f = _fluidVec\n    vec3.scale(f, self.gravity, -self.fluidDensity * displaced)\n    body.applyForce(f)\n\n    body.inFluid = true\n    body.ratioInFluid = ratioInFluid\n}\n\nvar _fluidVec = vec3.create()\n\n\n\n\n\n/*\n *    FRICTION\n*/\n\n\nfunction applyFrictionByAxis(axis, body, dvel) {\n    // friction applies only if moving into a touched surface\n    var restDir = body.resting[axis]\n    var vNormal = dvel[axis]\n    if (restDir === 0) return\n    if (restDir * vNormal <= 0) return\n\n    // current vel lateral to friction axis\n    vec3.copy(lateralVel, body.velocity)\n    lateralVel[axis] = 0\n    var vCurr = vec3.length(lateralVel)\n    if (equals(vCurr, 0)) return\n\n    // treat current change in velocity as the result of a pseudoforce\n    //        Fpseudo = m*dv/dt\n    // Base friction force on normal component of the pseudoforce\n    //        Ff = u * Fnormal\n    //        Ff = u * m * dvnormal / dt\n    // change in velocity due to friction force\n    //        dvF = dt * Ff / m\n    //            = dt * (u * m * dvnormal / dt) / m\n    //            = u * dvnormal\n    var dvMax = Math.abs(body.friction * vNormal)\n\n    // decrease lateral vel by dvMax (or clamp to zero)\n    var scaler = (vCurr > dvMax) ? (vCurr - dvMax) / vCurr : 0\n    body.velocity[(axis + 1) % 3] *= scaler\n    body.velocity[(axis + 2) % 3] *= scaler\n}\nvar lateralVel = vec3.create()\n\n\n\n\n\n\n/*\n *    COLLISION HANDLER\n*/\n\n// sweep aabb along velocity vector and set resting vector\nfunction processCollisions(self, box, velocity, resting) {\n    vec3.set(resting, 0, 0, 0)\n    return sweep(self.testSolid, box, velocity, function (dist, axis, dir, vec) {\n        resting[axis] = dir\n        vec[axis] = 0\n    })\n}\n\n\n\n\n\n/*\n *    AUTO-STEPPING\n*/\n\nvar tmpBox = new aabb([], [])\nvar tmpResting = vec3.create()\nvar targetPos = vec3.create()\nvar upvec = vec3.create()\nvar leftover = vec3.create()\n\nfunction tryAutoStepping(self, b, oldBox, dx) {\n    if (b.resting[1] >= 0 && !b.inFluid) return\n\n    // // direction movement was blocked before trying a step\n    var xBlocked = (b.resting[0] !== 0)\n    var zBlocked = (b.resting[2] !== 0)\n    if (!(xBlocked || zBlocked)) return\n\n    // continue autostepping only if headed sufficiently into obstruction\n    var ratio = Math.abs(dx[0] / dx[2])\n    var cutoff = 4\n    if (!xBlocked && ratio > cutoff) return\n    if (!zBlocked && ratio < 1 / cutoff) return\n\n    // original target position before being obstructed\n    vec3.add(targetPos, oldBox.base, dx)\n\n    // move towards the target until the first X/Z collision\n    var getVoxels = self.testSolid\n    sweep(getVoxels, oldBox, dx, function (dist, axis, dir, vec) {\n        if (axis === 1) vec[axis] = 0\n        else return true\n    })\n\n    var y = b.aabb.base[1]\n    var ydist = Math.floor(y + 1.001) - y\n    vec3.set(upvec, 0, ydist, 0)\n    var collided = false\n    // sweep up, bailing on any obstruction\n    sweep(getVoxels, oldBox, upvec, function (dist, axis, dir, vec) {\n        collided = true\n        return true\n    })\n    if (collided) return // could't move upwards\n\n    // now move in X/Z however far was left over before hitting the obstruction\n    vec3.subtract(leftover, targetPos, oldBox.base)\n    leftover[1] = 0\n    processCollisions(self, oldBox, leftover, tmpResting)\n\n    // bail if no movement happened in the originally blocked direction\n    if (xBlocked && !equals(oldBox.base[0], targetPos[0])) return\n    if (zBlocked && !equals(oldBox.base[2], targetPos[2])) return\n\n    // done - oldBox is now at the target autostepped position\n    cloneAABB(b.aabb, oldBox)\n    b.resting[0] = tmpResting[0]\n    b.resting[2] = tmpResting[2]\n    if (b.onStep) b.onStep()\n}\n\n\n\n\n\n/*\n *    SLEEP CHECK\n*/\n\nfunction bodyAsleep(self, body, dt, noGravity) {\n    if (body._sleepFrameCount > 0) return false\n    // without gravity bodies stay asleep until a force/impulse wakes them up\n    if (noGravity) return true\n    // otherwise check body is resting against something\n    // i.e. sweep along by distance d = 1/2 g*t^2\n    // and check there's still a collision\n    var isResting = false\n    var gmult = 0.5 * dt * dt * body.gravityMultiplier\n    vec3.scale(sleepVec, self.gravity, gmult)\n    sweep(self.testSolid, body.aabb, sleepVec, function () {\n        isResting = true\n        return true\n    }, true)\n    return isResting\n}\nvar sleepVec = vec3.create()\n\n\n\n\n\nfunction equals(a, b) { return Math.abs(a - b) < 1e-5 }\n\nfunction cloneAABB(tgt, src) {\n    for (var i = 0; i < 3; i++) {\n        tgt.base[i] = src.base[i]\n        tgt.max[i] = src.max[i]\n        tgt.vec[i] = src.vec[i]\n    }\n}\n\n\n\nvar sanityCheck = function () { }\nif (DEBUG) sanityCheck = function (v) {\n    if (isNaN(vec3.length(v))) throw 'Vector with NAN: ', v\n}\n\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/src/index.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/src/rigidBody.js":
/*!************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/src/rigidBody.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar aabb = __webpack_require__(/*! aabb-3d */ \"./node_modules/aabb-3d/index.js\")\nvar vec3 = __webpack_require__(/*! gl-vec3 */ \"./node_modules/gl-vec3/index.js\")\n\n\nvar DEBUG = 0\n\n\nmodule.exports = RigidBody\n\n\n\n/*\n *    RIGID BODY - internal data structure\n *  Only AABB bodies right now. Someday will likely need spheres?\n*/\n\nfunction RigidBody(_aabb, mass, friction, restitution, gravMult, onCollide, autoStep) {\n    this.aabb = new aabb(_aabb.base, _aabb.vec) // clone\n    this.mass = mass\n    this.friction = friction\n    this.restitution = restitution\n    this.gravityMultiplier = gravMult\n    this.onCollide = onCollide\n    this.autoStep = !!autoStep\n    this.airDrag = -1   // overrides global airDrag when >= 0\n    this.fluidDrag = -1 // overrides global fluidDrag when >= 0\n    this.onStep = null\n    \n    // internals\n    this.velocity = vec3.create()\n    this.resting = [0, 0, 0]\n    this.inFluid = false\n    this._ratioInFluid = 0\n    this._forces = vec3.create()\n    this._impulses = vec3.create()\n    this._sleepFrameCount = 10 | 0\n}\n\nRigidBody.prototype.setPosition = function (p) {\n    sanityCheck(p)\n    vec3.subtract(p, p, this.aabb.base)\n    this.aabb.translate(p)\n    this._markActive()\n}\nRigidBody.prototype.getPosition = function () {\n    return vec3.clone(this.aabb.base)\n}\nRigidBody.prototype.applyForce = function (f) {\n    sanityCheck(f)\n    vec3.add(this._forces, this._forces, f)\n    this._markActive()\n}\nRigidBody.prototype.applyImpulse = function (i) {\n    sanityCheck(i)\n    vec3.add(this._impulses, this._impulses, i)\n    this._markActive()\n}\nRigidBody.prototype._markActive = function () {\n    this._sleepFrameCount = 10 | 0\n}\n\n\n\n// temp\nRigidBody.prototype.atRestX = function () { return this.resting[0] }\nRigidBody.prototype.atRestY = function () { return this.resting[1] }\nRigidBody.prototype.atRestZ = function () { return this.resting[2] }\n\n\n\n\n\nvar sanityCheck = function () { }\nif (DEBUG) sanityCheck = function (v) {\n    if (isNaN(vec3.length(v))) throw 'Vector with NAN: ', v\n}\n\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/src/rigidBody.js?");

/***/ }),

/***/ "./server.js":
/*!*******************!*\
  !*** ./server.js ***!
  \*******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_MasterCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/MasterCore */ \"./src/MasterCore.js\");\n/* harmony import */ var _src_interfaces_WorldInterface__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/interfaces/WorldInterface */ \"./src/interfaces/WorldInterface.js\");\n\n\nglobal.Module = __webpack_require__(/*! ../cmake-build-debug/craft_gen.js */ \"../cmake-build-debug/craft_gen.js\");\nconsole.log(\"Starting server...\");\nlet worldInterface = new _src_interfaces_WorldInterface__WEBPACK_IMPORTED_MODULE_1__[\"default\"](Module);\nlet core = new _src_MasterCore__WEBPACK_IMPORTED_MODULE_0__[\"default\"](worldInterface);\ncore.start();\n\n//# sourceURL=webpack:///./server.js?");

/***/ }),

/***/ "./src/Defs.js":
/*!*********************!*\
  !*** ./src/Defs.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nconst Defs = {\n  PORT: 50788,\n  CHUNK_SIZE: 32,\n  CREATE_CHUNK_RADIUS: 2,\n  DELETE_CHUNK_RADIUS: 6,\n  // Max is 10 chunks unless MAX_CHUNKS in C code is increased\n  MAX_CHUNK_SUBS: 1500,\n  CORE_SYNC_INTERVAL: 200,\n  // ms\n  PHYSICS_STEP_FREQUENCY: 20,\n  PHYSICS_MAX_SUB_STEPS: 3,\n  WORLD_SCALE: 1,\n  SHAPE_TYPE_CHUNK: 512,\n  // cannon.js shape type\n  TIME_DAY: 1000 * 60 * 3,\n  TIME_NIGHT: 1000 * 60 * 10,\n  BUILD_MODE: {\n    SINGLE: 0,\n    FLOOR: 1,\n    WALL: 2\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (Defs);\n\n//# sourceURL=webpack:///./src/Defs.js?");

/***/ }),

/***/ "./src/MasterCore.js":
/*!***************************!*\
  !*** ./src/MasterCore.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return MasterCore; });\n/* harmony import */ var _entities_EntityTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./entities/EntityTypes */ \"./src/entities/EntityTypes.js\");\n/* harmony import */ var _entities_PhysicsEntity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./entities/PhysicsEntity */ \"./src/entities/PhysicsEntity.js\");\n/* harmony import */ var _Defs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Defs */ \"./src/Defs.js\");\n/* harmony import */ var _network_MasterServer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./network/MasterServer */ \"./src/network/MasterServer.js\");\n/* harmony import */ var _network_plugins_master_MasterCorePlugin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./network/plugins/master/MasterCorePlugin */ \"./src/network/plugins/master/MasterCorePlugin.js\");\n/* harmony import */ var _network_plugins_master_EntityPlugin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./network/plugins/master/EntityPlugin */ \"./src/network/plugins/master/EntityPlugin.js\");\n/* harmony import */ var _network_plugins_master_WorldPlugin__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./network/plugins/master/WorldPlugin */ \"./src/network/plugins/master/WorldPlugin.js\");\n/* harmony import */ var _network_plugins_master_ChatPlugin__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./network/plugins/master/ChatPlugin */ \"./src/network/plugins/master/ChatPlugin.js\");\n/* harmony import */ var _world_WorldVoxelPhysics__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./world/WorldVoxelPhysics */ \"./src/world/WorldVoxelPhysics.js\");\n/* harmony import */ var _world_WorldStore__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./world/WorldStore */ \"./src/world/WorldStore.js\");\n/* harmony import */ var _world_ChunkManager__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./world/ChunkManager */ \"./src/world/ChunkManager.js\");\n/* harmony import */ var _world_DbChunkLoader__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./world/DbChunkLoader */ \"./src/world/DbChunkLoader.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nclass MasterCore {\n  constructor(worldInterface) {\n    let worldStore = new _world_WorldStore__WEBPACK_IMPORTED_MODULE_9__[\"default\"]();\n    this.chunkManager = new _world_ChunkManager__WEBPACK_IMPORTED_MODULE_10__[\"default\"](worldInterface, new _world_DbChunkLoader__WEBPACK_IMPORTED_MODULE_11__[\"default\"](worldInterface, worldStore));\n    this.physics = new _world_WorldVoxelPhysics__WEBPACK_IMPORTED_MODULE_8__[\"default\"](this.chunkManager);\n    this.server = new _network_MasterServer__WEBPACK_IMPORTED_MODULE_3__[\"default\"]();\n    this.masterCorePlugin = new _network_plugins_master_MasterCorePlugin__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this);\n    this.entities = new _network_plugins_master_EntityPlugin__WEBPACK_IMPORTED_MODULE_5__[\"default\"](e => this.onCreateEntity(e), e => this.onDeleteEntity(e));\n    this.world = new _network_plugins_master_WorldPlugin__WEBPACK_IMPORTED_MODULE_6__[\"default\"](this.chunkManager, worldStore);\n    this.chat = new _network_plugins_master_ChatPlugin__WEBPACK_IMPORTED_MODULE_7__[\"default\"](this);\n    this.server.addPlugin(this.masterCorePlugin);\n    this.server.addPlugin(this.entities);\n    this.server.addPlugin(this.world);\n    this.server.addPlugin(this.chat);\n    this.server.init();\n  }\n\n  onCreateEntity(entity) {\n    if (entity instanceof _entities_PhysicsEntity__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n      this.physics.phys.bodies.push(entity.body);\n    }\n  }\n\n  onDeleteEntity(entity) {\n    if (entity instanceof _entities_PhysicsEntity__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n      this.physics.phys.removeBody(entity.body);\n    }\n  }\n\n  start() {\n    this.lastUpdate = Date.now();\n    this.updateInterval = setInterval(() => this.update(Date.now()), 50);\n  }\n\n  update(now) {\n    let delta = now - this.lastUpdate;\n    this.lastUpdate = now;\n    this.physics.update(now);\n    this.entities.update();\n    this.entities.sendUpdates();\n    this.masterCorePlugin.update();\n  }\n\n}\n\n//# sourceURL=webpack:///./src/MasterCore.js?");

/***/ }),

/***/ "./src/StructDefs.js":
/*!***************************!*\
  !*** ./src/StructDefs.js ***!
  \***************************/
/*! exports provided: SignStruct, SignListStruct, MapStruct, ChunkStruct, ClientChunkStruct, StateStruct, PlayerStruct, ClientModelStruct */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SignStruct\", function() { return SignStruct; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SignListStruct\", function() { return SignListStruct; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MapStruct\", function() { return MapStruct; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ChunkStruct\", function() { return ChunkStruct; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ClientChunkStruct\", function() { return ClientChunkStruct; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StateStruct\", function() { return StateStruct; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PlayerStruct\", function() { return PlayerStruct; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ClientModelStruct\", function() { return ClientModelStruct; });\nconst SignStruct = [{\n  name: 'x',\n  type: 'i32'\n}, {\n  name: 'y',\n  type: 'i32'\n}, {\n  name: 'z',\n  type: 'i32'\n}, {\n  name: 'face',\n  type: 'i32'\n}, {\n  name: 'text',\n  type: 'char',\n  length: 64\n}];\nconst SignListStruct = [{\n  name: 'capacity',\n  type: 'i32'\n}, {\n  name: 'size',\n  type: 'i32'\n}, {\n  name: 'data',\n  type: '*',\n  to: {\n    type: 'struct',\n    struct: SignStruct\n  }\n}];\nconst MapStruct = [{\n  name: 'dx',\n  type: 'i32'\n}, {\n  name: 'dy',\n  type: 'i32'\n}, {\n  name: 'dz',\n  type: 'i32'\n}, {\n  name: 'mask',\n  type: 'i32'\n}, {\n  name: 'size',\n  type: 'i32'\n}, {\n  name: 'data',\n  type: '*'\n}];\nconst ChunkStruct = [{\n  name: 'p',\n  type: 'i32'\n}, {\n  name: 'q',\n  type: 'i32'\n}, {\n  name: 'r',\n  type: 'i32'\n}, {\n  name: 'active',\n  type: 'i32'\n}, {\n  name: 'dirty',\n  type: 'i32'\n}, {\n  name: 'map',\n  type: 'struct',\n  struct: MapStruct\n}, {\n  name: 'lights',\n  type: 'struct',\n  struct: MapStruct\n}, {\n  name: 'signs',\n  type: 'struct',\n  struct: SignListStruct\n}];\nconst ClientChunkStruct = [{\n  name: 'c',\n  type: 'struct',\n  struct: ChunkStruct\n}, {\n  name: 'buffer',\n  type: 'i32'\n}, {\n  name: 'sign_buffer',\n  type: 'i32'\n}, {\n  name: 'faces',\n  type: 'i32'\n}, {\n  name: 'sign_faces',\n  type: 'i32'\n}];\nconst StateStruct = [{\n  name: 'x',\n  type: 'float'\n}, {\n  name: 'y',\n  type: 'float'\n}, {\n  name: 'z',\n  type: 'float'\n}, {\n  name: 'rx',\n  type: 'float'\n}, {\n  name: 'ry',\n  type: 'float'\n}, {\n  name: 't',\n  type: 'float'\n}];\nconst PlayerStruct = [{\n  name: 'id',\n  type: 'i32'\n}, {\n  name: 'current_item',\n  type: 'i32'\n}, {\n  name: 'name',\n  type: 'char',\n  length: 32\n}, {\n  name: 'state',\n  type: 'struct',\n  struct: StateStruct\n}, {\n  name: 'buffer',\n  type: 'i32'\n}];\nconst ClientModelStruct = [{\n  name: 'chunks',\n  type: 'struct',\n  length: 1024,\n  struct: ClientChunkStruct\n}, {\n  name: 'players',\n  type: 'struct',\n  length: 128,\n  struct: PlayerStruct\n}, {\n  name: 'create_radius',\n  type: 'i32'\n}, {\n  name: 'render_radius',\n  type: 'i32'\n}, {\n  name: 'delete_radius',\n  type: 'i32'\n}, {\n  name: 'sign_radius',\n  type: 'i32'\n}, {\n  name: 'width',\n  type: 'i32'\n}, {\n  name: 'height',\n  type: 'i32'\n}, {\n  name: 'build_mode',\n  type: 'i32'\n}, {\n  name: 'build_rot',\n  type: 'i32'\n}, {\n  name: 'scale',\n  type: 'i32'\n}, {\n  name: 'ortho',\n  type: 'i32'\n}, {\n  name: 'fov',\n  type: 'float'\n}, {\n  name: 'time',\n  type: 'i32'\n}, {\n  name: 'day_length',\n  type: 'i32'\n}, {\n  name: 'time_changed',\n  type: 'i32'\n}, {\n  name: 'px',\n  type: 'i32'\n}, {\n  name: 'py',\n  type: 'i32'\n}, {\n  name: 'pz',\n  type: 'i32'\n}];\n\n//# sourceURL=webpack:///./src/StructDefs.js?");

/***/ }),

/***/ "./src/entities/Entity.js":
/*!********************************!*\
  !*** ./src/entities/Entity.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Entity; });\n/* harmony import */ var _util_SerializedObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/SerializedObject */ \"./src/util/SerializedObject.js\");\n/* harmony import */ var _EntityTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EntityTypes */ \"./src/entities/EntityTypes.js\");\n\n\nclass Entity extends Object(_util_SerializedObject__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(null, _EntityTypes__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ENTITY, {\n  _static: [],\n  id: undefined,\n  player: null\n},\n/* onChangeData */\nfunction (k, v) {}) {\n  constructor(data) {\n    super(data);\n    this.dirty = false;\n    this.deleted = false;\n    this.clientControlled = false;\n  }\n\n  serverUpdate() {}\n\n  clientUpdate() {}\n\n  onDelete() {}\n\n}\n\n//# sourceURL=webpack:///./src/entities/Entity.js?");

/***/ }),

/***/ "./src/entities/EntityTypes.js":
/*!*************************************!*\
  !*** ./src/entities/EntityTypes.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nconst ENTITY_TYPES = {\n  ENTITY: 0,\n  PHYSICS: 1,\n  PLAYER: 2\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (ENTITY_TYPES);\n\n//# sourceURL=webpack:///./src/entities/EntityTypes.js?");

/***/ }),

/***/ "./src/entities/PhysicsEntity.js":
/*!***************************************!*\
  !*** ./src/entities/PhysicsEntity.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return PhysicsEntity; });\n/* harmony import */ var _util_SerializedObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/SerializedObject */ \"./src/util/SerializedObject.js\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Entity */ \"./src/entities/Entity.js\");\n/* harmony import */ var _EntityTypes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EntityTypes */ \"./src/entities/EntityTypes.js\");\n/* harmony import */ var gl_vec3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gl-vec3 */ \"./node_modules/gl-vec3/index.js\");\n/* harmony import */ var gl_vec3__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(gl_vec3__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\nclass PhysicsEntity extends Object(_util_SerializedObject__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(_Entity__WEBPACK_IMPORTED_MODULE_1__[\"default\"], _EntityTypes__WEBPACK_IMPORTED_MODULE_2__[\"default\"].PHYSICS, {\n  x: 0,\n  y: 0,\n  z: 0,\n  rx: 0,\n  ry: 0,\n  rz: 0,\n  vx: 0,\n  vy: 0,\n  vz: 0\n}) {\n  constructor(data) {\n    super(data);\n    this.body = this.createBody();\n  }\n\n  createBody() {\n    /* override */\n    throw Error(\"PhysicsEntity.createBody must be overridden\");\n  }\n\n  onUpdateData() {\n    this.body.setPosition([this.x, this.y, this.z]);\n    gl_vec3__WEBPACK_IMPORTED_MODULE_3___default.a.set(this.body.velocity, this.vx, this.vy, this.vz);\n  }\n\n  updateFromBody() {\n    this.x = this.body.getPosition()[0];\n    this.y = this.body.getPosition()[1];\n    this.z = this.body.getPosition()[2];\n    this.vx = this.body.velocity[0];\n    this.vy = this.body.velocity[1];\n    this.vz = this.body.velocity[2];\n  }\n\n  clientUpdate() {\n    super.clientUpdate();\n    this.updateFromBody();\n  }\n\n  serverUpdate() {\n    super.serverUpdate();\n    this.updateFromBody();\n  }\n\n}\n\n//# sourceURL=webpack:///./src/entities/PhysicsEntity.js?");

/***/ }),

/***/ "./src/entities/Player.js":
/*!********************************!*\
  !*** ./src/entities/Player.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Player; });\n/* harmony import */ var _util_SerializedObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/SerializedObject */ \"./src/util/SerializedObject.js\");\n/* harmony import */ var _PhysicsEntity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PhysicsEntity */ \"./src/entities/PhysicsEntity.js\");\n/* harmony import */ var _EntityTypes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EntityTypes */ \"./src/entities/EntityTypes.js\");\n/* harmony import */ var _node_modules_voxel_physics_engine_src_rigidBody__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../node_modules/voxel-physics-engine/src/rigidBody */ \"./node_modules/voxel-physics-engine/src/rigidBody.js\");\n/* harmony import */ var _node_modules_voxel_physics_engine_src_rigidBody__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_voxel_physics_engine_src_rigidBody__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var aabb_3d__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! aabb-3d */ \"./node_modules/aabb-3d/index.js\");\n/* harmony import */ var aabb_3d__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(aabb_3d__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var gl_vec3__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! gl-vec3 */ \"./node_modules/gl-vec3/index.js\");\n/* harmony import */ var gl_vec3__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(gl_vec3__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _Defs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Defs */ \"./src/Defs.js\");\n\n\n // import CANNON from 'cannon';\n// import physicsMaterial from '~/world/physicsMaterial';\n\n\n\n\n\nclass Player extends Object(_util_SerializedObject__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(_PhysicsEntity__WEBPACK_IMPORTED_MODULE_1__[\"default\"], _EntityTypes__WEBPACK_IMPORTED_MODULE_2__[\"default\"].PLAYER, {\n  name: \"Nemp\",\n  currentItem: _Defs__WEBPACK_IMPORTED_MODULE_6__[\"default\"].BUILD_MODE.SINGLE\n}) {\n  constructor(data, mem) {\n    super(data, mem + 4 + 32);\n  }\n\n  createBody() {\n    let b = new _node_modules_voxel_physics_engine_src_rigidBody__WEBPACK_IMPORTED_MODULE_3___default.a(new aabb_3d__WEBPACK_IMPORTED_MODULE_4___default.a([0, 0, 0], [3, 6, 3]), 1, 1, 0, 1, () => {}, 1);\n    b.setPosition([this.x, this.y, this.z]);\n    return b; // let radius = 1.4;\n    // let height = 4.5;\n    // let segments = 15;\n    // // let shape = new CANNON.Cylinder(radius, radius, height, segments);\n    // let shape = new CANNON.Sphere(radius);\n    // // orient cylinder along y-axis\n    // // let quat = new CANNON.Quaternion();\n    // // quat.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2);\n    // // shape.transformAllPoints(new CANNON.Vec3(0,0,0), quat);\n    // let body = new CANNON.Body({\n    //     type: CANNON.Body.DYNAMIC,\n    //     mass: 10,\n    //     position: new CANNON.Vec3(this.x, this.y, this.z),\n    //     velocity: new CANNON.Vec3(this.vx, this.vy, this.vz),\n    //     shape: shape,\n    //     material: physicsMaterial,\n    //     fixedRotation: true,\n    //     linearDamping: 0.7\n    // });\n    // body.addShape(new CANNON.Sphere(radius), new CANNON.Vec3(0, -height + radius, 0));\n    // return body;\n  }\n\n}\n\n//# sourceURL=webpack:///./src/entities/Player.js?");

/***/ }),

/***/ "./src/interfaces/Interface.js":
/*!*************************************!*\
  !*** ./src/interfaces/Interface.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nclass Interface {\n  constructor(Module, functionDefs) {\n    for (let func of functionDefs) {\n      this[func.name] = Module.cwrap(func.name, func.ret, func.args);\n    }\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Interface);\n\n//# sourceURL=webpack:///./src/interfaces/Interface.js?");

/***/ }),

/***/ "./src/interfaces/WorldInterface.js":
/*!******************************************!*\
  !*** ./src/interfaces/WorldInterface.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return WorldInterface; });\n/* harmony import */ var _Interface__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Interface */ \"./src/interfaces/Interface.js\");\n\nclass WorldInterface extends _Interface__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(Module) {\n    super(Module, [{\n      name: 'find_chunk',\n      args: ['i32', 'i32', 'i32']\n    }, {\n      name: 'get_unused_chunk_mem_location'\n    }, {\n      name: 'init_chunk',\n      args: ['*', 'i32', 'i32', 'i32']\n    }, {\n      name: 'delete_chunk',\n      args: ['*']\n    }, {\n      name: 'gen_chunk',\n      args: ['*']\n    }]);\n  }\n\n}\n\n//# sourceURL=webpack:///./src/interfaces/WorldInterface.js?");

/***/ }),

/***/ "./src/network/MasterServer.js":
/*!*************************************!*\
  !*** ./src/network/MasterServer.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return MasterServer; });\n/* harmony import */ var _Defs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Defs */ \"./src/Defs.js\");\n/* harmony import */ var _Server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Server */ \"./src/network/Server.js\");\n/* harmony import */ var socket_io__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! socket.io */ \"socket.io\");\n/* harmony import */ var socket_io__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(socket_io__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _plugins_ServerLogPlugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plugins/ServerLogPlugin */ \"./src/network/plugins/ServerLogPlugin.js\");\n\n\n\n\nclass MasterServer extends _Server__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  constructor(config) {\n    super(config);\n    this.io = new socket_io__WEBPACK_IMPORTED_MODULE_2___default.a({\n      transports: [\"websocket\"],\n      serveClient: false\n    });\n    this.addPlugin(new _plugins_ServerLogPlugin__WEBPACK_IMPORTED_MODULE_3__[\"default\"]());\n  }\n\n  addPlugin(plugin) {\n    plugin.emit = this.io.emit.bind(this.io);\n    super.addPlugin(plugin);\n  }\n\n  init() {\n    this.io.on('connect', socket => {\n      this.registerHandlersOnSocket(socket);\n    });\n    this.io.listen(_Defs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].PORT); // start listening\n  }\n\n}\n\n//# sourceURL=webpack:///./src/network/MasterServer.js?");

/***/ }),

/***/ "./src/network/Server.js":
/*!*******************************!*\
  !*** ./src/network/Server.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Server; });\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass Server {\n  constructor(config) {\n    this.config = _objectSpread({\n      isMaster: true\n    }, config);\n    this.handlers = {};\n    this.plugins = [];\n  }\n\n  init() {\n    /* Override in client, create sockets */\n  }\n\n  addPlugin(plugin) {\n    this.plugins.push(plugin);\n    plugin.registerHandlers((key, handler) => {\n      let _handler = (...args) => {\n        try {\n          handler(...args);\n        } catch (e) {\n          console.error(`Error in socket handler ${key} from plugin ${plugin.constructor.name}:`);\n          console.error(e.stack);\n        }\n      };\n\n      if (key in this.handlers) {\n        this.handlers[key].push(_handler);\n      } else {\n        this.handlers[key] = [_handler];\n      }\n    }, this.config);\n  }\n\n  registerHandlersOnSocket(socket) {\n    for (let key in this.handlers) {\n      for (let handler of this.handlers[key]) {\n        socket.on(key, (...args) => handler(socket, ...args));\n      }\n    }\n  }\n\n}\n\n//# sourceURL=webpack:///./src/network/Server.js?");

/***/ }),

/***/ "./src/network/ServerPlugin.js":
/*!*************************************!*\
  !*** ./src/network/ServerPlugin.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ServerPlugin; });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n\nclass ServerPlugin extends events__WEBPACK_IMPORTED_MODULE_0___default.a {\n  constructor() {\n    super();\n    this.emitEvent = this.emit; // inherited from EventEmitter\n\n    this.emit = null;\n  }\n\n  registerHandlers(registerHandler, serverConfig) {\n    /* override in child class */\n  }\n\n}\n\n//# sourceURL=webpack:///./src/network/ServerPlugin.js?");

/***/ }),

/***/ "./src/network/plugins/ServerLogPlugin.js":
/*!************************************************!*\
  !*** ./src/network/plugins/ServerLogPlugin.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ServerLogPlugin; });\n/* harmony import */ var _ServerPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ServerPlugin */ \"./src/network/ServerPlugin.js\");\n\nclass ServerLogPlugin extends _ServerPlugin__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  registerHandlers(registerHandler, serverConfig) {\n    if (serverConfig.isMaster) {\n      // Print right away if on master server\n      console.log(\"Socket connected.\");\n    } else {\n      registerHandler('connect', () => {\n        console.log(\"Socket connected.\");\n      });\n    }\n\n    registerHandler('disconnect', () => {\n      console.log(\"Socket disconnected.\");\n    });\n  }\n\n}\n\n//# sourceURL=webpack:///./src/network/plugins/ServerLogPlugin.js?");

/***/ }),

/***/ "./src/network/plugins/master/ChatPlugin.js":
/*!**************************************************!*\
  !*** ./src/network/plugins/master/ChatPlugin.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ChatPlugin; });\n/* harmony import */ var _ServerPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../ServerPlugin */ \"./src/network/ServerPlugin.js\");\n/* harmony import */ var _entities_EntityTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../entities/EntityTypes */ \"./src/entities/EntityTypes.js\");\n/* harmony import */ var _Defs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../Defs */ \"./src/Defs.js\");\n\n\n\nclass ChatPlugin extends _ServerPlugin__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(masterCore) {\n    super();\n    this.masterCore = masterCore;\n  }\n\n  registerHandlers(registerHandler) {\n    registerHandler('chat.message', (socket, {\n      msg\n    }) => {\n      if (msg[0] === '/') {\n        // command\n        let args = msg.slice(1).split(' ');\n\n        if (args[0] === 'timeset') {\n          if (args[1] === 'day') {\n            this.masterCore.masterCorePlugin.gameTime = _Defs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].TIME_DAY;\n          } else if (args[1] === 'night') {\n            this.masterCore.masterCorePlugin.gameTime = _Defs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].TIME_NIGHT;\n          } else {\n            socket.emit('chat.message', {\n              msg: \"USAGE: timeset [day|night|time]\"\n            });\n          }\n        } else {\n          socket.emit('chat.message', {\n            msg: \"Unknown command\"\n          });\n        }\n      } else {\n        let player = this.masterCore.masterCorePlugin.getPlayer(socket.id);\n        let playerName = player ? player.name : \"?????\";\n        let formattedMsg = `${playerName}: ${msg}`;\n        this.emit('chat.message', {\n          msg: formattedMsg\n        });\n      }\n    });\n  }\n\n}\n\n//# sourceURL=webpack:///./src/network/plugins/master/ChatPlugin.js?");

/***/ }),

/***/ "./src/network/plugins/master/EntityPlugin.js":
/*!****************************************************!*\
  !*** ./src/network/plugins/master/EntityPlugin.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return EntityPlugin; });\n/* harmony import */ var _ServerPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../ServerPlugin */ \"./src/network/ServerPlugin.js\");\n/* harmony import */ var _entities_EntityTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../entities/EntityTypes */ \"./src/entities/EntityTypes.js\");\n/* harmony import */ var _entities_Player__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../entities/Player */ \"./src/entities/Player.js\");\n/* harmony import */ var _util_UUID__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../util/UUID */ \"./src/util/UUID.js\");\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\nclass EntityPlugin extends _ServerPlugin__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(onCreateEntity, onDeleteEntity) {\n    super();\n    this.onCreateEntity = onCreateEntity;\n    this.onDeleteEntity = onDeleteEntity;\n    this.entities = {};\n    this.entityFactory = {\n      [_entities_EntityTypes__WEBPACK_IMPORTED_MODULE_1__[\"default\"].PLAYER]: _entities_Player__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n    };\n  }\n\n  registerHandlers(registerHandler) {\n    registerHandler('entity.update', (socket, {\n      entityData\n    }) => {\n      for (let data of entityData) {\n        if (this.entities.hasOwnProperty(data.id)) {\n          // Only allow update by controlling player\n          let entity = this.entities[data.id];\n\n          if (entity.player === socket.id) {\n            entity.updateData(data);\n            entity.dirty = true;\n          }\n        }\n      }\n    }); // registerHandler('entity.delete', (socket, { entityIds }) => {\n    //     for (let id of entityIds) {\n    //         if (this.entities.hasOwnProperty(id)) {\n    //             this.entities[id].onDelete();\n    //             delete this.entities[id];\n    //         }\n    //     }\n    // });\n  }\n\n  create(entityType, data = {}) {\n    if (entityType in this.entityFactory) {\n      let id = Object(_util_UUID__WEBPACK_IMPORTED_MODULE_3__[\"generateUuid\"])();\n      let EntityClass = this.entityFactory[entityType];\n      let entity = new EntityClass(_objectSpread({}, data, {\n        id\n      }));\n      this.entities[id] = entity;\n      this.onCreateEntity(entity);\n      this.sendUpdate(entity);\n    } else {\n      throw Error(`Unregistered entity type ${entityType}.`);\n    }\n  }\n\n  delete(entity) {\n    entity.deleted = true;\n    this.onDeleteEntity(entity);\n  }\n\n  update() {\n    for (let e of Object.values(this.entities)) {\n      e.serverUpdate();\n    }\n  }\n\n  sendUpdate(entity) {\n    if (entity.deleted) {\n      this.emit('entity.delete', {\n        entityIds: [entity.id]\n      });\n    } else {\n      this.emit('entity.update', {\n        entityData: [entity.toData()]\n      });\n    }\n  }\n\n  sendUpdates() {\n    let entityData = [];\n    let deletedEntityIds = [];\n\n    for (let e of Object.values(this.entities)) {\n      if (e.deleted) {\n        deletedEntityIds.push(e.id);\n        delete this.entities[e.id];\n      } else if (e.dirty) {\n        entityData.push(e.toData());\n        e.dirty = false;\n      }\n    }\n\n    if (entityData.length > 0) {\n      this.emit('entity.update', {\n        entityData\n      });\n    }\n\n    if (deletedEntityIds.length > 0) {\n      this.emit('entity.delete', {\n        entityIds: deletedEntityIds\n      });\n    }\n  }\n\n  sendAllEntities(socket) {\n    let entityData = [];\n\n    for (let e of Object.values(this.entities)) {\n      if (e.deleted) continue;\n      entityData.push(e.toData());\n    }\n\n    if (entityData.length > 0) {\n      socket.emit('entity.update', {\n        entityData\n      });\n    }\n  }\n\n  search(cond) {\n    let entities = [];\n\n    for (let e of Object.values(this.entities)) {\n      if (cond(e) === true) {\n        entities.push(e);\n      }\n    }\n\n    return entities;\n  }\n\n}\n\n//# sourceURL=webpack:///./src/network/plugins/master/EntityPlugin.js?");

/***/ }),

/***/ "./src/network/plugins/master/MasterCorePlugin.js":
/*!********************************************************!*\
  !*** ./src/network/plugins/master/MasterCorePlugin.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return MasterCorePlugin; });\n/* harmony import */ var _ServerPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../ServerPlugin */ \"./src/network/ServerPlugin.js\");\n/* harmony import */ var _entities_EntityTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../entities/EntityTypes */ \"./src/entities/EntityTypes.js\");\n/* harmony import */ var _Defs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../Defs */ \"./src/Defs.js\");\n\n\n\nclass MasterCorePlugin extends _ServerPlugin__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(masterCore) {\n    super();\n    this.masterCore = masterCore;\n    this.players = {};\n    this.lastUpdate = Date.now();\n    this.gameTime = _Defs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].TIME_DAY;\n  }\n\n  getPlayer(playerId) {\n    return this.players[playerId];\n  }\n\n  update() {\n    let now = Date.now();\n\n    if (now - this.lastUpdate > _Defs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].CORE_SYNC_INTERVAL) {\n      this.gameTime += now - this.lastUpdate;\n      this.lastUpdate = now;\n      this.emit('core.update', {\n        time: now,\n        gameTime: this.gameTime\n      });\n    }\n  }\n\n  registerHandlers(registerHandler) {\n    registerHandler('client.join', (socket, {\n      name\n    }, cb) => {\n      this.players[socket.id] = {\n        name\n      };\n      cb({\n        playerId: socket.id\n      });\n      console.log(`Player ${name} joined.`);\n      this.masterCore.entities.sendAllEntities(socket);\n      this.masterCore.entities.create(_entities_EntityTypes__WEBPACK_IMPORTED_MODULE_1__[\"default\"].PLAYER, {\n        name,\n        player: socket.id,\n        y: 35\n      });\n    });\n    registerHandler('disconnect', socket => {\n      if (socket.id in this.players) {\n        delete this.players[socket.id];\n        let playerEntities = this.masterCore.entities.search(e => e.player === socket.id);\n\n        for (let e of playerEntities) {\n          this.masterCore.entities.delete(e);\n        }\n      }\n    });\n  }\n\n}\n\n//# sourceURL=webpack:///./src/network/plugins/master/MasterCorePlugin.js?");

/***/ }),

/***/ "./src/network/plugins/master/WorldPlugin.js":
/*!***************************************************!*\
  !*** ./src/network/plugins/master/WorldPlugin.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return WorldPlugin; });\n/* harmony import */ var _Defs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Defs */ \"./src/Defs.js\");\n/* harmony import */ var _ServerPlugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../ServerPlugin */ \"./src/network/ServerPlugin.js\");\n/* harmony import */ var _world_ChunkUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../world/ChunkUtils */ \"./src/world/ChunkUtils.js\");\n\n\n\nclass WorldPlugin extends _ServerPlugin__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  constructor(chunkManager, worldStore) {\n    super();\n    this.chunkManager = chunkManager;\n    this.worldStore = worldStore;\n    this.subCount = {}; // socketId: subCount\n\n    this.chunkSubs = {}; // chunkKey: [...sockets]\n\n    this.changedChunks = []; // [...chunkKeys]\n  }\n\n  async getChunk(p, q, r) {\n    let chunk = this.chunkManager.getChunk(p, q, r);\n\n    if (!chunk) {\n      chunk = await this.chunkManager.createChunk(p, q, r);\n    }\n\n    return chunk;\n  }\n\n  removeChunk(chunk) {\n    let key = Object(_world_ChunkUtils__WEBPACK_IMPORTED_MODULE_2__[\"chunkKey\"])(chunk.p, chunk.q, chunk.r);\n    let ind = this.changedChunks.indexOf(key);\n\n    if (ind !== -1) {\n      // chunk was changed, so save it\n      this.worldStore.saveChunk(chunk.toData());\n      this.changedChunks.splice(ind, 1);\n    }\n\n    this.chunkManager.removeChunk(chunk);\n  }\n\n  async _onUnsubChunk(key, remainingSubs) {\n    if (remainingSubs === 0) {\n      this.removeChunk(this.chunkManager.getChunkByChunkKey(key));\n      delete this.chunkSubs[key];\n    }\n  }\n\n  subChunk(p, q, r, socket) {\n    let key = Object(_world_ChunkUtils__WEBPACK_IMPORTED_MODULE_2__[\"chunkKey\"])(p, q, r);\n\n    if (!(key in this.chunkSubs)) {\n      this.chunkSubs[key] = [socket];\n    } else if (this.chunkSubs[key].indexOf(socket) === -1) {\n      this.chunkSubs[key].push(socket);\n    } else {\n      throw Error(`Socket [${socket.id}] is already subscribed to chunk ${key}`);\n    }\n\n    if (socket.id in this.subCount) {\n      if (++this.subCount[socket.id] >= _Defs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].MAX_CHUNK_SUBS) {\n        console.warn(`Socket [${socket.id}] has chunk subscriptions > ${_Defs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].MAX_CHUNK_SUBS} (${this.subCount[socket.id]})`);\n      }\n    } else {\n      this.subCount[socket.id] = 1;\n    }\n  }\n\n  unsubChunk(p, q, r, socket) {\n    let key = Object(_world_ChunkUtils__WEBPACK_IMPORTED_MODULE_2__[\"chunkKey\"])(p, q, r);\n    let ind;\n    let subs;\n\n    if (key in this.chunkSubs && (ind = this.chunkSubs[key].indexOf(socket)) !== -1) {\n      this.chunkSubs[key].splice(ind, 1);\n\n      this._onUnsubChunk(key, this.chunkSubs[key].length);\n    } else {\n      throw Error(`Socket [${socket.id}] is not subscribed to chunk ${key}`);\n    }\n\n    if (socket.id in this.subCount) {\n      if (--this.subCount[socket.id] < 0) {\n        throw Error(`Socket [${socket.id}] has a sub count < 0`);\n      }\n    } else {\n      this.subCount[socket.id] = 0;\n    }\n  }\n\n  unsubAllChunks(socket) {\n    for (let key in this.chunkSubs) {\n      let ind = this.chunkSubs[key].indexOf(socket);\n\n      if (ind !== -1) {\n        this.chunkSubs[key].splice(ind, 1);\n\n        this._onUnsubChunk(key, this.chunkSubs[key].length);\n      }\n    }\n\n    delete this.subCount[socket.id];\n  }\n\n  sendBlockUpdateToSockets(sockets, x, y, z, state, w) {\n    for (let socket of sockets) {\n      socket.emit('block.update', {\n        x,\n        y,\n        z,\n        state,\n        w\n      });\n    }\n  }\n\n  registerHandlers(registerHandler) {\n    registerHandler('disconnect', socket => {\n      this.unsubAllChunks(socket);\n    });\n    registerHandler('chunk.sub', async (socket, {\n      p,\n      q,\n      r\n    }, cb) => {\n      this.subChunk(p, q, r, socket);\n\n      try {\n        let chunk = await this.getChunk(p, q, r);\n        cb(chunk.toData());\n      } catch (e) {\n        console.error(e.stack);\n      }\n    });\n    registerHandler('chunk.unsub', (socket, {\n      p,\n      q,\n      r\n    }, cb) => {\n      this.unsubChunk(p, q, r, socket);\n    });\n    registerHandler('block.modify', async (socket, {\n      x,\n      y,\n      z,\n      state,\n      w\n    }, cb) => {\n      let p = Object(_world_ChunkUtils__WEBPACK_IMPORTED_MODULE_2__[\"chunked\"])(x);\n      let q = Object(_world_ChunkUtils__WEBPACK_IMPORTED_MODULE_2__[\"chunked\"])(z);\n      let r = Object(_world_ChunkUtils__WEBPACK_IMPORTED_MODULE_2__[\"chunked\"])(y);\n      let chunk = await this.getChunk(p, q, r); //console.log(`Set block (${x}, ${y}, ${z}) to ${w}[${state}]`);\n\n      chunk.setBlock(x, y, z, state, w);\n      let key = Object(_world_ChunkUtils__WEBPACK_IMPORTED_MODULE_2__[\"chunkKey\"])(p, q, r);\n\n      if (key in this.chunkSubs) {\n        this.sendBlockUpdateToSockets(this.chunkSubs[key], x, y, z, state, w);\n      }\n\n      if (this.changedChunks.indexOf(key) === -1) {\n        this.changedChunks.push(key);\n      }\n    });\n  }\n\n}\n\n//# sourceURL=webpack:///./src/network/plugins/master/WorldPlugin.js?");

/***/ }),

/***/ "./src/util/MemoryBackedObject.js":
/*!****************************************!*\
  !*** ./src/util/MemoryBackedObject.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst ValueSizes = {\n  char: 1,\n  i8: 1,\n  i16: 2,\n  i32: 4,\n  i64: 8,\n  float: 4,\n  double: 8,\n  '*': 4,\n  // pointer\n  struct: 0 // special case, here for clarity\n\n};\n\nconst computeMemoryDataForField = field => {\n  let type = field.type;\n  let length = field.length || 1;\n  let size = 0;\n  let struct, to;\n\n  if (type === 'struct') {\n    ({\n      memData: struct,\n      size\n    } = computeMemoryDataForStruct(field.struct));\n  } else if (type === '*') {\n    size = ValueSizes[field.type];\n\n    if (field.to) {\n      to = computeMemoryDataForField(field.to);\n    } // else: just ignore, may not be required\n\n  } else {\n    size = ValueSizes[field.type];\n  }\n\n  return {\n    type,\n    length,\n    size,\n    struct,\n    to\n  };\n};\n\nconst computeMemoryDataForStruct = STRUCT => {\n  let memData = {};\n  let offset = 0;\n\n  for (let prop of STRUCT) {\n    let field = computeMemoryDataForField(prop);\n    memData[prop.name] = _objectSpread({\n      offset\n    }, field);\n    offset += field.size * field.length;\n  }\n\n  return {\n    memData,\n    size: offset\n  };\n};\n\nconst getFieldData = (memData, memPos, name) => {\n  let names = name.split('.');\n  let n = names[0];\n\n  if (memData.hasOwnProperty(n) === false) {\n    throw Error(`Memory data doesn't contain the field ${n} (in ${name})`);\n  }\n\n  let field = memData[n];\n\n  if (names.length === 1 && (field.type === 'struct' || field.type === '*')) {\n    // Reached end of depth, return memory location\n    return {\n      pos: memPos + field.offset,\n      type: '*'\n    };\n  } else if (field.type === 'struct') {\n    return getFieldData(field.struct, memPos + field.offset, names.splice(1).join('.'));\n  } else if (field.type === '*') {\n    memPos = Module.getValue(memPos + field.offset, '*'); // TODO: Access pointer value\n  } else {\n    return {\n      pos: memPos + field.offset,\n      type: field.type\n    };\n  }\n};\n\nconst MemoryBackedObject = (SuperClass, STRUCT) => {\n  const {\n    memData,\n    size\n  } = computeMemoryDataForStruct(STRUCT);\n  return class extends SuperClass {\n    constructor() {\n      super(...arguments);\n      this.memPos = null;\n    }\n\n    assignMemory(memPos) {\n      this.memPos = memPos;\n      this.initMemory();\n    }\n\n    initMemory() {\n      /* Override in child class */\n    }\n\n    get size() {\n      return size;\n    }\n\n    getMemoryPosition(k) {\n      if (this.memPos === null) return null;\n      if (k === undefined) return this.memPos;\n      return getFieldData(memData, this.memPos, k).pos;\n    }\n\n    getMemoryValue(k) {\n      if (this.memPos === null) return null;\n      let {\n        pos,\n        type\n      } = getFieldData(memData, this.memPos, k);\n      return Module.getValue(pos, type);\n    }\n\n    setMemoryValue(k, v) {\n      if (this.memPos === null) return null; // TODO: Implement setting char arrays\n\n      let {\n        pos,\n        type\n      } = getFieldData(memData, this.memPos, k);\n      return Module.setValue(pos, v, type);\n    }\n\n  };\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (MemoryBackedObject);\n\n//# sourceURL=webpack:///./src/util/MemoryBackedObject.js?");

/***/ }),

/***/ "./src/util/ObjectHelpers.js":
/*!***********************************!*\
  !*** ./src/util/ObjectHelpers.js ***!
  \***********************************/
/*! exports provided: extend, mask */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"extend\", function() { return extend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mask\", function() { return mask; });\nfunction extend(target) {\n  for (var hOP = Object.prototype.hasOwnProperty, copy = function (key) {\n    if (!hOP.call(target, key)) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(this, key));\n    }\n  }, i = arguments.length; 1 < i--; Object.keys(arguments[i]).forEach(copy, arguments[i])) {}\n\n  return target;\n} // masks source1 with source2, result will be all of the properties in source1\n// with values replaced from source2 if it contains the property\n// if _static: [property keys] is provided, then properties in source2 that are in _static\n// will not be included\n\nfunction mask(source1, source2, excludeProtect) {\n  var destination = {};\n  var _static = [];\n\n  for (var property in source1) {\n    if (source1.hasOwnProperty(property)) {\n      if (property === \"_static\") {\n        _static = source1[property];\n\n        if (!excludeProtect) {\n          destination[property] = _static.slice(); // make a copy\n        }\n      } else {\n        destination[property] = source1[property];\n      }\n    }\n  }\n\n  for (var property in source2) {\n    if (source1.hasOwnProperty(property) && source2.hasOwnProperty(property) && _static.indexOf(property) === -1 && property != \"_protect\") {\n      // Changed from extend here (2 => 1)\n      destination[property] = source2[property];\n    }\n  }\n\n  return destination;\n}\n\n//# sourceURL=webpack:///./src/util/ObjectHelpers.js?");

/***/ }),

/***/ "./src/util/ObjectPool.js":
/*!********************************!*\
  !*** ./src/util/ObjectPool.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ObjectPool; });\nclass ObjectPool {\n  constructor(Cls, n, ...args) {\n    this.Cls = Cls;\n    this.args = args;\n    this.objs = [];\n    this.usedObjs = [];\n\n    if (typeof n !== 'number' || n < 0) {\n      throw Error(\"n must be a number >= 0\");\n    }\n\n    for (let i = 0; i < n; i++) {\n      this._allocate();\n    }\n\n    throw Error(\"DON'T USE ObjectPool, ObjectPool.init FUNCTION NEEDS OPTIMIZING\");\n  }\n\n  _allocate() {\n    let obj = new this.Cls(...this.args);\n    this.objs.push(obj);\n    return obj;\n  }\n\n  init() {\n    for (let i = 0; i < this.objs.length; i++) {\n      if (this.usedObjs.indexOf(i) === -1) {\n        this.usedObjs.push(i);\n        return this.objs[i];\n      }\n    } // Didn't find an unused object, create a new one\n\n\n    this.usedObjs.push(this.objs.length);\n    return this._allocate();\n  }\n\n  free(obj) {\n    let i = this.objs.indexOf(obj);\n    if (i === -1) throw Error(\"obj not in ObjectPool\");\n    let ii = this.usedObjs.indexOf(i);\n    if (ii === -1) throw Error(\"obj is not used (invalid free)\");\n    this.usedObjs.splice(ii, 1);\n  }\n\n  freeAll() {\n    this.usedObjs = [];\n  }\n\n}\n\n//# sourceURL=webpack:///./src/util/ObjectPool.js?");

/***/ }),

/***/ "./src/util/SerializedObject.js":
/*!**************************************!*\
  !*** ./src/util/SerializedObject.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ObjectHelpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ObjectHelpers */ \"./src/util/ObjectHelpers.js\");\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\nconst SerializedObject = (SuperClass, type, SCHEMA) => {\n  // generate a *unique* data symbol for each class\n  let _data = Symbol('data');\n\n  if (!SuperClass) {\n    SuperClass = Object;\n  }\n\n  if (SCHEMA === undefined) {\n    throw Error(\"SCHEMA can't be undefined\");\n  }\n\n  return class extends SuperClass {\n    constructor() {\n      super(...arguments);\n\n      if (SuperClass !== Object && !super.updateData) {\n        throw Error(\"Super class must implement updateData (Should inherit from SerializedObject)\");\n      }\n\n      if (SuperClass !== Object && !super.onUpdateData) {\n        throw Error(\"Super class must implement onUpdateData (Should inherit from SerializedObject)\");\n      }\n\n      if (SuperClass !== Object && !super.onChangeData) {\n        throw Error(\"Super class must implement onChangeData (Should inherit from SerializedObject)\");\n      }\n\n      this[_data] = Object(_ObjectHelpers__WEBPACK_IMPORTED_MODULE_0__[\"mask\"])(_objectSpread({\n        _static: []\n      }, SCHEMA), arguments[0]); // create getters and setters\n\n      for (let p in this[_data]) {\n        if (p == '_static') continue;\n        let o = this;\n        Object.defineProperty(this, p, {\n          get: () => this[_data][p],\n          set: v => {\n            if (this[_data]._static.includes(p)) {\n              throw Error(`Property \"${p}\" is static and cannot be updated`);\n            }\n\n            this[_data][p] = v;\n            this.onChangeData(p, v);\n          }\n        });\n      }\n    }\n\n    get type() {\n      return type;\n    }\n\n    toData() {\n      return _objectSpread({}, super.toData ? super.toData() : {}, Object(_ObjectHelpers__WEBPACK_IMPORTED_MODULE_0__[\"mask\"])(SCHEMA, this[_data], true), {\n        type\n      });\n    }\n\n    refreshData() {\n      this.updateData(this.toData(), true);\n    }\n\n    updateData(data, triggerCallbacks = false) {\n      this[_data] = Object(_ObjectHelpers__WEBPACK_IMPORTED_MODULE_0__[\"mask\"])(this[_data], data);\n\n      if (triggerCallbacks === true) {\n        for (let k in this[_data]) {\n          this.onChangeData(k, this[k]);\n        }\n      }\n\n      if (SuperClass !== Object) {\n        super.updateData(...arguments);\n      } else {\n        // Only invoke callback in top-level class (after all data has been updated)\n        this.onUpdateData();\n      }\n    }\n\n    onUpdateData() {\n      if (SuperClass !== Object) {\n        super.onUpdateData();\n      }\n    }\n\n    onChangeData(k, v) {\n      if (SuperClass !== Object) {\n        super.onChangeData(...arguments);\n      }\n    }\n\n  };\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (SerializedObject);\n\n//# sourceURL=webpack:///./src/util/SerializedObject.js?");

/***/ }),

/***/ "./src/util/UUID.js":
/*!**************************!*\
  !*** ./src/util/UUID.js ***!
  \**************************/
/*! exports provided: generateUuid */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"generateUuid\", function() { return generateUuid; });\nconst s4 = () => {\n  return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n};\n\nfunction generateUuid() {\n  return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n}\n\n//# sourceURL=webpack:///./src/util/UUID.js?");

/***/ }),

/***/ "./src/world/BodyPool.js":
/*!*******************************!*\
  !*** ./src/world/BodyPool.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return BodyPool; });\n/* harmony import */ var _util_ObjectPool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/ObjectPool */ \"./src/util/ObjectPool.js\");\n/* harmony import */ var cannon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cannon */ \"cannon\");\n/* harmony import */ var cannon__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(cannon__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ChunkUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ChunkUtils */ \"./src/world/ChunkUtils.js\");\n\n\n\nclass BodyPool extends _util_ObjectPool__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(n, ...args) {\n    super(cannon__WEBPACK_IMPORTED_MODULE_1___default.a.Body, n, ...args);\n    this.ids = {}; // chunkKey(x, y, z): id\n  }\n\n  init(x, y, z) {\n    let key = Object(_ChunkUtils__WEBPACK_IMPORTED_MODULE_2__[\"chunkKey\"])(x, y, z);\n    let body = super.init();\n    let id = this.ids[key];\n\n    if (id === undefined) {\n      id = cannon__WEBPACK_IMPORTED_MODULE_1___default.a.Body.idCounter++;\n      this.ids[key] = id;\n    }\n\n    body.id = id;\n    body.position.set(x, y, z); //body.computeAABB();\n\n    return body;\n  }\n\n}\n\n//# sourceURL=webpack:///./src/world/BodyPool.js?");

/***/ }),

/***/ "./src/world/Chunk.js":
/*!****************************!*\
  !*** ./src/world/Chunk.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Chunk; });\n/* harmony import */ var _Defs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Defs */ \"./src/Defs.js\");\n/* harmony import */ var _util_SerializedObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/SerializedObject */ \"./src/util/SerializedObject.js\");\n/* harmony import */ var _util_MemoryBackedObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/MemoryBackedObject */ \"./src/util/MemoryBackedObject.js\");\n/* harmony import */ var _StructDefs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../StructDefs */ \"./src/StructDefs.js\");\n/* harmony import */ var _ChunkUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ChunkUtils */ \"./src/world/ChunkUtils.js\");\n/* harmony import */ var cannon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cannon */ \"cannon\");\n/* harmony import */ var cannon__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(cannon__WEBPACK_IMPORTED_MODULE_5__);\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\n\nconst MAPENTRY_SIZE = 2;\nclass Chunk extends Object(_util_MemoryBackedObject__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Object(_util_SerializedObject__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Object, 'CHUNK', {\n  p: 0,\n  q: 0,\n  r: 0\n}), _StructDefs__WEBPACK_IMPORTED_MODULE_3__[\"ChunkStruct\"]) {\n  constructor() {\n    super(...arguments);\n    this.active = false;\n    this.isDirty = false;\n    this.loaded = false;\n    this.body = this._createBody();\n  }\n\n  get key() {\n    return Object(_ChunkUtils__WEBPACK_IMPORTED_MODULE_4__[\"chunkKey\"])(this.p, this.q, this.r);\n  }\n\n  initMemory() {\n    this.active = true;\n  }\n\n  onDelete() {\n    this.active = false;\n  }\n\n  adjacent(p, q, r) {\n    return Math.max(Math.abs(this.p - p), Math.abs(this.q - q), Math.abs(this.r - r)) <= 1;\n  }\n\n  getMap() {\n    let mapPos = this.getMemoryValue('map.data');\n    let size = this.getMemoryValue('map.size');\n\n    if (mapPos) {\n      return new Uint8Array(Module.HEAPU32.buffer, mapPos, size * MAPENTRY_SIZE);\n    } else {\n      console.warn(\"Chunk map is null\", this.p, this.q, this.r);\n      return null;\n    }\n  }\n\n  getBlock(x, y, z, map) {\n    let [xx, yy, zz] = Object(_ChunkUtils__WEBPACK_IMPORTED_MODULE_4__[\"toChunkCoords\"])(x, y, z, this.p, this.q, this.r);\n    let index = xx + yy * _Defs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CHUNK_SIZE + zz * _Defs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CHUNK_SIZE * _Defs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CHUNK_SIZE;\n    if (index < 0 || index >= Math.pow(_Defs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CHUNK_SIZE, 3)) throw Error(\"Chunk index OOB\");\n    return (map || this.getMap()).slice(index * MAPENTRY_SIZE, (index + 1) * MAPENTRY_SIZE);\n  }\n\n  setBlock(x, y, z, state, w) {\n    let [xx, yy, zz] = Object(_ChunkUtils__WEBPACK_IMPORTED_MODULE_4__[\"toChunkCoords\"])(x, y, z, this.p, this.q, this.r);\n    let index = xx + yy * _Defs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CHUNK_SIZE + zz * _Defs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CHUNK_SIZE * _Defs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CHUNK_SIZE;\n    if (index < 0 || index >= Math.pow(_Defs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CHUNK_SIZE, 3)) throw Error(\"Chunk index OOB\");\n    this.getMap().set([state, w], index * MAPENTRY_SIZE);\n    this.dirty();\n  }\n\n  dirty() {\n    this.setMemoryValue('dirty', 1);\n    this.isDirty = true;\n  }\n\n  toData() {\n    let map = this.getMap();\n    return _objectSpread({}, super.toData(), {\n      map: map.buffer.slice(map.byteOffset, map.byteOffset + map.byteLength)\n    });\n  }\n\n  updateData(data) {\n    super.updateData(...arguments);\n\n    if (data.hasOwnProperty('map') && this.active) {\n      this.getMap().set(new Uint8Array(data.map));\n      this.dirty();\n      this.loaded = true;\n    }\n  }\n\n  _createBody() {\n    let halfChunk = _Defs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WORLD_SCALE * _Defs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CHUNK_SIZE / 2;\n    let shape = new cannon__WEBPACK_IMPORTED_MODULE_5___default.a.Box(new cannon__WEBPACK_IMPORTED_MODULE_5___default.a.Vec3(halfChunk, halfChunk, halfChunk));\n    shape.type = _Defs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SHAPE_TYPE_CHUNK;\n    let body = new cannon__WEBPACK_IMPORTED_MODULE_5___default.a.Body({\n      shape,\n      type: cannon__WEBPACK_IMPORTED_MODULE_5___default.a.Body.STATIC,\n      position: new cannon__WEBPACK_IMPORTED_MODULE_5___default.a.Vec3( // subtract 0.5 a block since the blocks are rendered with their point in the center\n      (this.p * _Defs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CHUNK_SIZE - 0.5) * _Defs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WORLD_SCALE, (this.r * _Defs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CHUNK_SIZE - 0.5) * _Defs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WORLD_SCALE, (this.q * _Defs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CHUNK_SIZE - 0.5) * _Defs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WORLD_SCALE)\n    });\n    body.chunk = this;\n    body.shapeOffsets[0].set(halfChunk, halfChunk, halfChunk);\n    body.computeAABB();\n    body.updateBoundingRadius();\n    return body;\n  }\n\n}\n\n//# sourceURL=webpack:///./src/world/Chunk.js?");

/***/ }),

/***/ "./src/world/ChunkLoader.js":
/*!**********************************!*\
  !*** ./src/world/ChunkLoader.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ChunkLoader; });\nclass ChunkLoader {\n  constructor() {}\n\n  async loadChunk(chunk) {}\n\n  unloadChunk(chunk) {}\n\n}\n\n//# sourceURL=webpack:///./src/world/ChunkLoader.js?");

/***/ }),

/***/ "./src/world/ChunkManager.js":
/*!***********************************!*\
  !*** ./src/world/ChunkManager.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ChunkManager; });\n/* harmony import */ var _Defs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Defs */ \"./src/Defs.js\");\n/* harmony import */ var _Chunk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Chunk */ \"./src/world/Chunk.js\");\n/* harmony import */ var _ChunkUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ChunkUtils */ \"./src/world/ChunkUtils.js\");\n\n\n\nclass ChunkManager {\n  constructor(worldInterface, chunkLoader) {\n    this.worldInterface = worldInterface; // this.physics = physics;\n\n    this.chunkLoader = chunkLoader;\n    this.chunks = {};\n  }\n\n  containsChunk(p, q, r) {\n    return Object(_ChunkUtils__WEBPACK_IMPORTED_MODULE_2__[\"chunkKey\"])(p, q, r) in this.chunks;\n  }\n\n  getChunk(p, q, r) {\n    return this.chunks[Object(_ChunkUtils__WEBPACK_IMPORTED_MODULE_2__[\"chunkKey\"])(p, q, r)];\n  }\n\n  getChunkByChunkKey(key) {\n    return this.chunks[key];\n  }\n\n  removeChunk(chunk) {\n    if (!this.containsChunk(chunk.p, chunk.q, chunk.r)) throw Error(\"Chunk does not exist\");\n    this.chunkLoader.unloadChunk(chunk);\n\n    this._deleteChunk(chunk);\n\n    delete this.chunks[Object(_ChunkUtils__WEBPACK_IMPORTED_MODULE_2__[\"chunkKey\"])(chunk.p, chunk.q, chunk.r)]; // this.physics.removeBody(chunk.body);\n\n    chunk.body = null;\n  }\n\n  async createChunk(p, q, r) {\n    if (this.containsChunk(p, q, r)) throw Error(\"Chunk already exists\");\n\n    let chunk = this._initChunk(p, q, r);\n\n    this.chunks[Object(_ChunkUtils__WEBPACK_IMPORTED_MODULE_2__[\"chunkKey\"])(p, q, r)] = chunk;\n    await this.chunkLoader.loadChunk(chunk); // this.physics.addBody(chunk.body);\n\n    return chunk;\n  }\n\n  _initChunk(p, q, r) {\n    let mem = this.worldInterface.get_unused_chunk_mem_location();\n    this.worldInterface.init_chunk(mem, p, q, r);\n    let chunk = new _Chunk__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n      p,\n      q,\n      r\n    });\n    chunk.assignMemory(mem);\n    return chunk;\n  }\n\n  _deleteChunk(chunk) {\n    chunk.onDelete();\n    this.worldInterface.delete_chunk(chunk.getMemoryPosition());\n  }\n\n}\n\n//# sourceURL=webpack:///./src/world/ChunkManager.js?");

/***/ }),

/***/ "./src/world/ChunkUtils.js":
/*!*********************************!*\
  !*** ./src/world/ChunkUtils.js ***!
  \*********************************/
/*! exports provided: chunkKey, chunked, isBlockSolid, toChunkCoords */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"chunkKey\", function() { return chunkKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"chunked\", function() { return chunked; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isBlockSolid\", function() { return isBlockSolid; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toChunkCoords\", function() { return toChunkCoords; });\n/* harmony import */ var _Defs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Defs */ \"./src/Defs.js\");\n\nfunction chunkKey(p, q, r) {\n  return `${p}:${q}:${r}`;\n}\nfunction chunked(n) {\n  return Math.floor(n / _Defs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CHUNK_SIZE);\n}\nfunction isBlockSolid(block) {\n  return block[1] > 0;\n}\nfunction toChunkCoords(x, y, z, p, q, r) {\n  return [x - p * _Defs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CHUNK_SIZE, y - r * _Defs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CHUNK_SIZE, z - q * _Defs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CHUNK_SIZE];\n}\n\n//# sourceURL=webpack:///./src/world/ChunkUtils.js?");

/***/ }),

/***/ "./src/world/DbChunkLoader.js":
/*!************************************!*\
  !*** ./src/world/DbChunkLoader.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return DbChunkLoader; });\n/* harmony import */ var _GenChunkLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GenChunkLoader */ \"./src/world/GenChunkLoader.js\");\n/* harmony import */ var _WorldStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WorldStore */ \"./src/world/WorldStore.js\");\n\n\nclass DbChunkLoader extends _GenChunkLoader__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(worldInterface, worldStore) {\n    super(worldInterface);\n    this.worldStore = worldStore;\n  }\n\n  async loadChunk(chunk) {\n    // check if in store, if not generate new chunk\n    let chunkData = await this.worldStore.loadChunk(chunk.p, chunk.q, chunk.r);\n\n    if (chunkData) {\n      chunk.updateData(chunkData);\n    } else {\n      // chunk didn't exist, generate it\n      super.loadChunk(chunk);\n    }\n  }\n\n}\n\n//# sourceURL=webpack:///./src/world/DbChunkLoader.js?");

/***/ }),

/***/ "./src/world/GenChunkLoader.js":
/*!*************************************!*\
  !*** ./src/world/GenChunkLoader.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return GenChunkLoader; });\n/* harmony import */ var _ChunkLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ChunkLoader */ \"./src/world/ChunkLoader.js\");\n\nclass GenChunkLoader extends _ChunkLoader__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(worldInterface) {\n    super();\n    this.worldInterface = worldInterface;\n  }\n\n  async loadChunk(chunk) {\n    this.worldInterface.gen_chunk(chunk.getMemoryPosition());\n    chunk.dirty();\n  }\n\n}\n\n//# sourceURL=webpack:///./src/world/GenChunkLoader.js?");

/***/ }),

/***/ "./src/world/WorldNarrowphase.js":
/*!***************************************!*\
  !*** ./src/world/WorldNarrowphase.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return WorldNarrowphase; });\n/* harmony import */ var cannon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cannon */ \"cannon\");\n/* harmony import */ var cannon__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(cannon__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Defs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Defs */ \"./src/Defs.js\");\n/* harmony import */ var _ChunkUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ChunkUtils */ \"./src/world/ChunkUtils.js\");\n/* harmony import */ var _physicsMaterial__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./physicsMaterial */ \"./src/world/physicsMaterial.js\");\n/* harmony import */ var _BodyPool__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./BodyPool */ \"./src/world/BodyPool.js\");\n\n\n\n\n\nconst halfBlockSize = new cannon__WEBPACK_IMPORTED_MODULE_0___default.a.Vec3(_Defs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].WORLD_SCALE / 2, _Defs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].WORLD_SCALE / 2, _Defs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].WORLD_SCALE / 2);\nconst blockShape = new cannon__WEBPACK_IMPORTED_MODULE_0___default.a.Box(halfBlockSize);\nclass WorldNarrowphase extends cannon__WEBPACK_IMPORTED_MODULE_0___default.a.Narrowphase {\n  constructor(...args) {\n    super(...args); // this.bodyPool = new BodyPool(15, {\n    //     type: CANNON.Body.STATIC,\n    //     mass: 0,\n    //     material: physicsMaterial,\n    //     shape: blockShape\n    // });\n\n    this[_Defs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].SHAPE_TYPE_CHUNK | cannon__WEBPACK_IMPORTED_MODULE_0___default.a.Shape.types.SPHERE] = this[_Defs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].SHAPE_TYPE_CHUNK | cannon__WEBPACK_IMPORTED_MODULE_0___default.a.Shape.types.BOX] = this[_Defs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].SHAPE_TYPE_CHUNK | cannon__WEBPACK_IMPORTED_MODULE_0___default.a.Shape.types.COMPOUND] = this[_Defs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].SHAPE_TYPE_CHUNK | cannon__WEBPACK_IMPORTED_MODULE_0___default.a.Shape.types.CONVEXPOLYHEDRON] = this[_Defs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].SHAPE_TYPE_CHUNK | cannon__WEBPACK_IMPORTED_MODULE_0___default.a.Shape.types.HEIGHTFIELD] = this[_Defs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].SHAPE_TYPE_CHUNK | cannon__WEBPACK_IMPORTED_MODULE_0___default.a.Shape.types.PARTICLE] = this[_Defs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].SHAPE_TYPE_CHUNK | cannon__WEBPACK_IMPORTED_MODULE_0___default.a.Shape.types.CYLINDER] = this[_Defs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].SHAPE_TYPE_CHUNK | cannon__WEBPACK_IMPORTED_MODULE_0___default.a.Shape.types.TRIMESH] = this.doChunkCollision;\n  }\n\n  chunkAABBCollision(chunkAABB, otherAABB, callback) {\n    if (chunkAABB.overlaps(otherAABB) === false) return;\n    let low = otherAABB.lowerBound;\n    let high = otherAABB.upperBound;\n\n    for (let x = Math.floor(low.x); x <= Math.ceil(high.x); x++) {\n      if (x < chunkAABB.lowerBound.x || x >= chunkAABB.upperBound.x) continue;\n\n      for (let y = Math.floor(low.y); y <= Math.ceil(high.y); y++) {\n        if (y < chunkAABB.lowerBound.y || y >= chunkAABB.upperBound.y) continue;\n\n        for (let z = Math.floor(low.z); z <= Math.ceil(high.z); z++) {\n          if (z < chunkAABB.lowerBound.z || z >= chunkAABB.upperBound.z) continue;\n          let br = callback(x, y, z);\n          if (br) return true;\n        }\n      }\n    }\n  }\n\n  doChunkCollision(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {\n    // console.log(bi.aabb.lowerBound);\n    let map = bj.chunk.getMap();\n    let n = [];\n    let br = this.chunkAABBCollision(bj.aabb, bi.aabb, (x, y, z) => {\n      if (Object(_ChunkUtils__WEBPACK_IMPORTED_MODULE_2__[\"isBlockSolid\"])(bj.chunk.getBlock(x, y, z, map))) {\n        //let blockBody = this.bodyPool.init(x, y, z);\n        let blockBody = new cannon__WEBPACK_IMPORTED_MODULE_0___default.a.Body({\n          type: cannon__WEBPACK_IMPORTED_MODULE_0___default.a.Body.STATIC,\n          mass: 0,\n          material: _physicsMaterial__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n          shape: blockShape,\n          position: new cannon__WEBPACK_IMPORTED_MODULE_0___default.a.Vec3(x, y, z)\n        });\n        n.push([x, y, z]); // override current contact material with one from material pairing w blockBody\n\n        this.currentContactMaterial = this.world.getContactMaterial(blockBody.material, bi.material) || this.currentContactMaterial; // the order of arguments is dependent on the order of types\n\n        if (cannon__WEBPACK_IMPORTED_MODULE_0___default.a.Shape.types.BOX < si.type) {\n          return this[cannon__WEBPACK_IMPORTED_MODULE_0___default.a.Shape.types.BOX | si.type](blockShape, si, blockBody.position, xi, blockBody.quaternion, qi, blockBody, bi, blockShape, si, justTest);\n        } else {\n          return this[cannon__WEBPACK_IMPORTED_MODULE_0___default.a.Shape.types.BOX | si.type](si, blockShape, xi, blockBody.position, qi, blockBody.quaternion, bi, blockBody, si, blockShape, justTest);\n        }\n      }\n    }); //console.log(n.length);\n\n    if (br && justTest) return true;\n  }\n\n  postStep() {// this.bodyPool.freeAll();\n  }\n\n}\n\n//# sourceURL=webpack:///./src/world/WorldNarrowphase.js?");

/***/ }),

/***/ "./src/world/WorldStore.js":
/*!*********************************!*\
  !*** ./src/world/WorldStore.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return WorldStore; });\n/* harmony import */ var sqlite3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sqlite3 */ \"sqlite3\");\n/* harmony import */ var sqlite3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sqlite3__WEBPACK_IMPORTED_MODULE_0__);\n\n\nconst _sqlite3 = sqlite3__WEBPACK_IMPORTED_MODULE_0___default.a.verbose();\n\nclass WorldStore {\n  constructor(dbName = ':memory:') {\n    this.db = new _sqlite3.Database(dbName, err => {\n      if (err) throw err;\n    });\n    this.createDb();\n  }\n\n  createDb() {\n    this.db.exec(`\n            CREATE TABLE Chunks (\n                p INTEGER,\n                q INTEGER,\n                r INTEGER,\n                map BLOB,\n                PRIMARY KEY (p, q, r)\n            );\n            `, err => {\n      if (err) throw err;\n    });\n  }\n\n  containsChunk(p, q, r) {\n    return new Promise((resolve, reject) => {\n      this.db.get(`SELECT EXISTS(SELECT 1 FROM Chunks WHERE p = ? AND q = ? AND r = ?) AS 'Exists'`, p, q, r, (err, result) => {\n        if (err) reject(err);else resolve(result['Exists'] === 1);\n      });\n    });\n  }\n\n  loadChunk(p, q, r) {\n    return new Promise((resolve, reject) => {\n      this.db.get(`SELECT * FROM Chunks WHERE p = ? AND q = ? AND r = ?`, p, q, r, (err, chunk) => {\n        if (err) reject(err);else resolve(chunk);\n      });\n    });\n  }\n\n  saveChunk({\n    p,\n    q,\n    r,\n    map\n  }) {\n    this.db.run(`\n            INSERT INTO Chunks (p, q, r, map)\n                VALUES ($p, $q, $r, $map)\n                ON CONFLICT(p, q, r) DO UPDATE SET map=$map;`, {\n      $p: p,\n      $q: q,\n      $r: r,\n      $map: new Buffer(map)\n    }, err => {\n      if (err) throw err;\n      console.log(\"Saved chunk\");\n    });\n  }\n\n}\n\n//# sourceURL=webpack:///./src/world/WorldStore.js?");

/***/ }),

/***/ "./src/world/WorldVoxelPhysics.js":
/*!****************************************!*\
  !*** ./src/world/WorldVoxelPhysics.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return WorldVoxelPhysics; });\n/* harmony import */ var cannon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cannon */ \"cannon\");\n/* harmony import */ var cannon__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(cannon__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Defs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Defs */ \"./src/Defs.js\");\n/* harmony import */ var _WorldNarrowphase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WorldNarrowphase */ \"./src/world/WorldNarrowphase.js\");\n/* harmony import */ var _physicsMaterial__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./physicsMaterial */ \"./src/world/physicsMaterial.js\");\n/* harmony import */ var voxel_physics_engine__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! voxel-physics-engine */ \"./node_modules/voxel-physics-engine/src/index.js\");\n/* harmony import */ var voxel_physics_engine__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(voxel_physics_engine__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _ChunkUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ChunkUtils */ \"./src/world/ChunkUtils.js\");\n\n\n\n\n\n\nclass WorldVoxelPhysics {\n  constructor(chunkManager) {\n    this.lastUpdate = 0;\n    this.timeStep = 1 / _Defs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].PHYSICS_STEP_FREQUENCY;\n    this.phys = voxel_physics_engine__WEBPACK_IMPORTED_MODULE_4___default()({\n      gravity: [0, -10, 0]\n    }, (x, y, z) => {\n      let chunk = chunkManager.getChunk(Object(_ChunkUtils__WEBPACK_IMPORTED_MODULE_5__[\"chunked\"])(x), Object(_ChunkUtils__WEBPACK_IMPORTED_MODULE_5__[\"chunked\"])(z), Object(_ChunkUtils__WEBPACK_IMPORTED_MODULE_5__[\"chunked\"])(y));\n      if (!chunk) return true;\n      return Object(_ChunkUtils__WEBPACK_IMPORTED_MODULE_5__[\"isBlockSolid\"])(chunk.getBlock(x, y, z));\n    }, (x, y, z) => false);\n  }\n\n  addBody() {\n    this.phys.addBody(...arguments);\n  }\n\n  update(now) {\n    let start = Date.now();\n\n    if (this.lastUpdate === 0) {\n      this.phys.tick(this.timeStep);\n    } else {\n      let delta = now - this.lastUpdate;\n\n      if (delta >= 0) {\n        this.phys.tick(delta);\n      }\n    }\n\n    this.lastUpdate = now;\n  }\n\n}\n\n//# sourceURL=webpack:///./src/world/WorldVoxelPhysics.js?");

/***/ }),

/***/ "./src/world/physicsMaterial.js":
/*!**************************************!*\
  !*** ./src/world/physicsMaterial.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var cannon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cannon */ \"cannon\");\n/* harmony import */ var cannon__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(cannon__WEBPACK_IMPORTED_MODULE_0__);\n\nconst physicsMaterial = new cannon__WEBPACK_IMPORTED_MODULE_0___default.a.Material(\"slipperyMaterial\");\n/* harmony default export */ __webpack_exports__[\"default\"] = (physicsMaterial);\n\n//# sourceURL=webpack:///./src/world/physicsMaterial.js?");

/***/ }),

/***/ "cannon":
/*!*************************!*\
  !*** external "cannon" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"cannon\");\n\n//# sourceURL=webpack:///external_%22cannon%22?");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"events\");\n\n//# sourceURL=webpack:///external_%22events%22?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");\n\n//# sourceURL=webpack:///external_%22fs%22?");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"path\");\n\n//# sourceURL=webpack:///external_%22path%22?");

/***/ }),

/***/ "socket.io":
/*!****************************!*\
  !*** external "socket.io" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"socket.io\");\n\n//# sourceURL=webpack:///external_%22socket.io%22?");

/***/ }),

/***/ "sqlite3":
/*!**************************!*\
  !*** external "sqlite3" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"sqlite3\");\n\n//# sourceURL=webpack:///external_%22sqlite3%22?");

/***/ })

/******/ });